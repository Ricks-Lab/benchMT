#!/usr/bin/env python3
""" benchMT  -  SETI multi-threaded MB/AP Benchmark Tool

    This tool will extract the total number of CPU cores/threads and GPU platforms from the user's
    environment and utilize them in running a list of apps/args specified in the benchCFG file.
    Using less than the total number of CPU threads can be specified in the command line.  This
    tool will read a list of MB/AP apps/args from the BenchCFG file and search for the specified
    MB/AP apps in the APP_CPU and APP_GPU directories to validate and determine platform.  It will
    then leverage allocated threads, as specified, to run all benchmark jobs, storing results in
    the testData directory.  Use the *--help* option to get a description of valid command line
    arguments. In support of automation, some command line arguments can be specified as modes in
    the BenchCFG file.

    By default, a summary list of all jobs will update in the display as the program progresses.  If
    there are a large number of jobs, then this display may not be useful and the *--display_slots*
    option can be used to display the status of each slot as the program progresses.  In some cases,
    there will be too many slots to display, and the *--display_compact* option can used to further
    optimize the progress display.

    You may need to use the *--boinc_home* command option to specify the BOINC home directory, which
    is required, since boinccmd is used. An alternative BenchCFG file can be specified with the
    command line option *--cfg_file filename*.

    The *--lsgpu* command option can be used to display information and capability of all installed
    GPUs. The *--purge_kernels* can be used to purge all compiled kernels from the *benchMT* working
    directory.

    All WUs in the WU_test directory will be used in the creation of jobs to be run, unless the
    *--std_signals* option is used, in which case, WUs in the WU_std_signal will be used.  The
    APPS_GPU and APPS_CPU directories can have more apps than are specified to run in the BenchCFG
    file, but must contain apps specified in BenchCFG.  The APPS_REF directory must contain a single
    CPU reference app with a file prefix of "ref-cpu.".  The stock CPU app is suggested, as this is
    only used to test integrity of the results.  Elapsed time analysis is expected to be limited to
    apps/arg combinations specified in BenchCFG.  The generation of reference results can be skipped
    with the *--no_ref* option or forced with the *--force_ref* option. The *--energy* option can be
    used if your system has amdgpu drivers with compatible GPUs to give the energy used in running a
    task.  In order to correctly associate a GPU card number with a BOINC device number, you must
    specify this with the *--devmap B:C,B2:C2* option.  I know of no robust way to make this mapping
    other than manually running each card individually and observing which card is being used.  If
    you are running an AstroPulse app, you must specify the *--astropulse* option in order for it to
    run properly.

    The results will be stored in a unique subdir of the testData directory. There is an overall run
    log txt file, a psv file useful for importing into an analytics tools, and the sah and stderr
    files for each job run. A run name can be specified with the *--run_name* command line option.
    This name will be included in the name of the testData subdirectory for the current run.

    Copyright (C) 2018  RueiKe

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""
__author__ = 'RueiKe'
__copyright__ = 'Copyright (C) 2018 RueiKe'
__credits__ = ['Keith Myers - Testing and Verification']
__license__ = 'GNU General Public License'
__program_name__ = 'benchMT'
__version__ = 'v2.0.0'
__maintainer__ = 'RueiKe'
__status__ = 'Stable Release'
__docformat__ = 'reStructuredText'

import argparse
import re
import subprocess
import shlex
import socket
import os
import platform
import sys
import time
from datetime import datetime
from uuid import uuid4
import glob
import shutil
from pathlib import Path


# pylint: disable=multiple-statements
# pylint: disable=line-too-long

class ObjDict(dict):
    """
    Allow access of dictionary keys by key name.
    """
    # pylint: disable=attribute-defined-outside-init
    def __getattr__(self, name):
        if name in self:
            return self[name]
        else:
            raise AttributeError("No such attribute: " + name)

    def __setattr__(self, name, value):
        self[name] = value

    def __delattr__(self, name):
        if name in self:
            del self[name]
        else:
            raise AttributeError("No such attribute: " + name)


class MbConst(ObjDict):
    """
    Defines benchMT constants used through out the code.
    """
    # pylint: disable=attribute-defined-outside-init
    # pylint: disable=too-many-instance-attributes
    def __init__(self):
        # pylint: disable=attribute-defined-outside-init
        super().__init__({'boinc_home': '/home/boinc/BOINC/',
                          'cpu_app_subdir': 'APPS_CPU/',
                          'gpu_app_subdir': 'APPS_GPU/',
                          'ref_app_subdir': 'APPS_REF/',
                          'ref_results_subdir': 'REF_RESULTS/',
                          'wu_subdir': 'WU_test/',
                          'std_signal_subdir': 'WU_std_signal/',
                          'testdata_subdir': 'testData/',
                          'workdir_subdir': 'workdir/',
                          'slots_subdir': 'Slots/',
                          'command_line_filename': 'BenchCFG',
                          'boinccmd': 'boinccmd',
                          'template_file': 'init_data.xml.template',
                          'coproc_file_name': 'coproc_info.xml',
                          'wu_cmp': 'rescmpv5_l',
                          'suspend_args': ['boinccmd --set_gpu_mode never 172800',
                                           'boinccmd --set_run_mode never 172800'],
                          'resume_args': ['boinccmd --set_gpu_mode never 1',
                                          'boinccmd --set_run_mode never 1'],
                          'activeWU': 'work_unit.sah',
                          'activeAPWU': 'in.dat',
                          'DEBUG': False,
                          'noBS': False,
                          'env': None,
                          # Items required for Energy feature
                          'card_root': '/sys/class/drm/',
                          'hwmon_sub': 'hwmon/hwmon',
                          # System command definitions
                          'cmd_lspci': None,
                          'cmd_lshw': None,
                          'cmd_lscpu': None,
                          'cmd_clinfo': None,
                          'cmd_time': None,
                          'cmd_lsb_release': None,
                          'cmd_nvidia_smi': None})

    def __repr__(self):
        return '{} - {} items'.format(self.__class__.__name__, len(self))

    def __str__(self):
        ret_str = '{'
        for k, v in self.items():
            pre_str = '' if ret_str == '{' else ', '
            k_str = f'\'{k}\'' if isinstance(k, str) else f'{k}'
            v_str = f'\'{v}\'' if isinstance(v, str) else f'{v}'
            ret_str += '{}{}: {}'.format(pre_str, k_str, v_str)
        ret_str += '}'
        return ret_str

    def print(self):
        """
        Print all elements an MB_Const object.
        :return: None
        :rtype: None
        """
        for k, v in self.items():
            print('MbConst.{}: [{}]'.format(k, v))
        return


MB_CONST = MbConst()


class CfgModes:
    """
    Defines benchMT configuration modes.
    """
    def __init__(self):
        self.modes = {'yes': None,
                      'run_name': None,
                      'boinc_home': None,
                      'noBS': None,
                      'display_compact': None,
                      'display_slots': None,
                      'num_repetitions': None,
                      'max_threads': None,
                      'max_gpus': None,
                      'gpu_devices': None,
                      'devmap': None,
                      'std_signals': None,
                      'no_ref': None,
                      'force_ref': None,
                      'energy': None,
                      'astropulse': None}
        self.type = {'yes': bool,
                     'run_name': str,
                     'boinc_home': str,
                     'noBS': bool,
                     'display_compact': bool,
                     'display_slots': bool,
                     'num_repetitions': int,
                     'max_threads': int,
                     'max_gpus': int,
                     'gpu_devices': str,
                     'devmap': str,
                     'std_signals': bool,
                     'no_ref': bool,
                     'force_ref': bool,
                     'energy': bool,
                     'astropulse': bool}

    def set_mode(self, mode_name, mode_value):
        """
        Set given mode to the specified value.
        :param mode_name: Name of the mode to be updated
        :type mode_name: str
        :param mode_value: Value
        :type mode_value: str
        :return: True if successful
        :rtype: bool
        """
        if mode_name not in self.modes:
            return False
        if mode_name not in self.type:
            return False

        if self.type[mode_name] is bool:
            if mode_value == 'True' or mode_value == 'False':
                self.modes[mode_name] = True if mode_value == 'True' else False
                return True
        elif self.type[mode_name] is int:
            if re.fullmatch('[-]*[0-9]+', mode_value):
                self.modes[mode_name] = int(mode_value)
                return True
        elif self.type[mode_name] is str:
            self.modes[mode_name] = mode_value
            return True
        return False

    def mode_value(self, mode_name):
        """
        Get value for given mode.
        :param mode_name:
        :type mode_name: str
        :return:  value
        :rtype: Union([str, bool])
        """
        if mode_name not in self.modes.keys():
            return False
        return self.modes[mode_name]

    def print(self):
        """
        Print modes.
        :return: None
        :rtype: None
        """
        for m, v in self.modes.items():
            print('CFG_mode: {} {}'.format(m, str(v)))


class BenchEnv:
    """
    benchMT environment parameters.
    """
    # pylint: disable=attribute-defined-outside-init
    def __init__(self):
        # pylint: disable=attribute-defined-outside-init
        self._display = {'hostname': 'Hostname: {}', 'run_name': 'Run Name: {}', 'app_mode': 'APP Mode: {}',
                         'benchMT_version': 'benchMT version: {}', 'platform': 'Platform: {}',
                         'os_desc': 'OS Description: {}', 'cpu_model': 'CPU Model: {}', 'cpu_mhz': 'CPU MHz: {}',
                         'total_cpu_cores': 'CPU Cores: {}', 'total_cpu_threads': 'CPU Threads: {}',
                         'total_gpu_count': 'GPU Count: {}', 'total_gpu_threads': 'GPU Threads: {}',
                         'gpu_devices': 'Specified GPU Device List: {}', 'devmap': 'Devices Map: {}',
                         'boinc_dev_list': 'BOINC Device List: {}', 'card_num_list': 'GPU Card Number List: {}',
                         'gpu_details': 'GPU Details:', 'current_dir': 'Current Dir: {}',
                         'slots_path': 'Slots Dir: {}', 'time_now': 'TimeNow: {}',
                         'time_now_short': 'TimeNowShort: {}', 'cpu_app_path': 'CPU App Path: {}',
                         'gpu_app_path': 'GPU App Path: {}', 'ref_app_path': 'REF App Path: {}',
                         'ref_results_path': 'Reference Results Path: {}',
                         'wu_std_signal_path': 'STD Signal WU Path: {}',
                         'wu_path': 'WU Path: {}', 'testdata_path': 'Test Data Path: {}',
                         'boinc_home': 'BOINC Home: {}', 'coproc_file': 'Coprocessor Info File: {}',
                         'repetitions': 'Repetitions: {}', 'allocated_cthreads': 'Allocated CPU Threads: {}',
                         'allocated_gthreads': 'Allocated GPU Threads: {}', 'mode_yes': '\nMode yes: {}',
                         'mode_noBS': 'Mode noBS: {}', 'mode_std_signals': 'Mode std_signals: {}',
                         'mode_display_slots': 'Mode display_slots: {}',
                         'mode_display_compact': 'Mode display_compact: {}',
                         'mode_no_ref': 'Mode no_ref: {}', 'mode_force_ref': 'Mode force_ref: {}',
                         'mode_energy': 'Mode energy: {}', 'mode_astropulse': 'Mode astropulse: {}'}
        self.sum_file_ptr = None
        self.psv_file_ptr = None
        self.prm = ObjDict({'time_now': '',
                            'time_now_short': '',
                            'hostname':  '',
                            'platform':  '',
                            'os_desc':  '',
                            'cpu_model':  '',
                            'cpu_mhz':  '',
                            'total_cpu_threads':  0,
                            'total_cpu_cores':  0,
                            'specified_max_threads':  0,
                            'total_gpu_threads':  0,
                            'total_gpu_count':  0,
                            'allocated_cthreads':  0,
                            'allocated_gthreads':  0,
                            'boinc_dev_list':  [],
                            'card_num_list':  [],
                            'specified_max_gpus':  0,
                            'gpu_devices':  [],
                            'devmap':  {},
                            'gpu_details':  [],
                            'current_dir':  '',
                            'cpu_app_path':  '',
                            'gpu_app_path':  '',
                            'ref_app_path':  '',
                            'ref_results_path':  '',
                            'wu_path':  '',
                            'wu_std_signal_path':  '',
                            'testdata_path':  '',
                            'slots_path':  '',
                            'command_line_file':  '',
                            'boinccmd':  '',
                            'wucmpcmd':  '',
                            'repetitions':  1,
                            'summary_path':  '',
                            'run_name':  '',
                            'summary_file':  '',
                            'psv_file':  '',
                            'workdir_path':  '',
                            'lockfile':  '',
                            'mode_devmap':  {},
                            'mode_gpu_devices':  [],
                            'mode_std_signals':  False,
                            'mode_display_slots':  False,
                            'mode_display_compact':  False,
                            'mode_no_ref':  False,
                            'mode_force_ref':  False,
                            'mode_energy':  False,
                            'mode_yes':  False,
                            'mode_noBS':  False,
                            'mode_astropulse':  False,
                            'boinc_home':  MB_CONST.boinc_home,
                            'init_data_template_file':  '',
                            'coproc_file':  None})

    def process_options(self, args, cfg_modes):
        """
        This function takes command line arguments and configuration modes to determine
        final operating mode of benchMT.  Command line args will over ride config file modes.
        :param args:  Command line arguments
        :param cfg_modes:  Config file modes
        :return: None
        :rtype: None
        """
        # mode_yes
        if args.yes: self.prm.mode_yes = True
        elif cfg_modes.mode_value('yes'): self.prm.mode_yes = True

        # mode_force_ref
        if args.force_ref: self.prm.mode_force_ref = True
        elif cfg_modes.mode_value('force_ref'): self.prm.mode_force_ref = True

        # mode_no_ref
        if args.no_ref: self.prm.mode_no_ref = True
        elif cfg_modes.mode_value('no_ref'): self.prm.mode_no_ref = True

        if self.prm.mode_no_ref and self.prm.mode_force_ref:
            print('ERROR: --no_ref and --force_ref are mutually exclusive.  Exiting...')
            sys.exit(-1)

        # mode_noBS
        if args.noBS: self.prm.mode_noBS = True
        elif cfg_modes.mode_value('noBS'): self.prm.mode_noBS = True

        # mode_std_signals
        if args.std_signals: self.prm.mode_std_signals = True
        elif cfg_modes.mode_value('std_signals'): self.prm.mode_std_signals = True

        # mode_display_compact
        if args.display_compact: self.prm.mode_display_compact = True
        elif cfg_modes.mode_value('display_compact'): self.prm.mode_display_compact = True

        # mode_display_slots
        if args.display_slots: self.prm.mode_display_slots = True
        elif cfg_modes.mode_value('display_slots'): self.prm.mode_display_slots = True

        # mode_energy
        if args.energy: self.prm.mode_energy = True
        elif cfg_modes.mode_value('energy'): self.prm.mode_energy = True

        # mode_astropulse
        if args.astropulse: self.prm.mode_astropulse = True
        elif cfg_modes.mode_value('astropulse'): self.prm.mode_astropulse = True

        # mode_boinc_home
        if args.boinc_home and args.boinc_home.isprintable():
            self.prm.boinc_home = args.boinc_home
        elif cfg_modes.mode_value('boinc_home'):
            if cfg_modes.mode_value('boinc_home') and cfg_modes.mode_value('boinc_home').isprintable():
                self.prm.boinc_home = cfg_modes.mode_value('boinc_home')

        # mode_run_name
        if args.run_name and args.run_name.isprintable():
            self.prm.run_name = args.run_name.replace(' ', '').replace('/', '').replace('\\', '')
        elif cfg_modes.mode_value('run_name'):
            if cfg_modes.mode_value('run_name') and cfg_modes.mode_value('run_name').isprintable():
                self.prm.run_name = cfg_modes.mode_value('run_name').replace(' ', '').replace('/', '').replace('\\', '')

        # mode_devmap
        specified_devmap = {}
        self.prm.devmap = {}
        devmap_str = ''
        if args.devmap:
            devmap_str = args.devmap
        elif cfg_modes.mode_value('devmap'):
            devmap_str = cfg_modes.mode_value('devmap')
        if devmap_str:
            if re.fullmatch('([0-9]:[0-9],)*([0-9]:[0-9])+', devmap_str):
                gdev_items = devmap_str.split(',')
                for gi in gdev_items:
                    gi_items = gi.split(':')
                    specified_devmap[int(gi_items[0])] = int(gi_items[1])
                self.prm.devmap = specified_devmap
            else:
                print('Invalid devmap arg: [', devmap_str, ']')

        # mode_gpu_devices
        self.prm.mode_gpu_devices = []
        gpu_devices_str = ''
        if args.gpu_devices:
            gpu_devices_str = args.gpu_devices
        elif cfg_modes.mode_value('gpu_devices'):
            gpu_devices_str = cfg_modes.mode_value('gpu_devices')
        if gpu_devices_str:
            if re.fullmatch('([0-9],)*([0-9])+', gpu_devices_str):
                gdev_items = gpu_devices_str.split(',')
                for gi in gdev_items:
                    self.prm.mode_gpu_devices.append(int(gi))
            else:
                print('Invalid gpu_devices arg: [{}]'.format(gpu_devices_str))

        # mode_num_repetitions
        if args.num_repetitions > 0: self.prm.repetitions = args.num_repetitions
        elif cfg_modes.mode_value('num_repetitions'):
            if int(cfg_modes.mode_value('num_repetitions')) > 0:
                self.prm.repetitions = cfg_modes.mode_value('num_repetitions')
            else:
                print('CFG: Invalid number of repetitions specified [{}].  Ignoring...'.format(
                    str(cfg_modes.mode_value('num_repetitions'))))
        else:
            self.prm.repetitions = 1

        # mode_max_threads
        self.prm.specified_max_threads = -1
        if args.max_threads > 0: self.prm.specified_max_threads = args.max_threads
        elif cfg_modes.mode_value('max_threads'):
            if cfg_modes.mode_value('max_threads') > 0:
                self.prm.specified_max_threads = cfg_modes.mode_value('max_threads')

        # mode_max_gpus
        self.prm.specified_max_gpus = -1
        if args.max_gpus > 0:
            self.prm.specified_max_gpus = args.max_gpus
        elif cfg_modes.mode_value('max_gpus'):
            if cfg_modes.mode_value('max_gpus') > 0:
                self.prm.specified_max_gpus = cfg_modes.mode_value('max_gpus')

    @staticmethod
    def check_env():
        """
        Return 0 if all good, -1 if python version issue, -2 if OS issue, -3 if system command issue.
        :return:  Integer check code
        :rtype: int
        """
        # Check python version
        required_pversion = [3, 6]
        (python_major, python_minor, python_patch) = platform.python_version_tuple()
        if MB_CONST.DEBUG: print('Using python: {}.{}.{}'.format(python_major, python_minor, python_patch))
        if int(python_major) < required_pversion[0]:
            print('Using python {}, but {} requires python {}.{} or higher.'.format(python_major, __program_name__,
                                                                                    required_pversion[0],
                                                                                    required_pversion[1]),
                  file=sys.stderr)
            return -1
        elif int(python_major) == required_pversion[0] and int(python_minor) < required_pversion[1]:
            print('Using python {}.{}.{}, but {} requires python {}.{} or higher.'.format(python_major, python_minor,
                                                                                          python_patch,
                                                                                          __program_name__,
                                                                                          required_pversion[0],
                                                                                          required_pversion[1]),
                  file=sys.stderr)
            return -1

        # Check Linux Kernel version
        required_kversion = [4, 8]
        linux_version = platform.release()
        if MB_CONST.DEBUG: print('Using Linux Kernel: {}'.format(linux_version))
        if int(linux_version.split('.')[0]) < required_kversion[0]:
            print('Using Linux Kernel {}, but {} requires > {}.{}.'.format(linux_version, __program_name__,
                                                                           required_kversion[0], required_kversion[1]),
                  file=sys.stderr)
            return -2
        elif int(linux_version.split('.')[0]) == required_kversion[0] and \
                int(linux_version.split('.')[1]) < required_kversion[1]:
            print('Using Linux Kernel {}, but {} requires > {}.{}.'.format(linux_version, __program_name__,
                                                                           required_kversion[0], required_kversion[1]),
                  file=sys.stderr)
            return -2

        # Check access/paths to system commands
        command_access_fail = False
        MB_CONST.cmd_lspci = shutil.which('lspci')
        if not MB_CONST.cmd_lspci:
            print('OS command [lspci] executable not found.')
            command_access_fail = True
        MB_CONST.cmd_lshw = shutil.which('lshw')
        if not MB_CONST.cmd_lshw:
            print('OS command [lshw] executable not found.')
            command_access_fail = True
        MB_CONST.cmd_lscpu = shutil.which('lscpu')
        if not MB_CONST.cmd_lscpu:
            print('OS command [lscpu] executable not found.')
            command_access_fail = True
        MB_CONST.cmd_clinfo = shutil.which('clinfo')
        if not MB_CONST.cmd_clinfo:
            print('Package addon [clinfo] executable not found.  Use sudo apt-get install clinfo to install')
        MB_CONST.cmd_time = shutil.which('time')
        if not MB_CONST.cmd_time:
            print('OS command [time] executable not found.')
            command_access_fail = True
        MB_CONST.cmd_nvidia_smi = shutil.which('nvidia-smi')
        if not MB_CONST.cmd_nvidia_smi:
            print('Package addon [nvidia-smi] executable not found.')
        MB_CONST.cmd_lsb_release = shutil.which('lsb_release')
        if not MB_CONST.cmd_lsb_release:
            print('OS command [lsb_release] executable not found.')
            command_access_fail = True
        if command_access_fail:
            return -3
        return 0

    def set_env(self):
        """
        Setup the working environment to run benchmarks
                - Get time and system parameters
                - Use standard subdirectory and filenames in the MB_CONST class
                - Verify all required directories and files exist
        :return: True if all files and directories exist, else False
        :rtype: bool
        """
        valid = True
        t = datetime.utcnow()
        self.prm.time_now = t.strftime('%c')
        self.prm.time_now_short = t.strftime('%m%d_%H%M%S')
        self.prm.hostname = socket.gethostname()
        self.prm.platform = '{} {}'.format(platform.system(), platform.release())

        # Get OS details
        if not MB_CONST.cmd_lsb_release:
            print('OS Command [lsb_release] not found', file=sys.stderr)
            valid = False
        else:
            cmd_str = '{} -a 2>/dev/null'.format(MB_CONST.cmd_lsb_release)
            try:
                cmd = subprocess.Popen(cmd_str, shell=True, stdout=subprocess.PIPE)
                for line in cmd.stdout:
                    linestr = line.decode('utf-8').strip()
                    srch_obj = re.search('Description', linestr)
                    if srch_obj:
                        line_items = linestr.split(':')
                        self.prm.os_desc = line_items[1].strip()
                        cmd.stdout.close()
                        break
            except (subprocess.CalledProcessError, OSError) as except_err:
                print('Warning: {}. can not determine OS'.format(except_err), file=sys.stderr)
                self.prm.os_desc = 'UNKNOWN'

        # Get CPU details
        if not MB_CONST.cmd_lscpu:
            print('OS Command [lscpu] not found')
            valid = False
        else:
            cpu_max_mhz = ''
            cmd_str = '{} 2>/dev/null'.format(MB_CONST.cmd_lscpu)
            try:
                cmd = subprocess.Popen(cmd_str, shell=True, stdout=subprocess.PIPE)
                for line in cmd.stdout:
                    linestr = line.decode('utf-8').strip()
                    srch_obj = re.search('Model name', linestr)
                    if srch_obj:
                        line_items = linestr.split(':')
                        self.prm.cpu_model = line_items[1].strip()
                        continue
                    srch_obj = re.search('CPU max MHz', linestr)
                    if srch_obj:
                        line_items = linestr.split(':')
                        cpu_max_mhz = line_items[1].strip()
                        continue
                    srch_obj = re.search('CPU MHz', linestr)
                    if srch_obj:
                        line_items = linestr.split(':')
                        cpu_mhz = line_items[1].strip()
                        continue
                if cpu_max_mhz == '':
                    self.prm.cpu_mhz = int(float(cpu_mhz))
                else:
                    self.prm.cpu_mhz = int(float(cpu_max_mhz))
                cmd.stdout.close()
            except (subprocess.CalledProcessError, OSError) as except_err:
                print('Warning: can not determine CPU details: {}'.format(except_err), file=sys.stderr)
                self.prm.cpu_model = 'UNKNOWN'
                cpu_max_mhz = 'UNKNOWN'
                cpu_mhz = 'UNKNOWN'

            # Get CPU details
            cmd_str = '{} -e 2>/dev/null | tail -1'.format(MB_CONST.cmd_lscpu)
            try:
                cmd = subprocess.Popen(cmd_str, shell=True, stdout=subprocess.PIPE)
                for line in cmd.stdout:
                    linestr = line.decode('utf-8').strip()
                    line_items = linestr.split()
                    self.prm.total_cpu_threads = int(line_items[0].strip()) + 1
                    self.prm.total_cpu_cores = int(line_items[3].strip()) + 1
                cmd.stdout.close()
            except (subprocess.CalledProcessError, OSError) as except_err:
                print('Error: can not determine CPU core details: {}'.format(except_err), file=sys.stderr)
                valid = False

        # Set working directories
        self.prm.current_dir = os.getcwd()
        self.prm.workdir_path = os.path.join(self.prm.current_dir, MB_CONST.workdir_subdir)
        self.prm.cpu_app_path = os.path.join(self.prm.current_dir, MB_CONST.cpu_app_subdir)
        self.prm.gpu_app_path = os.path.join(self.prm.current_dir, MB_CONST.gpu_app_subdir)
        self.prm.ref_app_path = os.path.join(self.prm.current_dir, MB_CONST.ref_app_subdir)
        self.prm.wu_path = os.path.join(self.prm.current_dir, MB_CONST.wu_subdir)
        self.prm.wu_std_signal_path = os.path.join(self.prm.current_dir, MB_CONST.std_signal_subdir)
        self.prm.testdata_path = os.path.join(self.prm.current_dir, MB_CONST.testdata_subdir)
        self.prm.ref_results_path = os.path.join(self.prm.ref_app_path, MB_CONST.ref_results_subdir)
        self.prm.slots_path = os.path.join(self.prm.workdir_path, MB_CONST.slots_subdir)
        self.prm.lockfile = os.path.join(self.prm.workdir_path, '.benchMTlockfile')
        summary_subdir = '{}_benchMT_{}_{}'.format(self.prm.hostname, self.prm.run_name, self.prm.time_now_short)
        self.prm.summary_path = os.path.join(self.prm.testdata_path, summary_subdir)
        summary_filename = '{}.testlog.{}.txt'.format(self.prm.hostname, self.prm.time_now_short)
        self.prm.summary_file = os.path.join(self.prm.summary_path, summary_filename)
        psv_filename = '{}.timelog.{}.psv'.format(self.prm.hostname, self.prm.time_now_short)
        self.prm.psv_file = os.path.join(self.prm.summary_path, psv_filename)
        self.prm.init_data_template_file = os.path.join(self.prm.workdir_path, MB_CONST.template_file)

        # Check working directories
        if not os.path.isdir(self.prm.workdir_path):
            print('benchMT workdir Path [{}] does not exist, making...'.format(self.prm.workdir_path))
            os.mkdir(self.prm.workdir_path)
            if not os.path.isdir(self.prm.workdir_path):
                print('Failed to make benchMT workdir Path [{}]'.format(self.prm.workdir_path))
                valid = False
        if not os.path.isdir(self.prm.testdata_path):
            print('TestData Path [{}] does not exist, making...'.format(self.prm.testdata_path))
            os.mkdir(self.prm.testdata_path)
            if not os.path.isdir(self.prm.testdata_path):
                print('Failed to make TestData Path [{}]'.format(self.prm.testdata_path))
                valid = False
        if not os.path.isdir(self.prm.cpu_app_path):
            print('CPU APP Path [{}] does not exist'.format(self.prm.cpu_app_path))
            valid = False
        if not os.path.isdir(self.prm.ref_app_path):
            print('REFERENCE APP Path [{}] does not exist'.format(self.prm.ref_app_path))
            valid = False
        if not os.path.isdir(self.prm.ref_results_path):
            print('REFERENCE RESULTS Path [{}] does not exist'.format(self.prm.ref_results_path))
            valid = False
        if not os.path.isdir(self.prm.gpu_app_path):
            print('GPU APP Path [{}] does not exist'.format(self.prm.gpu_app_path))
            valid = False
        if not os.path.isdir(self.prm.wu_path):
            print('WU Path [{}] does not exist'.format(self.prm.wu_path))
            valid = False
        if not os.path.isdir(self.prm.wu_std_signal_path):
            print('STD SIGNAL WU Path [{}] does not exist'.format(self.prm.wu_std_signal_path))
            valid = False

        # Set CFG file location
        self.prm.command_line_file = os.path.join(self.prm.current_dir, MB_CONST.command_line_filename)
        if not os.path.isfile(self.prm.command_line_file):
            print('BenchCFG [{}] does not exist.'.format(self.prm.command_line_file))
            valid = False

        return valid

    def set_env_boinc(self):
        """
        Set boinc environment components.
        :return:  True if all ok
        :rtype: bool
        """
        valid = True
        if not MB_CONST.noBS:
            if not os.path.isdir(self.prm.boinc_home):
                print('BOINC Home Path [{}] does not exist'.format(self.prm.boinc_home))
                print('Please set the correct BOINC Home Path with the --boinc_home command line option')
                valid = False

        self.prm.wucmpcmd = os.path.join(self.prm.current_dir, MB_CONST.wu_cmp)
        if not os.path.isfile(self.prm.wucmpcmd):
            print('Results Compare Utility [{}] does not exist'.format(self.prm.wucmpcmd))
            valid = False

        if not MB_CONST.noBS:
            self.prm.coproc_file = os.path.join(self.prm.boinc_home, MB_CONST.coproc_file_name)
            if not os.path.isfile(self.prm.coproc_file):
                print('coproc_file [{}] does not exist'.format(self.prm.coproc_file))
                self.prm.coproc_file = None
            self.prm.boinccmd = os.path.join(self.prm.boinc_home, MB_CONST.boinccmd)
            if not os.path.isfile(self.prm.boinccmd):
                print('boinccmd [{}] does not exist'.format(self.prm.boinccmd))
                valid = False
            if not os.path.isfile(self.prm.init_data_template_file):
                print('init_data.xml_template file [{}] does not exist, creating...'.format(
                    self.prm.init_data_template_file))
            with open(self.prm.init_data_template_file, 'w') as fileptr:
                print('<app_init_data>', file=fileptr)
                print('<app_name>setiathome_v8</app_name>', file=fileptr)
                print('<project_dir>{}</project_dir>'.format(self.prm.workdir_path), file=fileptr)
                print('<boinc_dir>{}</boinc_dir>'.format(self.prm.boinc_home), file=fileptr)
                print('</app_init_data>', file=fileptr)
        return valid

    def purge_workdir_cache(self):
        """
        Purge openCL kernels from working directory.
        :return: None
        :rtype: None
        """
        if not os.path.isdir(self.prm.workdir_path):
            print('benchMT workdir Path [{}] does not exist, can not purge cache...'.format(self.prm.workdir_path))
        else:
            print('Purging cached kernels from: [{}]'.format(self.prm.workdir_path))
        for file_str in glob.glob(os.path.join(self.prm.workdir_path, 'MB_clFFTplan*')):
            os.remove(file_str)
            print('Removed: {}'.format(file_str))
        for file_str in glob.glob(os.path.join(self.prm.workdir_path, 'MultiBeam_Kernels*.cl[0-9,a-z,A-Z]*')):
            os.remove(file_str)
            print('Removed: {}'.format(file_str))

    def makedirs(self):
        """
        Check existence of required directories and make if missing
        :return: None
        :rtype: None
        """
        # Check/Make working directories
        if not os.path.isdir(self.prm.cpu_app_path):
            print('CPU APP Path [{}] does not exist, making...'.format(self.prm.cpu_app_path))
            os.mkdir(self.prm.cpu_app_path)
        if not os.path.isdir(self.prm.gpu_app_path):
            print('GPU APP Path [{}] does not exist, making...'.format(self.prm.gpu_app_path))
            os.mkdir(self.prm.gpu_app_path)
        if not os.path.isdir(self.prm.ref_app_path):
            print('REFERENCE APP Path [{}] does not exist, making...'.format(self.prm.ref_app_path))
            os.mkdir(self.prm.ref_app_path)
        if not os.path.isdir(self.prm.ref_results_path):
            print('REFERENCE RESULTS Path [{}] does not exist, making...'.format(self.prm.ref_results_path))
            os.mkdir(self.prm.ref_results_path)
        if not os.path.isdir(self.prm.wu_path):
            print('WU Path [{}] does not exist, making...'.format(self.prm.wu_path))
            os.mkdir(self.prm.wu_path)
        if not os.path.isdir(self.prm.wu_std_signal_path):
            print('STD SIGNAL WU Path [{}] does not exist, making...'.format(self.prm.wu_std_signal_path))
            os.mkdir(self.prm.wu_std_signal_path)
        if not os.path.isdir(self.prm.testdata_path):
            print('TestData Path [{}] does not exist, making...'.format(self.prm.testdata_path))
            os.mkdir(self.prm.testdata_path)

    def is_bench_conflict(self):
        """
        Return true if there is another instance running.  Check lock file for pid
        if there is a valid process with that pid, then there is a conflict.
        if no conflict, then write current pid to lockfile and return false
        :return: True if there is a conflict
        :rtype: bool
        """
        mypid = os.getpid()
        if not os.path.isfile(self.prm.lockfile):
            # No lockfile, so assume no conflict
            with open(self.prm.lockfile, 'w') as file_ptr:
                print(str(mypid), file=file_ptr)
            return False
        else:
            with open(self.prm.lockfile, 'r') as file_ptr:
                line = file_ptr.readline().strip()
            if line.isdigit():
                pid = int(line)
                try:
                    os.kill(pid, 0)
                except OSError:
                    # Not running
                    with open(self.prm.lockfile, 'w') as file_ptr:
                        print(str(mypid), file=file_ptr)
                    return False
        return True

    @staticmethod
    def is_boinc_running():
        """
        Check if boinc is running.
        :return: True if running
        :rtype: bool
        """
        cmd_str = 'ps -C boinc -o pid 2>/dev/null'
        try:
            cmd = subprocess.Popen(cmd_str, shell=True, stdout=subprocess.PIPE)
            output = cmd.stdout.read()
            cmd.stdout.close()
            cmd.wait()
            if output.decode('utf-8').strip() == 'PID':
                return False
            return True
        except OSError as except_err:
            print('Warning: {}, can not check if boinc is running.'.format(except_err), file=sys.stderr)
            return True

    def suspend_boinc(self):
        """
        Run boinc suspend script
        :return: None
        :rtype: None
        """
        if not self.is_boinc_running():
            print('boinc is not running, skip suspend')
            return
        cwd = os.getcwd()
        os.chdir(self.prm.boinc_home)
        for cmd_str in MB_CONST.suspend_args:
            cmd_str = os.path.join(self.prm.boinc_home, cmd_str)
            if MB_CONST.DEBUG: print('Suspend cmd: {}'.format(cmd_str))
            try:
                cmd = subprocess.Popen(shlex.split(cmd_str), shell=False, stdout=subprocess.PIPE)
                while True:
                    if cmd.poll() is not None:
                        break
                    time.sleep(1)
            except (subprocess.CalledProcessError, OSError) as except_err:
                print('Error: {}, could not execute boinccmd: {}'.format(except_err, cmd_str), file=sys.stderr)
        os.chdir(cwd)
        time.sleep(1)

    def resume_boinc(self):
        """
        Run boinc resume script
        :return: None
        :rtype: None
        """
        if not self.is_boinc_running():
            print('boinc is not running, skip resume')
            return
        cwd = os.getcwd()
        os.chdir(self.prm.boinc_home)
        for cmd_str in MB_CONST.resume_args:
            cmd_str = os.path.join(self.prm.boinc_home, cmd_str)
            if MB_CONST.DEBUG: print('Resume cmd: {}'.format(cmd_str))
            try:
                cmd = subprocess.Popen(shlex.split(cmd_str), shell=False, stdout=subprocess.PIPE)
                while True:
                    if cmd.poll() is not None:
                        break
                    time.sleep(1)
            except (subprocess.CalledProcessError, OSError) as except_err:
                print('Error: {}, could not execute {}.'.format(except_err, cmd_str), file=sys.stderr)
        os.chdir(cwd)

    def print(self, fileptr=sys.stdout):
        """
        Print all environment details.
        :return: None
        :rtype: None
        """
        for k, v in self._display.items():
            if k == 'app_mode':
                appmode = 'AstroPulse' if self.prm.mode_astropulse else 'MultiBeam'
                print(v.format(appmode), file=fileptr)
            elif k == 'benchMT_version':
                print(v.format(__version__), file=fileptr)
            elif k == 'run_name' and not self.prm.run_name:
                continue
            elif k == 'gpu_details':
                print('GPU Details:', file=fileptr)
                for gpi in self.prm.gpu_details:
                    print('    {}'.format(gpi), file=fileptr)
            else:
                print(v.format(self.prm[k]), file=fileptr)


class GpuItem:
    """
    Defines a data object that represents a GPU.
    """
    def __init__(self, item_id):
        self.uuid = item_id
        self.card_num = None
        self.boinc_device_num = None
        self.model = ''
        self.vendor = ''
        self.card_path = None
        self.hwmon_path = None
        self.pcie_id = ''
        self.driver = ''
        self.energy_compatible = False
        self.compute_compatible = False
        self.ocl_device_name = None
        self.ocl_device_version = None
        self.ocl_device_index = None
        time_0 = datetime.utcnow()
        self.energy = {'t0': time_0, 'tn': time_0, 'cumulative': 0.0, 'max_power': 0.0}
        self.power = None

    def populate(self, pcie_id, gpu_name, vendor, driver_module, card_path, hwmon_path,
                 energy, compute, ocl_dev, ocl_ver, ocl_index):
        """
        Populate elements of a GpuItem.
        :param pcie_id: The pcid ID of the GPU.
        :type pcie_id: str
        :param gpu_name:  Model name of the GPU
        :type gpu_name: str
        :param vendor:  The make of the GPU (AMD, NVIDIA, ...)
        :type vendor: str
        :param driver_module: The name of the driver.
        :type driver_module: str
        :param card_path: The path to the GPU.
        :type card_path: str
        :param hwmon_path: Path to the hardware monitor files.
        :type hwmon_path: str
        :param energy: Energy compatibility flag
        :type energy: bool
        :param compute: Compute compatibility flag
        :type compute: bool
        :param ocl_dev:  openCL device
        :type ocl_dev: str
        :param ocl_ver: openCL version
        :type ocl_ver: str
        :param ocl_index: openCL index
        :type ocl_index: str
        :return: None
        :rtype: None
        """
        self.pcie_id = pcie_id
        self.model = gpu_name
        self.vendor = vendor
        self.driver = driver_module
        self.card_path = card_path
        self.card_num = int(card_path.replace('{}card'.format(MB_CONST.card_root), '').replace('/device', ''))
        self.hwmon_path = hwmon_path
        self.energy_compatible = energy
        self.compute_compatible = compute
        self.ocl_device_name = ocl_dev
        self.ocl_device_version = ocl_ver
        self.ocl_device_index = ocl_index

    def print(self):
        """
        Print GpuItem.
        :return: None
        :rtype: None
        """
        print('GpuItem: uuid: {}'.format(self.uuid))
        print('    pcie_id: {}'.format(self.pcie_id))
        print('    model: {}'.format(self.model))
        print('    vendor: {}'.format(self.vendor))
        print('    driver: {}'.format(self.driver))
        print('    openCL Device: {}'.format(self.ocl_device_name))
        print('    openCL Version: {}'.format(self.ocl_device_version))
        print('    openCL Index: {}'.format(self.ocl_device_index))
        print('    card number: {}'.format(self.card_num))
        print('    BOINC Device number: {}'.format(self.boinc_device_num))
        print('    card path: {}'.format(self.card_path))
        print('    hwmon path: {}'.format(self.hwmon_path))
        print('    Compute compatible: {}'.format(self.compute_compatible))
        print('    Energy compatible: {}'.format(self.energy_compatible))

    def reset_energy(self):
        """
        Reset energy metrics to time zero state.
        :return: None
        :rtype: None
        .. note:: Energy is stored in kWh.
        """
        time_0 = datetime.utcnow()
        self.energy.update({'t0': time_0, 'tn': time_0, 'cumulative': 0.0, 'max_power': 0.0})

    def get_max_power(self):
        """
        Return the max power.
        :return:  max power in kW
        :rtype: float
        """
        return self.energy['max_power']

    def get_energy(self):
        """
        Return the cumulative energy.
        :return:  cumulative energy in kWh
        :rtype: float
        """
        return self.energy['cumulative']

    def update_energy_data(self):
        """
        Update energy metrics my getting current power and adding it product with time since last
        call to the cumulative energy value.
        :return: True if successful
        :rtype: bool
        .. note:: Power is in W and Energy is in kWh.
        """
        if not self.energy_compatible:
            return False
        self.power = self.get_power()
        if self.power:
            time_n = datetime.utcnow()
            delta_hrs = ((time_n - self.energy['tn']).total_seconds())/3600
            self.energy['tn'] = time_n
            self.energy['cumulative'] += delta_hrs * self.power/1000
            if self.power > self.energy['max_power']:
                self.energy['max_power'] = self.power
            if MB_CONST.DEBUG: print('GPU {}: Cumulative Energy: {} kWh, Max Power: {} W'.format(
                self.pcie_id, round(self.energy['cumulative'], 6), round(self.energy['max_power'], 2)))
            return True
        else:
            print('Error: Power read failed for GPU-{}: [{}]'.format(self.card_num, self.pcie_id), file=sys.stderr)
            return False

    def get_power(self, set_energy_compatibility=False):
        """
        Get power from GPU and set energy compatible flag if desired.
        :param set_energy_compatibility: True if GpuItem energy_compatible flag is to be not checked and set.
        :type set_energy_compatibility: bool
        :return: power reading in Watts
        :rtype: Union([float, None])
        .. note:: Measured power is converted to Watts.
        """
        power_reading = None
        # If not called as part of compatibility check, then check compatibility
        if not set_energy_compatibility:
            if not self.energy_compatible:
                return None

        if self.vendor == 'AMD':
            # AMD power reading
            if self.hwmon_path:
                hw_power_file = os.path.join(self.hwmon_path, 'power1_average')
                if os.path.isfile(hw_power_file):
                    try:
                        with open(hw_power_file) as hwmon_file:
                            power_reading = int(hwmon_file.readline())/1000000.0
                    except OSError as except_err:
                        power_reading = None
                        if MB_CONST.DEBUG: print('Error: {}, Failed to make power reading for {}'.format(
                                                 except_err, self.pcie_id))
        elif self.vendor == 'NVIDIA':
            # NVIDIA power reading
            if MB_CONST.cmd_nvidia_smi:
                try:
                    nsmi_items = subprocess.check_output(
                        '{} -i {} --query-gpu=power.draw --format=csv,noheader,nounits'.format(
                         MB_CONST.cmd_nvidia_smi, self.pcie_id), shell=True).decode().split('\n')
                    power_reading = float(nsmi_items[0].strip())
                except (subprocess.CalledProcessError, OSError) as except_err:
                    power_reading = None
                    if MB_CONST.DEBUG: print('Error: {}, Failed to make power reading for {}'.format(
                                              except_err, self.pcie_id))

        if MB_CONST.DEBUG: print('Power reading for {}: {} W'.format(self.pcie_id, power_reading))
        if set_energy_compatibility:
            self.energy_compatible = True if power_reading else False

        return power_reading


class GpuList:
    """
    An object that stores all GPU objects and other critical parameters.
    """
    def __init__(self):
        self.list = {}
        self.devmap = {}      # BOINC Device to Card num map
        self.dev2climap = {}  # BOINC Device to CL index map
        self.opencl_map = {}  # {ocl_pcie_id: [ocl_device_name, ocl_device_version, ocl_index]}

    def print(self):
        """
        Print every GpuItem in the GpuList object.
        :return:  None
        """
        for v in self.list.values():
            v.print()

    def add(self, gpu_item):
        """
        Add given GpuItem to the GpuList
        :param gpu_item:  Item to be added
        :type gpu_item: GpuItem
        :return: None
        """
        self.list[gpu_item.uuid] = gpu_item

    def read_gpu_coproc_file(self):
        """
        Reads in the BOINC coproc_info file for potential mapping of device to card numbers.
        :return: True if read is successful
        :rtype: bool
        """
        if MB_CONST.env.prm.coproc_file is None:
            print('coproc_info.xml file not found: [{}]'.format(MB_CONST.env.prm.coproc_file))
            return False
        device_num = opencl_device_index = None
        with open(MB_CONST.env.prm.coproc_file, 'r') as file_ptr:
            lines = file_ptr.readlines()
            for linestr in lines:
                linestr = linestr.strip()
                srch_obj = re.search('device_num', linestr)
                if srch_obj:
                    device_num = re.sub(r'<[/]*device_num>', '', linestr)
                    if MB_CONST.DEBUG: print('device_num: [{}]'.format(device_num))
                srch_obj = re.search('opencl_device_index', linestr)
                if srch_obj:
                    opencl_device_index = re.sub(r'<[/]*opencl_device_index>', '', linestr)
                    if MB_CONST.DEBUG: print('opencl_device_index: [{}]'.format(opencl_device_index))
                srch_obj = re.search(r'</(nvidia|ati)_opencl>', linestr)
                if srch_obj:
                    if MB_CONST.DEBUG: print('device_num: opencl_device_index [{}: {}]'.format(device_num,
                                                                                               opencl_device_index))
                    if device_num is not None and opencl_device_index is not None:
                        self.dev2climap.update({int(device_num): int(opencl_device_index)})
                        device_num = opencl_device_index = None
        return True

    def read_gpu_opencl_data(self):
        """
        Use clinfo system call to get openCL details for relevant GPUs.
        :return:  Returns True if successful
        :rtype:  bool
        .. todo:: Read of Intel pcie_id is not working.
        """
        # Check access to clinfo command
        if not MB_CONST.cmd_clinfo:
            print('OS Command [clinfo] not found.  Use sudo apt-get install clinfo to install', file=sys.stderr)
            return False
        cmd = subprocess.Popen(shlex.split('{} --raw'.format(MB_CONST.cmd_clinfo)), shell=False, stdout=subprocess.PIPE)
        ocl_pcie_id = ''
        ocl_device_name = ''
        ocl_device_version = ''
        ocl_index = ''
        ocl_pcie_slot_id = ocl_pcie_bus_id = None
        for line in cmd.stdout:
            linestr = line.decode('utf-8').strip()
            if len(linestr) < 1:
                continue
            if linestr[0] != '[':
                continue
            line_items = linestr.split(maxsplit=2)
            if len(line_items) != 3:
                continue
            _cl_vender, cl_index = tuple(re.sub(r'[\[\]]', '', line_items[0]).split('/'))
            if cl_index == '*':
                continue
            if ocl_index == '':
                ocl_index = cl_index
                ocl_pcie_slot_id = ocl_pcie_bus_id = None

            # If new cl_index, then update opencl_map
            if cl_index != ocl_index:
                self.opencl_map.update({ocl_pcie_id: [ocl_device_name, ocl_device_version, ocl_index]})
                if MB_CONST.DEBUG: print('cl_index: {}'.format(self.opencl_map[ocl_pcie_id]))
                ocl_index = cl_index
                ocl_pcie_id = ''
                ocl_device_name = ''
                ocl_device_version = ''
                ocl_pcie_slot_id = ocl_pcie_bus_id = None

            param_str = line_items[1]
            srch_obj = re.search('CL_DEVICE_NAME', param_str)
            if srch_obj:
                ocl_device_name = line_items[2].strip()
                if MB_CONST.DEBUG: print('ocl_device_name [{}]'.format(ocl_device_name))
                continue
            srch_obj = re.search('CL_DEVICE_VERSION', param_str)
            if srch_obj:
                ocl_device_version = line_items[2].strip()
                if MB_CONST.DEBUG: print('ocl_device_version [{}]'.format(ocl_device_version))
                continue
            srch_obj = re.search('CL_DEVICE_TOPOLOGY', param_str)
            if srch_obj:
                ocl_pcie_id = (line_items[2].split()[1]).strip()
                if MB_CONST.DEBUG: print('ocl_pcie_id [{}]'.format(ocl_pcie_id))
                continue
            srch_obj = re.search('CL_DEVICE_PCI_BUS_ID_NV', param_str)
            if srch_obj:
                ocl_pcie_bus_id = hex(int(line_items[2].strip()))
                if ocl_pcie_slot_id is not None:
                    ocl_pcie_id = '{}:{}.0'.format(ocl_pcie_bus_id[2:].zfill(2), ocl_pcie_slot_id[2:].zfill(2))
                    ocl_pcie_slot_id = ocl_pcie_bus_id = None
                    if MB_CONST.DEBUG: print('ocl_pcie_id [{}]'.format(ocl_pcie_id))
                continue
            srch_obj = re.search('CL_DEVICE_PCI_SLOT_ID_NV', param_str)
            if srch_obj:
                ocl_pcie_slot_id = hex(int(line_items[2].strip()))
                if ocl_pcie_bus_id is not None:
                    ocl_pcie_id = '{}:{}.0'.format(ocl_pcie_bus_id[2:].zfill(2), ocl_pcie_slot_id[2:].zfill(2))
                    ocl_pcie_slot_id = ocl_pcie_bus_id = None
                    if MB_CONST.DEBUG: print('ocl_pcie_id [{}]'.format(ocl_pcie_id))
                continue

        self.opencl_map.update({ocl_pcie_id: [ocl_device_name, ocl_device_version, ocl_index]})
        if MB_CONST.DEBUG: print('cl_index: {}'.format(self.opencl_map[ocl_pcie_id]))
        return True

    def set_gpu_list(self):
        """
        Use lspci to populate list of all installed GPUs.
        :return: True on success
        :rtype: bool
        """
        if not MB_CONST.cmd_lspci:
            return False
        self.read_gpu_opencl_data()
        if MB_CONST.DEBUG: print('openCL map: {}'.format(self.opencl_map))
        self.read_gpu_coproc_file()
        if MB_CONST.DEBUG: print('device to cl_index map: {}'.format(self.dev2climap))

        try:
            pcie_ids = subprocess.check_output('{} | grep -E \"^.*(VGA|3D|Display).*$\" | grep -Eo \
                                               \"^([0-9a-fA-F]+:[0-9a-fA-F]+.[0-9a-fA-F])\"'.format(MB_CONST.cmd_lspci),
                                               shell=True).decode().split()
        except (subprocess.CalledProcessError, OSError) as except_err:
            print('Error: {}, lspci failed to find GPUs'.format(except_err))
            return False

        if MB_CONST.DEBUG: print('Found {} GPUs'.format(len(pcie_ids)))
        for pcie_id in pcie_ids:
            gpu_uuid = uuid4().hex
            self.add(GpuItem(gpu_uuid))
            if MB_CONST.DEBUG: print('GPU: {}'.format(pcie_id))
            energy = compute = False
            try:
                lspci_items = subprocess.check_output('{} -k -s {}'.format(MB_CONST.cmd_lspci, pcie_id),
                                                      shell=True).decode().split('\n')
            except (subprocess.CalledProcessError, OSError) as except_err:
                print('Fatal Error: {}, can not get GPU details with lspci'.format(except_err))
                sys.exit(-1)
            if MB_CONST.DEBUG: print(lspci_items)

            # Get Long GPU Name
            gpu_name = 'UNKNOWN'
            gpu_name_items = lspci_items[0].split(': ', maxsplit=1)
            if len(gpu_name_items) >= 2:
                gpu_name = gpu_name_items[1]
            # Check for Fiji ProDuo
            srch_obj = re.search('Fiji', gpu_name)
            if srch_obj:
                srch_obj = re.search(r'Radeon Pro Duo', lspci_items[1].split('[AMD/ATI]')[1])
                if srch_obj:
                    gpu_name = 'Radeon Fiji Pro Duo'

            # Get GPU brand: AMD, INTEL, NVIDIA, ASPEED
            vendor = 'UNKNOWN'
            opencl_device_name = None
            opencl_device_version = None
            opencl_device_index = None
            srch_obj = re.search(r'(AMD|amd|ATI|ati)', gpu_name)
            if srch_obj:
                vendor = 'AMD'
                compute = False
                if self.opencl_map:
                    if pcie_id in self.opencl_map.keys():
                        opencl_device_name = self.opencl_map[pcie_id][0]
                        opencl_device_version = self.opencl_map[pcie_id][1]
                        opencl_device_index = self.opencl_map[pcie_id][2]
                        compute = True
                else:
                    compute = True
            srch_obj = re.search(r'(NVIDIA|nvidia|nVidia)', gpu_name)
            if srch_obj:
                vendor = 'NVIDIA'
                compute = False
                if self.opencl_map:
                    if pcie_id in self.opencl_map.keys():
                        opencl_device_name = self.opencl_map[pcie_id][0]
                        opencl_device_version = self.opencl_map[pcie_id][1]
                        opencl_device_index = self.opencl_map[pcie_id][2]
                        compute = True
                else:
                    compute = True
            srch_obj = re.search(r'(INTEL|intel|Intel)', gpu_name)
            if srch_obj:
                vendor = 'INTEL'
                compute = False
                if self.opencl_map:
                    if pcie_id in self.opencl_map.keys():
                        opencl_device_name = self.opencl_map[pcie_id][0]
                        opencl_device_version = self.opencl_map[pcie_id][1]
                        opencl_device_index = self.opencl_map[pcie_id][2]
                        compute = True
                else:
                    srch_obj = re.search(r' 530', gpu_name)
                    if srch_obj:
                        compute = False
                    else:
                        compute = True
            srch_obj = re.search(r'(ASPEED|aspeed|Aspeed)', gpu_name)
            if srch_obj:
                vendor = 'ASPEED'
                compute = False
            srch_obj = re.search(r'(MATROX|matrox|Matrox)', gpu_name)
            if srch_obj:
                vendor = 'MATROX'
                compute = False

            # Get Driver Name
            driver_module = 'UNKNOWN'
            for lspci_line in lspci_items:
                srch_obj = re.search(r'(Kernel|kernel)', lspci_line)
                if srch_obj:
                    driver_module_items = lspci_line.split(': ')
                    if len(driver_module_items) >= 2:
                        driver_module = driver_module_items[1].strip()

            # Get full card path
            card_path = None
            device_dirs = glob.glob(os.path.join(MB_CONST.card_root, 'card?/device'))
            for device_dir in device_dirs:
                sysfspath = str(Path(device_dir).resolve())
                if pcie_id == sysfspath[-7:]:
                    card_path = device_dir

            # Get full hwmon path
            hwmon_path = None
            hw_file_srch = glob.glob(os.path.join(card_path, MB_CONST.hwmon_sub) + '?')
            if MB_CONST.DEBUG: print('hw_file_search: ', hw_file_srch)
            if len(hw_file_srch) > 1:
                print('More than one hwmon file found: ', hw_file_srch)
            elif len(hw_file_srch) == 1:
                hwmon_path = hw_file_srch[0]

            self.list[gpu_uuid].populate(pcie_id, gpu_name, vendor, driver_module,
                                         card_path, hwmon_path, energy, compute,
                                         opencl_device_name, opencl_device_version, opencl_device_index)

            # Set energy compatibility
            self.list[gpu_uuid].get_power(set_energy_compatibility=True)
        return True

    def apply_devmap(self):
        """
        Applies the devmap to the GpuList, by updating boinc_device_num in each GpuItem.
        :return: None
        """
        for v in self.list.values():
            for dmk, dmv in self.devmap.items():
                if v.card_num == dmv:
                    v.boinc_device_num = dmk
                    break

    def set_default_devmap(self, bd_list, cn_list):
        """
        Set a default devmap based on it being reverse of cn_list.
        :param bd_list:  BOINC device number list
        :type bd_list: list
        :param cn_list:  Linux card number list
        :type cn_list: list
        :return:  true on success
        :rtype: bool
        .. note:: Confirmed invalid approach, do not use.
        """
        if len(bd_list) != len(cn_list):
            return False
        boinc_dev_list = bd_list[:]
        card_num_list = cn_list[:]

        card_num_list.sort(reverse=True)
        boinc_dev_list.sort()
        MB_CONST.env.prm.devmap = self.devmap = dict(zip(boinc_dev_list, card_num_list))
        return True

    def set_devmap(self, devmap, bd_list, cn_list):
        """
        Verify consistency of devmap to boinc and card number lists and set if ok.
        :param devmap:  The device mapping dictionary
        :type devmap: dict
        :param bd_list:  BOINC device number list
        :type bd_list: list
        :param cn_list:  Linux card number list
        :type cn_list: list
        :return:  true on success
        :rtype: bool
        """
        self.devmap = devmap
        ret_value = True
        for k, v in devmap.items():
            if k not in bd_list:
                print('Error in devmap: BOINC Device {} not in valid BOINC Devices [{}]'.format(k, bd_list))
                ret_value = False
            if v not in cn_list:
                print('Error in devmap: Card Number {} not in valid Driver Card Numbers [{}]'.format(v, cn_list))
                ret_value = False
        self.apply_devmap()
        return ret_value

    def get_device_gpu(self, device_num):
        """
        A function that uses the devmap dictionary to lookup a BOINC Device number and uses the corresponding
        card number to return the matching GPU.
        :param device_num:  An integer representing a BOINC Device number
        :type device_num:  int
        :return:  Returns the GpuItem which corresponds to the card number in devmap
        :rtype: GpuItem
        .. todo:: with the implementation of apply_devmap, this function could be optimized.
        """
        if not self.devmap:
            return None
        if device_num not in self.devmap:
            print('Error: Invalid device map, BOINC device number [{}] not in devmap [{}]'.format(device_num,
                                                                                                  self.devmap))
            print('Exiting...')
            MB_CONST.env.resume_boinc()
            sys.exit(-1)
        card_num = self.devmap[device_num]

        for v in self.list.values():
            if v.card_num == card_num:
                if MB_CONST.DEBUG: print('Device {} maps to card {}'.format(device_num, v.card_num))
                return v

        print('Error: Invalid device map [{}] BOINC Device to GPU Card num'.format(device_num))
        print('       Card [{}] mapped to BOINC device number [{}] does not exist'.format(card_num, device_num))
        print('Exiting...')
        MB_CONST.env.resume_boinc()
        sys.exit(-1)

    def set_env_boinc_gpu_details(self, env):
        """
        Set the remaining env parameters after GPU details are read.
        :param env:  The execution environment
        :type env: BenchEnv
        :return:  None
        """
        env.prm.total_gpu_threads = env.prm.total_gpu_count = len(self.get_card_number_list(compute=True))
        env.prm.boinc_dev_list = []
        for gi in range(0, env.prm.total_gpu_count):
            env.prm.boinc_dev_list.append(int(gi))

    def get_gpu_details(self, compute=False, energy=False):
        """
        This function returns a list of all valid card details. If compute is true, then only compute
        compatible cards are returned.  If energy is true then only compute compatible GPUs with energy capability
        are returned.
        :param compute: if True return list of compute capable cards
        :type compute: bool
        :param energy: if True return list of compute capable cards that are energy capable
        :type energy: bool
        :return: Returns a list of GPU details.
        :rtype: list
        .. todo:: Maybe add boinc device number when mapping is complete
        """
        gdlist = []
        for v in self.list.values():
            if v.card_num is not None:
                if compute:
                    if v.compute_compatible:
                        if MB_CONST.DEBUG: v.print()
                        gdlist.append('Card{}, PCIE ID: {}, Model: {}'.format(v.card_num, v.pcie_id, v.model))
                elif energy:
                    if v.compute_compatible and v.energy_compatible:
                        if MB_CONST.DEBUG: v.print()
                        gdlist.append('Card{}, PCIE ID: {}, Model: {}'.format(v.card_num, v.pcie_id, v.model))
                else:
                    gdlist.append('Card{}, PCIE ID: {}, Model: {}'.format(v.card_num, v.pcie_id, v.model))
        return gdlist

    def get_card_number_list(self, compute=False, energy=False):
        """
        This function returns a list of all valid card numbers. If compute is true, then only compute
        compatible cards are returned.  If energy is true then only compute compatible GPUs with energy capability
        are returned.
        :param compute: if True return list of compute capable cards
        :type compute: bool
        :param energy: if True return list of compute capable cards that are energy capable
        :type energy: bool
        :return: Returns a list of valid GPU card numbers
        :rtype: list
        """
        cnlist = []
        for v in self.list.values():
            if v.card_num >= 0:
                if compute:
                    if v.compute_compatible:
                        cnlist.append(v.card_num)
                elif energy:
                    if v.compute_compatible and v.energy_compatible:
                        cnlist.append(v.card_num)
                else:
                    cnlist.append(v.card_num)
        return cnlist


class BenchJob:
    """
    Object which represents a processing job.
    """
    def __init__(self, item_id):
        self.uuid = item_id
        self.cmd = ''
        self.slot = None
        self.start_time = 'not started'
        self.complete_time = 'not started'
        self.exit_status = ''
        self.state = 'PENDING'              # PENDING, ACTIVE, COMPLETE
        self.app_name = ''
        self.app_args = ''
        self.platform = 'UNKNOWN'           # UNKNOWN, CPU, GPU
        self.wu_name = 'not assigned'
        self.wu_path = 'not assigned'
        self.error = ''
        self.slot_dir = ''
        self.similarity = 'UNKNOWN'
        self.q_value = 'UNKNOWN'
        self.angle_range = 0.0
        self.cnt_spike = 0
        self.cnt_autocorr = 0
        self.cnt_pulse = 0
        self.cnt_triplet = 0
        self.cnt_gaussian = 0
        self.time_real = -1
        self.time_user = -1
        self.time_system = -1
        self.time_maxmem = -1
        self.time_swapnum = -1
        self.time_ctxswt = -1
        self.time_majpf = -1
        self.energy = -1
        self.max_power = -1

    def copy(self, src):
        """
        Copy a BenchJob object to self.
        :param src:
        :type src: BenchJob
        :return: None
        """
        # Don't copy uuid self.uuid = item_id src.uuid
        self.cmd = src.cmd
        self.start_time = src.start_time
        self.complete_time = src.complete_time
        self.exit_status = src.exit_status
        self.state = src.state
        self.app_name = src.app_name
        self.app_args = src.app_args
        self.platform = src.platform
        self.wu_name = src.wu_name
        self.wu_path = src.wu_path
        self.error = src.error
        self.slot_dir = src.slot_dir
        self.similarity = src.similarity
        self.q_value = src.q_value
        self.angle_range = src.angle_range
        self.cnt_spike = src.cnt_spike
        self.cnt_autocorr = src.cnt_autocorr
        self.cnt_pulse = src.cnt_pulse
        self.cnt_triplet = src.cnt_triplet
        self.cnt_gaussian = src.cnt_gaussian
        self.time_real = src.time_real
        self.time_user = src.time_user
        self.time_system = src.time_system
        self.time_maxmem = src.time_maxmem
        self.time_swapnum = src.time_swapnum
        self.time_ctxswt = src.time_ctxswt
        self.time_majpf = src.time_majpf


class JobList:
    """
    An object that aggregates jobs.
    """
    def __init__(self):
        self.list = {}

    def read_benchcfg(self, env, modes):
        """
        Read the default benchCFG file or one specified by user on command line.  Extract
        modes, app_names and app_args
        :param env:
        :type env: BenchEnv
        :param modes:
        :type modes: CfgModes
        :return:  None
        """
        with open(env.prm.command_line_file, 'r') as clfptr:
            for line in clfptr:
                line = line.strip()
                if len(line) < 2: continue
                if line[0] == '#': continue
                lineitems = line.split(maxsplit=1)

                # check if entry is a mode item
                if lineitems[0] == 'mode':
                    modeitems = lineitems[1].split(maxsplit=2)
                    if len(modeitems) < 2: continue
                    # process mode
                    mode_name = modeitems[0].strip()
                    mode_value = modeitems[1].strip()
                    if not modes.set_mode(mode_name, mode_value):
                        print('Invalid mode specified in CFG file: [{}][{}]'.format(mode_name, mode_value))
                    else:
                        print('Read valid mode from CFG file: [{}][{}]'.format(mode_name, mode_value))
                    continue

                # process appname and apparg
                job = BenchJob(uuid4().hex)
                job.app_name = lineitems[0]
                if len(lineitems) > 1:
                    argstr = lineitems[1]
                    srch_obj = re.search(r'[-]+[dD]evice\s+[0-9]+', argstr)
                    if srch_obj:
                        argstr = re.sub(r'[-]+[dD]evice\s+[0-9]+', '', argstr)
                        print(lineitems[1])
                        print('Removed [-device X] argument as conflicts with slot assignment process')
                        print(argstr)
                    job.app_args = argstr
                else:
                    job.app_args = ''

                # print(env.cpu_app_path + job.app_name)
                if os.path.isfile(os.path.join(env.prm.cpu_app_path, job.app_name)):
                    job.platform = 'CPU'
                elif os.path.isfile(os.path.join(env.prm.gpu_app_path, job.app_name)):
                    job.platform = 'GPU'
                else:
                    job.platform = 'UNKNOWN'
                self.list[job.uuid] = job

    def read_wu_list(self, env):
        """
        Prepare a list of WUs based on the contents of the wu_path or std_signal_path
        depending on command line arguments or CFG mode settings
        :param env: environment object
        :type env: BenchEnv
        :return: None
        """
        if env.prm.mode_std_signals:
            wu_path = env.prm.wu_std_signal_path
        else:
            wu_path = env.prm.wu_path
        filelist = os.listdir(path=wu_path)
        for line in filelist:
            line = line.strip()
            if line.endswith('.wu'):
                job = BenchJob(uuid4().hex)
                job.wu_name = line
                job.wu_path = wu_path
                self.list[job.uuid] = job

    def create_ref_list(self, ref_app, wulist):
        """
        Create a reference job entry for every WU found using the specified
        ref_app.  Set state to pending.
        :param ref_app: A bench job object for reference app
        :type ref_app: BenchJob
        :param wulist:  Work unit job list
        :type wulist:  JobList
        :return:  None
        """
        for wu_value in wulist.list.values():
            job = BenchJob(uuid4().hex)
            job.copy(ref_app)
            job.platform = 'REF'
            job.state = 'PENDING'
            job.wu_name = wu_value.wu_name
            job.wu_path = wu_value.wu_path
            self.list[job.uuid] = job

    def check_ref_results(self, env):
        """
        Check if ref_file exist for each ref_job in the list.
        If it exists, change status from PENDING to COMPLETE
        :param env:  environment
        :type env: BenchEnv
        :return: None
        """
        for v in self.list.values():
            ref_app_name = v.app_name.replace('ref-cpu.', '')
            ref_file_name = '{}ref-result.{}.{}.sah'.format(env.prm.ref_results_path, ref_app_name, v.wu_name)
            if os.path.isfile(ref_file_name):
                v.state = 'COMPLETE'
                v.start_time = 'NA'
                v.complete_time = 'NA'

    def create_job_list(self, applist, wulist, env):
        """
        Based on a list of apps and a list of WUs, create an job list which uses every app
        to run every WU.
        :param applist: Application List
        :type applist: JobList
        :param wulist:  Work Unit List
        :type wulist: JobList
        :param env: Environment
        :type env: BenchEnv
        :return: None
        """
        for _ in range(0, env.prm.repetitions):
            for wu_value in wulist.list.values():
                for app_value in applist.list.values():
                    if app_value.platform != 'UNKNOWN':
                        job = BenchJob(uuid4().hex)
                        job.copy(app_value)
                        job.state = 'PENDING'
                        job.wu_name = wu_value.wu_name
                        job.wu_path = wu_value.wu_path
                        self.list[job.uuid] = job

    def append_job_list(self, newlist):
        """
        Append jobs in newlist to self, but check if jobs are already in self
        :param newlist:  Job list to be appended to self
        :type newlist: JobList
        :return: None
        """
        for nl_key, nl_value in newlist.list.items():
            if nl_key in self.list.keys():
                # SKIP if new Job is already in the list
                continue
            else:
                self.list[nl_value.uuid] = nl_value

    def print(self, compact_flag=False, show_skipped=False, fileptr=sys.stdout, title=''):
        """
        Output formatted job list table.
        :param compact_flag: Use compact format if true
        :type compact_flag: bool
        :param show_skipped:  show skipped jobs if true
        :type show_skipped: bool
        :param fileptr: Output fileptr
        :type fileptr: file
        :param title:  Title of the table
        :type title: str
        :return: None
        .. todo:: convert to format() prints
        """
        # Print is optimized for 112 columns
        i = 0
        num_jobs = self.jobcount_bystatus()
        if title == '':
            print('\n   {} of {} jobs complete.\n'.format(num_jobs['COMPLETE'], num_jobs['TOTAL']), file=fileptr)
        else:
            print('\n   {}'.format(title))
        print('┌─'.ljust(5, '─'), '─'.ljust(4, '─'), '─'.ljust(3, '─'), '─'.ljust(60, '─'),
              '─'.ljust(8, '─'), '─'.ljust(8, '─'), '─'.ljust(11, '─'),
              '─'.ljust(8, '─') + '┐', file=fileptr, sep='┬')

        if fileptr == sys.stdout:
            print('│\x1b[1;36m' + 'Job#'.ljust(4, ' ') + '\x1b[0m',
                  '\x1b[1;36m' + 'Slot'.ljust(4, ' ') + '\x1b[0m',
                  '\x1b[1;36m' + 'xPU'.ljust(3, ' ') + '\x1b[0m',
                  '\x1b[1;36m' + 'app_name'.ljust(60, ' ') + '\x1b[0m',
                  '\x1b[1;36m' + '  start'.ljust(8, ' ') + '\x1b[0m',
                  '\x1b[1;36m' + ' finish'.ljust(8, ' ') + '\x1b[0m',
                  '\x1b[1;36m' + 'tot_time'.ljust(11, ' ') + '\x1b[0m',
                  '\x1b[1;36m' + ' state'.ljust(8, ' ') + '\x1b[0m' + '│', file=fileptr, sep='│')
            print('│\x1b[1;36m' + ' '.ljust(4, ' ') + '\x1b[0m',
                  '\x1b[1;36m' + ' '.ljust(4, ' ') + '\x1b[0m',
                  '\x1b[1;36m' + ' '.ljust(3, ' ') + '\x1b[0m',
                  '\x1b[1;36m' + 'app_args'.ljust(60, ' ') + '\x1b[0m',
                  '\x1b[1;36m' + 'wu_name'.ljust(38, ' ') + '\x1b[0m' + '│', file=fileptr, sep='│')
        else:
            print('│Job#'.ljust(5, ' '), 'Slot'.ljust(4, ' '), 'xPU'.ljust(3, ' '), 'app_name'.ljust(60, ' '),
                  '  start'.ljust(8, ' '), ' finish'.ljust(8, ' '), 'tot_time'.ljust(11, ' '),
                  ' state'.ljust(8, ' ') + '│', file=fileptr, sep='│')
            print('│'.ljust(5, ' '), ' '.ljust(4, ' '), ' '.ljust(3, ' '), 'app_args'.ljust(60, ' '),
                  'wu_name'.ljust(38, ' ') + '│', file=fileptr, sep='│')

        for v in self.list.values():
            if v.slot is None:
                slot_str = ' NA'
            else:
                slot_str = ' ' + str(v.slot)

            if (v.state == 'ACTIVE' or v.state == 'COMPLETE') and v.start_time != 'NA':
                start_time_str = v.start_time.strftime('%H:%M:%S')
            elif v.start_time == 'NA':
                start_time_str = 'SKIPPED'
                if not show_skipped: continue
            else:
                start_time_str = '  NA  '

            if v.state == 'COMPLETE' and v.start_time != 'NA':
                complete_time_str = v.complete_time.strftime('%H:%M:%S')
                elapsed_time = v.complete_time - v.start_time
            elif v.start_time == 'NA':
                complete_time_str = 'SKIPPED'
                elapsed_time = 'SKIPPED'
                if not show_skipped: continue
            else:
                complete_time_str = '  NA  '
                elapsed_time = '  NA  '

            # if printing to stdout, use state colors
            if fileptr == sys.stdout:
                if v.state == 'ACTIVE':
                    # Blue
                    state_str = '\x1b[1;37;44m' + v.state.ljust(8, ' ')[:8] + '\x1b[0m'
                elif v.state == 'PENDING':
                    # Yellow
                    state_str = '\x1b[1;30;43m' + v.state.ljust(8, ' ')[:8] + '\x1b[0m'
                elif v.state == 'COMPLETE' and (v.exit_status == 0 or v.exit_status == ''):
                    # Green
                    state_str = '\x1b[1;30;42m' + v.state.ljust(8, ' ')[:8] + '\x1b[0m'
                elif v.state == 'COMPLETE':
                    # Red
                    state_str = '\x1b[1;37;41m' + ' ERROR'.ljust(8, ' ')[:8] + '\x1b[0m'
            else:
                if v.exit_status == 0 or v.exit_status == '':
                    state_str = v.state.ljust(8, ' ')[:8]
                else:
                    state_str = ' ERROR'.ljust(8, ' ')[:8]

            if not compact_flag:
                print('├─'.ljust(5, '─'), '─'.ljust(4, '─'), '─'.ljust(3, '─'), '─'.ljust(60, '─'),
                      '─'.ljust(8, '─') + '┬' + '─'.ljust(8, '─') + '┬' + '─'.ljust(11, '─') + '┬' +
                      '─'.ljust(8, '─') + '┤', file=fileptr, sep='┼')
            print('│' + str(i).ljust(4, ' '), slot_str.ljust(4, ' '), v.platform.ljust(3, ' ')[:3],
                  v.app_name.ljust(60, ' ')[:60], start_time_str.ljust(8, ' '), complete_time_str.ljust(8, ' '),
                  str(elapsed_time).ljust(11, ' ')[:11], state_str + '│', file=fileptr, sep='│')
            print('│' + ' '.ljust(4, ' '), ' '.ljust(4, ' '), ' '.ljust(3, ' ')[:3], v.app_args.ljust(60, ' ')[:60],
                  v.wu_name.ljust(38, ' ')[:38] + '│', file=fileptr, sep='│')
            i += 1

        print('└─'.ljust(5, '─'), '─'.ljust(4, '─'), '─'.ljust(3, '─'), '─'.ljust(60, '─'),
              '─'.ljust(8, '─') + '─' + '─'.ljust(8, '─') + '─' + '─'.ljust(11, '─') + '─' +
              '─'.ljust(8, '─') + '┘', file=fileptr, sep='┴')

    def print_app_names(self, fileptr=sys.stdout):
        """
        Output app names for given job list.
        :param fileptr: fileptr for output, default is stdout
        :type fileptr: file
        :return: None
        """
        for v in self.list.values():
            print(v.app_name, file=fileptr)

    def print_wu_names(self, fileptr=sys.stdout):
        """
        Output work unit names for given job list.
        :param fileptr: fileptr for output, default is stdout
        :type fileptr: file
        :return: None
        """
        for v in self.list.values():
            print(v.wu_name, file=fileptr)

    def psv_print(self, env, fileptr=sys.stdout):
        """
        Output self to psv file or stdout as default.
        :param env:  environment
        :type env: BenchEnv
        :param fileptr: fileptr for output, default is stdout
        :type fileptr: file
        :return: None
        """
        print('Host', 'RunName', 'CPU', 'CPU-MHz', 'JobID', 'Platform', 'app_name', 'app_args', 'wu_name',
              'angle_range', 'spike_cnt', 'autocorr_cnt', 'pulse_cnt', 'triplet_cnt', 'gaussian_cnt', 'start_time',
              'complete_time', 'elapsed_time', 'real_time', 'user_time', 'sys_time', 'energy', 'max_power', 'maxmem',
              'swapnum', 'ctxswt', 'majpf', 'state', 'Q', 'similarity', 'error', file=fileptr, sep='|')
        for v in self.list.values():
            if (v.state == 'ACTIVE' or v.state == 'COMPLETE') and v.start_time != 'NA':
                start_time_str = v.start_time.strftime('%H:%M:%S')
            else:
                start_time_str = 'SKIPPED'
                # don't output skipped items to the psv file
                continue
            if v.state == 'COMPLETE' and v.start_time != 'NA':
                complete_time_str = v.complete_time.strftime('%H:%M:%S')
                elapsed_time = v.complete_time - v.start_time
            else:
                complete_time_str = 'SKIPPED'
                elapsed_time = 'SKIPPED'
            if v.error == '':
                error_str = 'None'
            else:
                error_str = v.error
            if env.prm.run_name == '':
                psv_run_name = 'NA'
            else:
                psv_run_name = env.prm.run_name
            print(env.prm.hostname, psv_run_name, env.prm.cpu_model, env.prm.cpu_mhz, v.uuid, v.platform, v.app_name,
                  v.app_args, v.wu_name, v.angle_range, v.cnt_spike, v.cnt_autocorr, v.cnt_pulse, v.cnt_triplet,
                  v.cnt_gaussian, start_time_str, complete_time_str, elapsed_time, v.time_real,
                  v.time_user, v.time_system, v.energy, v.max_power, v.time_maxmem, v.time_swapnum, v.time_ctxswt,
                  v.time_majpf, v.state, v.q_value, v.similarity, error_str, file=fileptr, sep='|')

    def jobcount_bystatus(self):
        """
        Return a dictionary of job counts with status as keys.
        :return: dictionary with job counts by status.
        :rtype: dict
        """
        num_pending_jobs = {'PENDING': 0, 'COMPLETE': 0, 'ACTIVE': 0, 'TOTAL': 0}
        for v in self.list.values():
            num_pending_jobs[v.state] += 1
            num_pending_jobs['TOTAL'] += 1
        return num_pending_jobs

    def pending_pjobs(self):
        """
        Return a dictionary of pending job counts with type as keys.
        :return: dictionary with pending job counts by type.
        :rtype: dict
        """
        num_pending_jobs = {'GPU': 0, 'CPU': 0, 'REF': 0}
        for v in self.list.values():
            if v.state == 'PENDING':
                num_pending_jobs[v.platform] += 1
        return num_pending_jobs

    def pending_jobs(self):
        """
        Return count of pending jobs.
        :return: pending job count
        :rtype: int
        """
        num_pending_jobs = 0
        for v in self.list.values():
            if v.state == 'PENDING':
                num_pending_jobs += 1
        return num_pending_jobs

    def all_complete(self, target=''):
        """
        Check if all jobs are complete. If platform is specified, then check is limited to that platform.
        :param target:  The target platform, all if not specified
        :type target: str
        :return:  True if all jobs complete
        :rtype: bool
        """
        for v in self.list.values():
            if target != '':
                if v.platform != target:
                    continue
            if v.state != 'COMPLETE':
                return False
        return True

    def num_cpu_jobs(self):
        """
        Return the number of cpu jobs.
        :return: Number of cpu jobs
        :rtype: int
        """
        cnt = 0
        for v in self.list.values():
            if v.platform == 'CPU' or v.platform == 'REF':
                cnt += 1
        return cnt

    def num_gpu_jobs(self):
        """
        Return the number of gpu jobs.
        :return: Number of gpu jobs
        :rtype: int
        """
        cnt = 0
        for v in self.list.values():
            if v.platform == 'GPU':
                cnt += 1
        return cnt

    def count_pending_pjobs(self, platform_list=('CPU', 'GPU')):
        """
        Returns the number of pending jobs for the platforms in the given list.
        :param platform_list: List of platform names
        :type platform_list: list
        :return: number of pending jobs
        :rtype: int
        """
        num_pending_jobs = 0
        for plat in platform_list:
            num_pending_jobs += self.pending_pjobs()[plat]
        return num_pending_jobs

    def request_job(self, target):
        """
        Return next pending job for specified platform.
        :param target: Target platform
        :type target: str
        :return: The uuid of next pending job or None if none are pending
        :rtype: Union([str, None])
        """
        for v in self.list.values():
            if v.state == 'PENDING' and v.platform == target:
                return v.uuid
        return None

    def wait_for_complete_job(self, env):
        """
        Waits for next job to complete and return the freed slot.
        :param env: Environment
        :type env: BenchEnv
        :return: freed slot ID
        :rtype: int
        """
        while True:
            time.sleep(3)
            for v in self.list.values():
                if v.state == 'ACTIVE':
                    es = v.cmd.poll()
                    if es is None:
                        if env.prm.mode_energy:
                            if v.platform == 'GPU':
                                v.gpu_card.update_energy_data()
                    else:
                        print('='.ljust(80, '='), file=env.sum_file_ptr)
                        v.complete_time = datetime.utcnow()
                        v.state = 'COMPLETE'
                        v.exit_status = es
                        if env.prm.mode_energy:
                            if v.platform == 'GPU':
                                v.energy = round(v.gpu_card.get_energy(), 6)
                                v.max_power = round(v.gpu_card.get_max_power(), 2)
                        if v.exit_status != 0:
                            v.error = v.error + '[Job Execution error]'
                            print('ERROR: time returned non zero.  Job execution error')
                            print('ERROR: time returned non zero.  Job execution error', file=env.sum_file_ptr)

                        if v.platform != 'REF':
                            # Read results of time from the subprocess
                            for line in v.cmd.stderr:
                                linestr = line.decode('utf-8').strip()
                                if MB_CONST.DEBUG: print('Time output: {}'.format(linestr))
                                srch_obj = re.search('Real=', linestr)
                                if srch_obj:
                                    line_items = linestr.split('|')
                                    for timestr in line_items:
                                        time_item = timestr.split('=')
                                        if time_item[0] == 'Real':
                                            v.time_real = time_item[1]
                                        elif time_item[0] == 'User':
                                            v.time_user = time_item[1]
                                        elif time_item[0] == 'System':
                                            v.time_system = time_item[1]
                                        elif time_item[0] == 'MaxMem':
                                            v.time_maxmem = time_item[1]
                                        elif time_item[0] == 'SwapNum':
                                            v.time_swapnum = time_item[1]
                                        elif time_item[0] == 'CtxSwt':
                                            v.time_ctxswt = time_item[1]
                                        elif time_item[0] == 'MajPF':
                                            v.time_majpf = time_item[1]

                            # Find ref-result file
                            file_srch = glob.glob(os.path.join(env.prm.ref_results_path,
                                                               'ref-result.*.{}.sah'.format(v.wu_name)))
                            if file_srch:
                                ref_result_file = file_srch[0]
                            else:
                                ref_result_file = ''
                                v.error = v.error + '[Can not open ref-result file]'

                            # Copy result and stderr files to testData
                            cur_result_file = os.path.join(env.prm.summary_path,
                                                           'result.{}.{}.{}.sah'.format(v.app_name, v.wu_name, v.uuid))
                            cur_stderr_file = os.path.join(env.prm.summary_path,
                                                           'stderr.{}.{}.{}.txt'.format(v.app_name, v.wu_name, v.uuid))
                            mb_result_file = os.path.join(v.slot_dir, 'result.sah')
                            ap_result_file = os.path.join(v.slot_dir, 'work_unit.sah')
                            stderr_file = os.path.join(v.slot_dir, 'stderr.txt')
                            if os.path.isfile(mb_result_file):
                                # Copy over MB data
                                shutil.copy2(mb_result_file, cur_result_file)
                                os.remove(mb_result_file)
                                if MB_CONST.DEBUG: print('Copy2:  {} to {}'.format(mb_result_file, cur_result_file))
                            elif os.path.isfile(ap_result_file):
                                # Copy over astropulse data
                                shutil.copy2(ap_result_file, cur_result_file)
                                os.remove(ap_result_file)
                                if MB_CONST.DEBUG: print('Copy2:  {} to {}'.format(ap_result_file, cur_result_file))
                            else:
                                v.error = v.error + '[No results.sah file]'
                            if os.path.isfile(stderr_file):
                                # copy over stderr file
                                shutil.copy2(stderr_file, cur_stderr_file)
                                os.remove(stderr_file)
                                if MB_CONST.DEBUG: print('Copy2:  {} to {}'.format(stderr_file, cur_stderr_file))
                            else:
                                v.error = v.error + '[No stderr.txt file]'

                            # Get parameters like AR and signal counts from results file
                            if not env.prm.mode_astropulse:
                                v.cnt_spike = 0
                                v.cnt_autocorr = 0
                                v.cnt_pulse = 0
                                v.cnt_triplet = 0
                                v.cnt_gaussian = 0

                                try:
                                    if os.path.isfile(cur_result_file):
                                        with open(cur_result_file, 'r') as resfptr:
                                            for line in resfptr:
                                                linestr = line.strip()
                                                if len(linestr) < 2: continue
                                                if linestr[0] == '#': continue
                                                if v.angle_range == 0:
                                                    srch_obj = re.search('true_angle_range', linestr)
                                                    if srch_obj:
                                                        line_items = linestr.split('true_angle_range')
                                                        ar_str = re.sub(r'[^\d.]', '', line_items[1])
                                                        if MB_CONST.DEBUG: print('Angle Range: [{}]'.format(ar_str))
                                                        v.angle_range = float(ar_str)
                                                        continue
                                                srch_obj = re.search(r'<spike>', linestr)
                                                if srch_obj:
                                                    v.cnt_spike += 1
                                                    continue
                                                srch_obj = re.search(r'<autocorr>', linestr)
                                                if srch_obj:
                                                    v.cnt_autocorr += 1
                                                    continue
                                                srch_obj = re.search(r'<pulse>', linestr)
                                                if srch_obj:
                                                    v.cnt_pulse += 1
                                                    continue
                                                srch_obj = re.search(r'<triplet>', linestr)
                                                if srch_obj:
                                                    v.cnt_triplet += 1
                                                    continue
                                                srch_obj = re.search(r'<gaussian>', linestr)
                                                if srch_obj:
                                                    v.cnt_gaussian += 1
                                                    continue
                                except OSError as except_err:
                                    print('Fatal Error: {} in reading results.'.format(except_err))
                                    print('    Are you running AP benchmarks and not in astropulse mode?')

                                # Write to run log
                                print('App Name: {}'.format(v.app_name), file=env.sum_file_ptr)
                                print('App Args: {}'.format(v.app_args), file=env.sum_file_ptr)
                                print('WU Name:  {}'.format(v.wu_name), file=env.sum_file_ptr)
                                if not env.prm.mode_astropulse:
                                    print('WU Angle Range: {}'.format(v.angle_range), file=env.sum_file_ptr)
                                    print('Spike count:    {}'.format(v.cnt_spike), file=env.sum_file_ptr)
                                    print('Autocorr count: {}'.format(v.cnt_autocorr), file=env.sum_file_ptr)
                                    print('Pulse count:    {}'.format(v.cnt_pulse), file=env.sum_file_ptr)
                                    print('Triplet count:  {}'.format(v.cnt_triplet), file=env.sum_file_ptr)
                                    print('Gaussian count: {}'.format(v.cnt_gaussian), file=env.sum_file_ptr)
                                print('Results:  {}'.format(cur_result_file), file=env.sum_file_ptr)
                                print('REF Name: {}'.format(ref_result_file), file=env.sum_file_ptr)
                                print('', file=env.sum_file_ptr)
                                print('Real Time:   {}'.format(v.time_real), file=env.sum_file_ptr)
                                print('User Time:   {}'.format(v.time_user), file=env.sum_file_ptr)
                                print('System Time: {}'.format(v.time_system), file=env.sum_file_ptr)
                                print('MaxMem:      {}'.format(v.time_maxmem), file=env.sum_file_ptr)
                                print('SwapNum:     {}'.format(v.time_swapnum), file=env.sum_file_ptr)
                                print('CtxSwt:      {}'.format(v.time_ctxswt), file=env.sum_file_ptr)
                                print('MajPF:       {}'.format(v.time_majpf), file=env.sum_file_ptr)
                                if env.prm.mode_energy:
                                    if v.platform == 'GPU':
                                        print('Energy:      {} kWh'.format(v.energy), file=env.sum_file_ptr)
                                        print('Max Power:   {} W'.format(v.max_power), file=env.sum_file_ptr)
                                print('', file=env.sum_file_ptr)

                                if ref_result_file != '' and not env.prm.mode_astropulse:
                                    # Compare results to reference
                                    v.similarity = 'Unknown'
                                    v.q_value = 'Unknown'
                                    command_str = '{} {} {} 2>/dev/null'.format(env.prm.wucmpcmd,
                                                                                cur_result_file, ref_result_file)
                                    if MB_CONST.DEBUG: print('Results compare command: {}'.format(command_str))
                                    cmd = subprocess.Popen(command_str, shell=True, stdout=subprocess.PIPE)
                                    for line in cmd.stdout:
                                        linestr = line.decode('utf-8').strip()
                                        print(linestr, file=env.sum_file_ptr)
                                        if MB_CONST.DEBUG: print('Results compare output: {}'.format(linestr))
                                        srch_obj = re.search('Result', linestr)
                                        if srch_obj:
                                            line_str_items = linestr.split(':')
                                            if len(line_str_items) >= 2:
                                                result_str = line_str_items[1].strip()
                                                result_str_items = result_str.split(',')
                                                v.similarity = result_str_items[0].strip()
                                                v.similarity = v.similarity.replace('.', '')
                                                if len(result_str_items) >= 2:
                                                    q_str_items = result_str_items[1].split('=')
                                                    v.q_value = q_str_items[1].strip()
                                                else:
                                                    v.q_value = '0.0%'
                                            else:
                                                v.similarity = 'ERROR'
                                                v.q_value = 'ERROR'
                                    cmd.stdout.close()
                                else:
                                    print('Error: No reference results file.', file=env.sum_file_ptr)
                                print('='.ljust(80, '='), file=env.sum_file_ptr)
                                print('', file=env.sum_file_ptr)
                            else:
                                print('ERROR: can not open results file: {}'.format(cur_result_file))
                                # Write to run log
                                print('ERROR: can not open results file: {}'.format(cur_result_file,
                                      file=env.sum_file_ptr))
                                print('App Name: {}'.format(v.app_name), file=env.sum_file_ptr)
                                print('App Args: {}'.format(v.app_args), file=env.sum_file_ptr)
                                print('WU Name:  {}'.format(v.wu_name), file=env.sum_file_ptr)
                                print('Results:  {}'.format(cur_result_file), file=env.sum_file_ptr)
                                print('REF Name: {}'.format(ref_result_file), file=env.sum_file_ptr)
                                print('', file=env.sum_file_ptr)
                                print('Real Time:   {}'.format(v.time_real), file=env.sum_file_ptr)
                                print('User Time:   {}'.format(v.time_user), file=env.sum_file_ptr)
                                print('System Time: {}'.format(v.time_system), file=env.sum_file_ptr)
                                print('MaxMem:      {}'.format(v.time_maxmem), file=env.sum_file_ptr)
                                print('SwapNum:     {}'.format(v.time_swapnum), file=env.sum_file_ptr)
                                print('CtxSwt:      {}'.format(v.time_ctxswt), file=env.sum_file_ptr)
                                print('MajPF:       {}'.format(v.time_majpf), file=env.sum_file_ptr)
                                print('', file=env.sum_file_ptr)

                        else:  # v.platform == REF
                            # Move results file to testData or testData/REF_RESULTS
                            ref_app_name = v.app_name.replace('ref-cpu.', '')

                            # Process results file
                            dest_file = os.path.join(env.prm.ref_results_path, 'ref-result.{}.{}.sah'.format(
                                ref_app_name, v.wu_name))
                            print('Processing new reference results:\n   {}:'.format(dest_file), file=env.sum_file_ptr)
                            mb_result_file = os.path.join(v.slot_dir, 'result.sah')
                            if os.path.isfile(mb_result_file):
                                shutil.copy2(mb_result_file, dest_file)
                                os.remove(mb_result_file)
                                if MB_CONST.DEBUG: print('Copy2:  {} to {}'.format(mb_result_file, dest_file))
                            else:
                                print('ERROR: can not open result file: {}'.format(mb_result_file))
                                v.error = v.error + '[No result.sah file]'
                            # Process stderr file
                            dest_file = os.path.join(env.prm.ref_results_path, 'ref-stderr.{}.{}.txt'.format(
                                ref_app_name, v.wu_name))
                            print('   {}:'.format(dest_file), file=env.sum_file_ptr)
                            stderr_file = os.path.join(v.slot_dir, 'stderr.txt')
                            if os.path.isfile(stderr_file):
                                shutil.copy2(stderr_file, dest_file)
                                os.remove(stderr_file)
                                if MB_CONST.DEBUG: print('Copy2:  {} to {}'.format(stderr_file, dest_file))
                            else:
                                print('ERROR: can not open stderr file: {}'.format(stderr_file))
                                v.error = v.error + '[No stderr.txt file]'
                            print('='.ljust(80, '='), file=env.sum_file_ptr)

                        # Clean slot
                        for filename in ['boinc_finish_called', 'boinc_lockfile', 'state.sah', 'wisdom.sah', 'fold.dat',
                                         'fold.dat0', 'fold.dat1', 'indices.txt', 'ap_state.dat', 'ap_state.dat0',
                                         'ap_state.dat1', 'pulse.out', 'pulse.out0', 'pulse.out1']:
                            del_file = os.path.join(v.slot_dir, filename)
                            if os.path.isfile(del_file):
                                os.remove(del_file)
                                if MB_CONST.DEBUG: print('Clean slots removed: {}'.format(del_file))

                        freed_slot = v.slot
                        v.slot = None
                        return freed_slot


class Slots:
    """
    Slots are used as containers for compute jobs and one is created for each identified compute unit.
    """
    def __init__(self, item_id):
        self.slot_num = item_id
        self.slot_dir = ''
        self.device = None
        self.platform = ''              # GPU, CPU
        self.job = ''                   # Job uuid
        self.state = 'EMPTY'            # EMPTY, ACTIVE
        self.gpu_card = None


class SlotsList:
    """
    Slots list is a object to store all available slots.
    """
    def __init__(self):
        self.list = {}

    def create_slot_list(self, max_slots):
        """
        Initializes a slot list to contain slots for max_slots compute units.
        :param max_slots: represents the number of total compute units to be used.
        :type max_slots: int
        :return: None
        """
        self.list = {}
        for i in range(0, max_slots):
            self.list[i] = Slots(i)

    def initialize_slots(self, env, num_gpu_slots):
        """
        This will make the slots subdirectories to support job processing by each slot.  It will classify
        and allocate Slots by platform.
        :param env: Environment
        :type env: BenchEnv
        :param num_gpu_slots:  Number of slots to be allocated to GPU compute
        :type num_gpu_slots: int
        :return: True if successful
        :rtype: bool
        """
        if os.path.isdir(env.prm.slots_path):
            shutil.rmtree(env.prm.slots_path)
        os.mkdir(env.prm.slots_path)
        if not os.path.isdir(env.prm.slots_path):
            print('Failed to make Slots directory [{}]'.format(env.prm.slots_path))
            return False
        if num_gpu_slots > 0:
            # Copy .cl files to workdir
            for cl_files in glob.glob(os.path.join(env.prm.gpu_app_path, '*.cl')):
                shutil.copy2(cl_files, env.prm.workdir_path)
        gpu_device_index = 0
        for v in self.list.values():
            v.slot_dir = os.path.join(env.prm.slots_path, str(v.slot_num))
            os.mkdir(v.slot_dir)
            if not os.path.isdir(v.slot_dir):
                print('Failed to make Slots directory [{}]'.format(v.slot_dir))
                return False

            # Copy init_data.xml from template to slot
            if not os.path.isfile(os.path.join(v.slot_dir, 'init_data.xml')):
                shutil.copy2(env.prm.init_data_template_file, os.path.join(v.slot_dir, 'init_data.xml'))
            if num_gpu_slots > 0:
                v.platform = 'GPU'
                v.device = env.prm.gpu_devices[gpu_device_index]
                num_gpu_slots -= 1
                gpu_device_index += 1
            else:
                v.platform = 'CPU'
        return True

    def all_complete(self, target=''):
        """
        Check if all slots have completed processing.
        :param target:  specified platform, all if not specified
        :type target: str
        :return: True if all slots have completed processing
        :rtype: bool
        """
        if target == 'REF': target = 'CPU'
        for v in self.list.values():
            if target != '':
                if v.platform != target:
                    continue
            if v.state == 'ACTIVE' or v.state == 'PENDING':
                return False
        return True

    def available_pslots(self):
        """
        Return a dictionary of available slots by platform.
        :return: dictionary of available slots by platform
        :rtype: dict
        """
        num_avail_slots = {'GPU': 0, 'CPU': 0, 'REF': 0}
        for v in self.list.values():
            if v.state == 'EMPTY':
                num_avail_slots[v.platform] += 1
        num_avail_slots['REF'] = num_avail_slots['CPU']
        return num_avail_slots

    def available_slots(self):
        """
        Return the number of total available slots.
        :return:  number of total available slots
        :rtype: int
        """
        num_avail_slots = 0
        for v in self.list.values():
            if v.state == 'EMPTY':
                num_avail_slots += 1
        return num_avail_slots

    def assign_job(self, jobs, slot_id, job_id, gpu_list, device):
        """
        Assign a job to a slot.
        :param jobs: The job list
        :type jobs: JobList
        :param slot_id: The slot number
        :type slot_id: int
        :param job_id: The job's uuid
        :type job_id: hex
        :param gpu_list: GpuList object with all system GPUs
        :type gpu_list: GpuList
        :param device: BOINC device number
        :type device: int
        :return: None
        """
        self.list[slot_id].state = 'ACTIVE'
        self.list[slot_id].job = jobs.list[job_id]
        jobs.list[job_id].state = 'ACTIVE'
        jobs.list[job_id].slot = slot_id
        jobs.list[job_id].slot_dir = self.list[slot_id].slot_dir
        jobs.list[job_id].gpu_card = gpu_list.get_device_gpu(device)
        if jobs.list[job_id].gpu_card:
            jobs.list[job_id].gpu_card.reset_energy()

    def request_slot(self, target):
        """
        Get an available slot for a specific platform.
        :param target:  The specified platform
        :type target: str
        :return: The slot number or None if none are available
        :rtype: Union([int, None])
        """
        if target == 'REF': target = 'CPU'
        for v in self.list.values():
            if v.state == 'EMPTY' and v.platform == target:
                return v.slot_num
        return None

    def free_slot(self, slot_id):
        """
        Free the specified slot.
        :param slot_id:  The slot's number
        :type slot_id: int
        :return: None
        """
        self.list[slot_id].state = 'EMPTY'
        self.list[slot_id].job = ''

    def print(self, title=''):
        """
        Simple formatted output of slot list.
        :param title: Title of the table output.
        :type title: str
        :return: None
        .. todo:: Convert to format print
        """
        if title == '':
            print('Slot list:')
        else:
            print(title)

        i = 0
        print('SlotNum', 'platform', 'device', 'state', 'job', 'SlotDir', sep=' | ')
        for i, v in enumerate(self.list.values(), start=1):
            slotnum_str = '-' + str(v.slot_num)
            slotnum_str = slotnum_str.ljust(8, '-')
            plat_str = ' ' + v.platform
            plat_str = plat_str.ljust(8, ' ')
            if v.device is None:
                dev_str = ' NA'
            else:
                dev_str = ' ' + str(v.device)
            dev_str = dev_str.ljust(7, ' ')
            state_str = v.state
            state_str = state_str.ljust(6, ' ')
            if v.job == '':
                job_str = 'None'
            else:
                job_str = v.job.uuid
            print('{}|  {}| {}| {}| {}| {}'.format(slotnum_str, plat_str, dev_str,
                                                   state_str, job_str, v.slot_dir), sep='')
        print('##### {} total slots'.format(i))

    def print_activity(self, joblist, compact_flag=False, fileptr=sys.stdout):
        """
        Formatted table output of slot list.
        :param joblist: Object containing the list of jobs
        :type joblist: JobList
        :param compact_flag:  Flag to indicate compact table option.
        :type compact_flag: bool
        :param fileptr: specifies the output, default is stdout
        :type fileptr: file
        :return:  None
        .. note:: Print is optimized for 112 columns
        .. todo:: Convert to format print
        """
        num_jobs = joblist.jobcount_bystatus()
        print('\n   ' + str(num_jobs['COMPLETE']) + ' of ' + str(num_jobs['TOTAL']) + ' jobs complete\n', file=fileptr)
        print('┌─'.ljust(5, '─'), '─'.ljust(3, '─'), '─'.ljust(3, '─'), '─'.ljust(40, '─'), '─'.ljust(30, '─'),
              '─'.ljust(10, '─'), '─'.ljust(10, '─') + '┐', file=fileptr, sep='┬')

        if fileptr == sys.stdout:
            print('│\x1b[1;36m' + 'Slot'.ljust(4, ' ') + '\x1b[0m',
                  '\x1b[1;36m' + 'xPU'.ljust(3, ' ') + '\x1b[0m',
                  '\x1b[1;36m' + 'DEV'.ljust(3, ' ') + '\x1b[0m',
                  '\x1b[1;36m' + 'app_name'.ljust(40, ' ') + '\x1b[0m',
                  '\x1b[1;36m' + 'app_args'.ljust(30, ' ') + '\x1b[0m',
                  '\x1b[1;36m' + 'wu_name'.ljust(10, ' ') + '\x1b[0m',
                  '\x1b[1;36m' + ' state'.ljust(10, ' ') + '\x1b[0m' + '│', file=fileptr, sep='│')
        else:
            print('│Slot'.ljust(5, ' '), 'xPU'.ljust(3, ' '), 'DEV'.ljust(3, ' '), 'app_name'.ljust(40, ' '),
                  'app_args'.ljust(30, ' '), 'wu_name'.ljust(10, ' '), ' state'.ljust(10, ' ') + '│',
                  file=fileptr, sep='│')

        for v in self.list.values():
            slotnum_str = ' ' + str(v.slot_num)
            if v.device is None:
                dev_str = ' NA'
            else:
                dev_str = ' ' + str(v.device)
            state_str = v.state
            state_str = state_str.ljust(6, ' ')
            if v.job == '':
                app_str = 'None'
                app_arg_str = 'None'
                wu_name_str = 'None'
            else:
                app_str = joblist.list[v.job.uuid].app_name
                app_arg_str = joblist.list[v.job.uuid].app_args
                wu_name_str = joblist.list[v.job.uuid].wu_name

            # if printing to stdout, use state colors
            if fileptr == sys.stdout:
                if v.state == 'ACTIVE':
                    # Blue
                    state_str = '\x1b[1;37;44m' + ('  '+v.state).ljust(10, ' ')[:10] + '\x1b[0m'
                elif v.state == 'EMPTY':
                    # Yellow
                    state_str = '\x1b[1;30;43m' + ('  '+v.state).ljust(10, ' ')[:10] + '\x1b[0m'
            else:
                state_str = v.state.ljust(10, ' ')[:10]

            if not compact_flag:
                print('├─'.ljust(5, '─'), '─'.ljust(3, '─'), '─'.ljust(3, '─'), '─'.ljust(40, '─'), '─'.ljust(30, '─'),
                      '─'.ljust(10, '─'), '─'.ljust(10, '─') + '┤', file=fileptr, sep='┼')
            print('│' + slotnum_str.ljust(4, ' '), v.platform.ljust(3, ' ')[:3], dev_str.ljust(3, ' '),
                  app_str.ljust(40, ' ')[:40], app_arg_str.ljust(30, ' ')[:30], wu_name_str.ljust(10, ' ')[:10],
                  state_str + '│', file=fileptr, sep='│')

        print('└─'.ljust(5, '─'), '─'.ljust(3, '─'), '─'.ljust(3, '─'), '─'.ljust(40, '─'), '─'.ljust(30, '─'),
              '─'.ljust(10, '─'), '─'.ljust(10, '─') + '┘', file=fileptr, sep='┴')


def main():
    """
    Main function for benchMT.
    """
    parser = argparse.ArgumentParser()
    parser.add_argument('--about', help='README',
                        action='store_true', default=False)
    parser.add_argument('-y', '--yes', help='Don\'t ask confirmation before running jobs',
                        action='store_true', default=False)
    parser.add_argument('--cfg_file', help='Specify name alternative CFG file',
                        type=str, default='BenchCFG')
    parser.add_argument('--run_name', help='Specify name of this run',
                        type=str, default='')
    parser.add_argument('--boinc_home', help='Specify path for BOINC',
                        type=str, default='')
    parser.add_argument('--noBS', help='Do not suspend BOINC',
                        action='store_true', default=False)
    parser.add_argument('--display_compact', help='Display compact run status',
                        action='store_true', default=False)
    parser.add_argument('--display_slots', help='Display run status by slots instead of jobs',
                        action='store_true', default=False)
    parser.add_argument('--num_repetitions', help='Specify number of times to run benchmark',
                        type=int, default=0)
    parser.add_argument('--max_threads', help='Specify max number of threads to load',
                        type=int, default=0)
    parser.add_argument('--max_gpus', help='Specify max number of GPUs to load',
                        type=int, default=0)
    parser.add_argument('--gpu_devices', help='Specify which GPUs to use: 0,1,2',
                        type=str, default='')
    parser.add_argument('--devmap', help='Specify mapping of boinc device to card #: {B:C,B:C}',
                        type=str, default='')
    parser.add_argument('--energy', help='Report energy usage (amdgpu driver only)',
                        action='store_true', default=False)
    parser.add_argument('--astropulse', help='Run in AstroPulse mode',
                        action='store_true', default=False)
    parser.add_argument('--std_signals', help='Use standard signal WUs instead of Test WUs',
                        action='store_true', default=False)
    parser.add_argument('--no_ref', help='Do not generate reference results',
                        action='store_true', default=False)
    parser.add_argument('--force_ref', help='Force generation of reference results',
                        action='store_true', default=False)
    parser.add_argument('--purge_kernels', help='Purge Cached Kernels from working directory',
                        action='store_true', default=False)
    parser.add_argument('--lsgpu', help='List GPU details',
                        action='store_true', default=False)
    parser.add_argument('--admin_mkdirs', help='Make required directories',
                        action='store_true', default=False)
    parser.add_argument('-d', '--debug', help='Debug output',
                        action='store_true', default=False)
    args = parser.parse_args()

    if args.about:
        print(__doc__)
        print('Author: ', __author__)
        print('Copyright: ', __copyright__)
        print('Credits: ', __credits__)
        print('License: ', __license__)
        print('Version: ', __version__)
        print('Maintainer: ', __maintainer__)
        print('Status: ', __status__)
        sys.exit(0)

    if args.debug: MB_CONST.DEBUG = True
    if args.noBS: MB_CONST.noBS = True

    # Initialize and verify working environment
    env = BenchEnv()
    MB_CONST.env = env

    # Check OS and python version
    if env.check_env() < 0:
        print('Error in environment. Exiting...')
        sys.exit(-1)

    if MB_CONST.DEBUG: MB_CONST.print()

    # Run set_env in order to populate numbers of GPU/CPU threads
    if not env.set_env():
        if args.admin_mkdirs:
            env.makedirs()
            sys.exit(0)
        print('Error in environment.  Exiting...')
        sys.exit(-1)

    # Check if purge of working directory kernels was specified
    if args.purge_kernels:
        env.purge_workdir_cache()

    # Check existence of Configuration File
    if args.cfg_file:
        if args.cfg_file != 'BenchCFG':
            test_command_line_file = os.path.join(env.prm.current_dir, args.cfg_file)
            if os.path.isfile(test_command_line_file):
                env.prm.command_line_file = test_command_line_file
            else:
                print('Specified BenchCFG [{}] does not exist'.format(test_command_line_file))
                sys.exit(-1)

    # Read BenchCFG file and create list of provided apps and arguments.
    # Determine if the apps are GPU or CPU by checking which APP_DIR they are located in
    cfg_modes = CfgModes()
    applist = JobList()
    applist.read_benchcfg(env, cfg_modes)
    if MB_CONST.DEBUG: applist.print(title='Initial app list')

    # Set options with CFG file mode statements and command line args
    env.process_options(args, cfg_modes)
    if MB_CONST.DEBUG: cfg_modes.print()

    # Run set_env_boinc in order to set boinc environment
    if not env.set_env_boinc():
        print('Error in BOINC environment.  Exiting...')
        sys.exit(-1)

    # Initialize list of all GPUs
    # TODO don't do all the GPU stuff if no GPU work to do!
    gpu_list = GpuList()
    gpu_list.set_gpu_list()
    gpu_list.set_env_boinc_gpu_details(env)
    env.prm.card_num_list = gpu_list.get_card_number_list(compute=True)

    # Setup devmap
    if env.prm.devmap:
        print('devmap: ', env.prm.devmap)
        if not gpu_list.set_devmap(env.prm.devmap, env.prm.boinc_dev_list, env.prm.card_num_list):
            print('Error in devmap. Exiting...')
            sys.exit(-1)

    # If energy reporting option is set, verify that device mapping is also set
    if env.prm.mode_energy:
        if len(env.prm.devmap) != env.prm.total_gpu_threads:
            print('With Energy mode, devmap must include all devices - devmap: {} devices: {}'.format(
                env.prm.devmap, env.prm.total_gpu_threads))
            sys.exit(-1)
    gpu_list.apply_devmap()

    # If lsgpu option is specified, display details and exit
    if args.lsgpu:
        gpu_list.print()
        sys.exit(0)

    # Check if specified GPUs exceed total GPUS and set env.gpu_devices
    if not env.prm.mode_gpu_devices:
        env.prm.gpu_devices = env.prm.boinc_dev_list
    else:
        if max(env.prm.mode_gpu_devices) > env.prm.total_gpu_threads - 1:
            print('Invalid gpu_device specified, max of {} is > number of GPUs [{} - 1 ]'.format(
                env.prm.mode_gpu_devices, env.prm.total_gpu_threads))
            print('Exiting...')
            sys.exit(-1)
        elif env.prm.mode_gpu_devices:
            env.prm.gpu_devices = env.prm.mode_gpu_devices
            print('Specified gpu_devices: {}'.format(env.prm.mode_gpu_devices))
        else:
            env.prm.gpu_devices = env.prm.boinc_dev_list

    # Allocate appropriate CPU threads
    if 0 < env.prm.specified_max_threads < env.prm.total_cpu_threads:
        env.prm.allocated_cthreads = env.prm.specified_max_threads
    else:
        env.prm.allocated_cthreads = env.prm.total_cpu_threads

    # Allocate appropriate GPU threads
    if 0 < env.prm.specified_max_gpus < env.prm.total_gpu_threads:
        env.prm.allocated_gthreads = env.prm.specified_max_gpus
    else:
        env.prm.allocated_gthreads = env.prm.total_gpu_threads

    # Allocate appropriate GPU threads based on specified GPUs
    if len(env.prm.gpu_devices) == env.prm.allocated_gthreads:
        print('Set specified gpu_devices: ', str(env.prm.gpu_devices))
    elif len(env.prm.gpu_devices) < env.prm.allocated_gthreads:
        print('Mismatch with allocated GPUS [{}], reset allocated devices to {}'.format(
            env.prm.allocated_gthreads, len(env.prm.gpu_devices)))
        env.prm.allocated_gthreads = len(env.prm.gpu_devices)
    else:
        print('Specified more GPUS [{}], than allocated [{}]'.format(
            len(env.prm.gpu_devices), env.prm.allocated_gthreads))

    # Setup for Energy mode
    if args.energy:
        num_eng_gpu = len(gpu_list.get_card_number_list(energy=True))
        if num_eng_gpu:
            print('GPU Energy metrics enabled for {} GPUs.'.format(num_eng_gpu))
        else:
            print('GPU Energy metrics not possible, disabling energy mode.')
            env.prm.mode_energy = False

    env.prm.gpu_details = gpu_list.get_gpu_details(compute=True)
    ###################################################
    # Print the final view of the execution environment
    env.print()
    ###################################################

    # Create a list of WUs to be processed
    wulist = JobList()
    wulist.read_wu_list(env)
    if MB_CONST.DEBUG: wulist.print(title='Initial WU list')

    if not env.prm.mode_no_ref:
        # Create a reference job list
        reflist = JobList()
        ref_app = BenchJob(uuid4().hex)

        # Determine ref_app name - only 1 app in REF_APP dir is used
        cwd = os.getcwd()
        os.chdir(env.prm.ref_app_path)
        ref_app.app_name = glob.glob('ref-cpu.*')[0]
        if not os.path.isfile(ref_app.app_name):
            print('Error: can not access reference app: [{}]'.format(ref_app.app_name))
        else:
            ref_app.app_args = ' --nographics'
            reflist.create_ref_list(ref_app, wulist)
        os.chdir(cwd)
        if env.prm.mode_force_ref:
            print('Forcing Reference Results Generation')
        else:
            reflist.check_ref_results(env)
        reflist.print(title='Reference Job List', show_skipped=True)

    # Create a final job list from the applist and wulist and append reflist
    joblist = JobList()
    joblist.create_job_list(applist, wulist, env)
    if not env.prm.mode_no_ref:
        joblist.append_job_list(reflist)
    joblist.print(title='Final Job List')

    # Prepare working slots
    num_cpu_jobs = max(joblist.pending_pjobs()['CPU'], joblist.pending_pjobs()['REF'])
    num_gpu_jobs = joblist.num_gpu_jobs()
    if num_cpu_jobs > 0 and num_gpu_jobs > 0 and env.prm.allocated_cthreads < 2:
        print('ERROR: Insufficient threads available for specified jobs. Exiting...')
        sys.exit(-1)
    if num_gpu_jobs > env.prm.allocated_gthreads:
        num_gpu_slots = env.prm.allocated_gthreads
    else:
        num_gpu_slots = num_gpu_jobs

    if num_gpu_slots >= env.prm.allocated_cthreads and num_cpu_jobs > 0:
        num_gpu_slots = env.prm.allocated_cthreads - 1
    elif num_gpu_slots >= env.prm.allocated_cthreads and num_cpu_jobs == 0:
        num_gpu_slots = env.prm.allocated_cthreads
    if num_gpu_slots < 1 and num_gpu_jobs > 0:
        print('ERROR: Insufficient threads available for specified jobs. Exiting...')
        sys.exit(-1)

    if num_cpu_jobs + num_gpu_slots < env.prm.allocated_cthreads:
        env.prm.allocated_cthreads = num_cpu_jobs + num_gpu_slots

    env.prm.allocated_gthreads = num_gpu_slots
    print('For {} CPU jobs and {} GPU slots. Allocated Threads reduced to {}.'.format(num_cpu_jobs,
                                                                                      env.prm.allocated_gthreads,
                                                                                      env.prm.allocated_cthreads))

    # Check if there is already and instance running in this directory
    if env.is_bench_conflict():
        print('Another instance of benchMT is running in this directory, exiting...')
        sys.exit(-1)

    slots = SlotsList()
    slots.create_slot_list(env.prm.allocated_cthreads)
    if not slots.initialize_slots(env, num_gpu_slots):
        sys.exit(-1)
    slots.print(title='List of Initialized Slots')

    # Execute the joblist
    num_pending_pjobs = joblist.pending_pjobs()
    num_pending_jobs = num_pending_pjobs['CPU'] + num_pending_pjobs['GPU']
    print('Pending jobs (CPU/GPU): {}/{}'.format(num_pending_pjobs['CPU'], num_pending_pjobs['GPU']))
    print('Pending reference jobs: {}'.format(num_pending_pjobs['REF']))
    if num_pending_jobs < 1:
        print('No jobs to execute.  Exiting...')
        sys.exit(1)
    if not env.prm.mode_yes:
        if input('Execute listed jobs? [y/N]').lower() != 'y':
            sys.exit(1)

    if not MB_CONST.DEBUG: os.system('clear')
    if env.prm.mode_display_slots:
        slots.print_activity(joblist, env.prm.mode_display_compact)
    else:
        joblist.print(env.prm.mode_display_compact)

    # Make testData subdirectory for this run and open summary file for writing
    # Update summary_path in case the run name was set
    env.prm.summary_path = os.path.join(env.prm.testdata_path, '{}_benchMT_{}_{}'.format(env.prm.hostname,
                                                                                         env.prm.run_name,
                                                                                         env.prm.time_now_short))
    env.prm.summary_file = os.path.join(env.prm.summary_path, '{}_testlog_{}_{}.txt'.format(env.prm.hostname,
                                                                                            env.prm.run_name,
                                                                                            env.prm.time_now_short))
    env.prm.psv_file = os.path.join(env.prm.summary_path, '{}_timelog_{}_{}.psv'.format(env.prm.hostname,
                                                                                        env.prm.run_name,
                                                                                        env.prm.time_now_short))

    os.mkdir(env.prm.summary_path)
    if not os.path.isdir(env.prm.summary_path):
        print('Failed to make benchMT testData subdir [{}]'.format(env.prm.summary_path))
        sys.exit(-1)
    env.sum_file_ptr = open(env.prm.summary_file, 'w', 1)
    env.psv_file_ptr = open(env.prm.psv_file, 'w', 1)
    print('{} {} \u2015 SETI MB/AP Benchmarking Utility \u2015 Linux Edition\n'.format(__program_name__, __version__),
          file=env.sum_file_ptr)
    if not env.prm.mode_noBS:
        print('Suspending BOINC\n', file=env.sum_file_ptr)
        env.suspend_boinc()
    print('System Details', file=env.sum_file_ptr)
    env.print(fileptr=env.sum_file_ptr)
    print('\nAPP List', file=env.sum_file_ptr)
    applist.print_app_names(fileptr=env.sum_file_ptr)
    print('\nWU List', file=env.sum_file_ptr)
    wulist.print_wu_names(fileptr=env.sum_file_ptr)
    print('', file=env.sum_file_ptr)

    # Loop to run all of the jobs
    if num_pending_pjobs['REF'] > 0:
        platform_list = ['REF']
    else:
        platform_list = ['CPU', 'GPU']

    while True:
        num_available_pslots = slots.available_pslots()
        num_pending_pjobs = joblist.pending_pjobs()
        num_pending_jobs = joblist.count_pending_pjobs(platform_list)
        if num_pending_jobs > 0:
            for plat in platform_list:
                if MB_CONST.DEBUG:
                    print('Platform: {} Total Pending Jobs: {}'.format(plat, num_pending_jobs))
                    print('Pending jobs (CPU/GPU/REF): {}/{}/{}'.format(num_pending_pjobs['CPU'],
                                                                        num_pending_pjobs['GPU'],
                                                                        num_pending_pjobs['REF']))
                    print('Available slots (CPU/GPU): {}/{}\n'.format(num_available_pslots['CPU'],
                                                                      num_available_pslots['GPU']))
                while num_available_pslots[plat] > 0 and num_pending_pjobs[plat] > 0:
                    # get an available job for open slot
                    slot_num = slots.request_slot(plat)
                    job_num = joblist.request_job(plat)
                    if MB_CONST.DEBUG: print('SlotNum: {}, JobUUID: {}.'.format(slot_num, job_num))

                    # changes states in both job and slot
                    slots.assign_job(joblist, slot_num, job_num, gpu_list, slots.list[slot_num].device)

                    # Copy WU to slot
                    shutil.copy2(os.path.join(slots.list[slot_num].job.wu_path, slots.list[slot_num].job.wu_name),
                                 os.path.join(slots.list[slot_num].slot_dir, MB_CONST.activeWU))
                    # Also copy using AP name, just in case the app is AP
                    shutil.copy2(os.path.join(slots.list[slot_num].job.wu_path, slots.list[slot_num].job.wu_name),
                                 os.path.join(slots.list[slot_num].slot_dir, MB_CONST.activeAPWU))

                    # Construct app/arg list
                    if plat == 'GPU':
                        device_arg = '-device {}'.format(slots.list[slot_num].device)
                        slots.list[slot_num].job.app_args = '{} {}'.format(device_arg,
                                                                           slots.list[slot_num].job.app_args)
                        cmd_str = '{} {}'.format(os.path.join(env.prm.gpu_app_path, slots.list[slot_num].job.app_name),
                                                 slots.list[slot_num].job.app_args)
                    elif plat == 'CPU':
                        cmd_str = '{} {}'.format(os.path.join(env.prm.cpu_app_path, slots.list[slot_num].job.app_name),
                                                 slots.list[slot_num].job.app_args)
                    else:
                        cmd_str = '{} {}'.format(os.path.join(env.prm.ref_app_path, slots.list[slot_num].job.app_name),
                                                 slots.list[slot_num].job.app_args)
                    if MB_CONST.DEBUG: print(cmd_str)

                    # Execute job with time command
                    cmd_str = '{} -f \"Real=%e|User=%U|System=%S|MaxMem=%M|SwapNum=%W|CtxSwt=%c|MajPF=%F\" {}'.format(
                        MB_CONST.cmd_time, cmd_str)
                    if MB_CONST.DEBUG:
                        print('\n\nRun Details')
                        print('Final command: {}'.format(cmd_str))
                        print('Execution directory: {}'.format(slots.list[slot_num].slot_dir))

                    # cd to slot dir and execute app with args
                    os.chdir(slots.list[slot_num].slot_dir)
                    slots.list[slot_num].job.start_time = datetime.utcnow()
                    try:
                        slots.list[slot_num].job.cmd = subprocess.Popen(shlex.split(cmd_str),
                                                                        shell=False, stderr=subprocess.PIPE)
                        time.sleep(.5)
                    except (subprocess.CalledProcessError, OSError) as except_err:
                        # This exception is not effective since time succeeds even if the app fails to run.
                        print('Fatal Error: {} can not execute to process job: [{}].\n'.format(except_err, cmd_str))
                        env.sum_file_ptr.close()
                        env.psv_file_ptr.close()
                        sys.exit(-1)
                    if slots.list[slot_num].job.cmd.poll() is not None:
                        # If the command finishes in less than 500ms, assume failure
                        slots.list[slot_num].job.complete_time = datetime.utcnow()
                        slots.list[slot_num].job.state = 'COMPLETE'
                        slots.list[slot_num].job.exit_status = 'ERROR'
                        slots.list[slot_num].job.error = slots.list[slot_num].job.error + '[Job Execution error]'
                        # slots.free_slot(slots.list[slot_num]) Not sure why PyCharm doesn't flag this
                        slots.free_slot(slot_num)
                        print('='.ljust(80, '='), file=env.sum_file_ptr)
                        print('ERROR: could not spawn MB process: {}'.format(cmd_str))
                        print('ERROR: could not spawn MB process: {}'.format(cmd_str), file=env.sum_file_ptr)
                        print('='.ljust(80, '='), file=env.sum_file_ptr)
                    os.chdir(env.prm.current_dir)
                    num_available_pslots = slots.available_pslots()
                    num_pending_pjobs = joblist.pending_pjobs()
                    # end while
                # end for plat
                num_pending_jobs = joblist.count_pending_pjobs(platform_list)
            # end if num_pending_jobs > 0

        # refresh screen
        if not MB_CONST.DEBUG: os.system('clear')
        if env.prm.mode_display_slots:
            slots.print_activity(joblist, env.prm.mode_display_compact)
        else:
            joblist.print(env.prm.mode_display_compact)

        # This is the part where we wait for jobs to complete
        num_pending_jobs = joblist.count_pending_pjobs(platform_list)
        if num_pending_jobs == 0:
            # Wait for all jobs to finish
            if platform_list[0] == 'REF':
                wait_str = 'REF'
            else:
                wait_str = ''
            while not slots.all_complete(target=wait_str):
                freed_slot = joblist.wait_for_complete_job(env)
                slots.free_slot(freed_slot)
                if not MB_CONST.DEBUG: os.system('clear')
                if env.prm.mode_display_slots:
                    slots.print_activity(joblist, env.prm.mode_display_compact)
                else:
                    joblist.print(env.prm.mode_display_compact)
            # No more pending jobs and all active jobs complete
            if platform_list[0] == 'REF':
                if MB_CONST.DEBUG: print('Switching platforms')
                platform_list = ['CPU', 'GPU']
        else:
            # Wait for appropriate slot to be available
            num_available_pslots = slots.available_pslots()
            num_pending_pjobs = joblist.pending_pjobs()
            for plat in platform_list:
                if num_available_pslots[plat] == 0 and num_pending_pjobs[plat] > 0:
                    freed_slot = joblist.wait_for_complete_job(env)
                    slots.free_slot(freed_slot)

        num_available_pslots = slots.available_pslots()
        num_pending_pjobs = joblist.pending_pjobs()
        num_pending_jobs = joblist.pending_jobs()
        if MB_CONST.DEBUG: print(num_pending_jobs)
        if joblist.all_complete():
            break
        # End of while True

    if not MB_CONST.DEBUG: os.system('clear')
    if env.prm.mode_display_slots:
        slots.print_activity(joblist, env.prm.mode_display_compact)
    else:
        joblist.print(env.prm.mode_display_compact)
    if MB_CONST.DEBUG: slots.print()

    # Finalize reports
    joblist.print(fileptr=env.sum_file_ptr)
    joblist.psv_print(env, fileptr=env.psv_file_ptr)

    os.chdir(env.prm.current_dir)
    if not env.prm.mode_noBS:
        print('Resuming BOINC', file=env.sum_file_ptr)
        env.resume_boinc()

    complete_time = datetime.utcnow()
    print('Finish Time: ' + complete_time.strftime('%c'), file=env.sum_file_ptr)
    print('BenchMT run complete. Results location: {}'.format(env.prm.summary_path))
    print('')

    # close files
    env.sum_file_ptr.close()
    env.psv_file_ptr.close()

    # Remove lockfile
    if os.path.isfile(env.prm.lockfile):
        os.remove(env.prm.lockfile)


if __name__ == '__main__':
    main()
