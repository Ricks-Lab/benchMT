#!/usr/bin/env python3
"""benchMT  -  SETI multi-threaded MB Benchmark Tool

 This tool will extract the total number of CPU cores/threads and GPU platforms from the user's
 environment and utilize them in running a list of apps/args specified in the benchCFG file.  Using
 less than total number of CPU threads can be specified in the command line.  This tool will read a
 list of MB apps/args from the benchCFG file and search for the specified MB apps in the APP_CPU
 and APP_GPU directories to validate and determine platform.  It will then leverage available
 threads, as specified, to run all benchmark jobs storing results in the testData directory.  Use
 the --help option to get a description of valid command line arguments.

 By default, a summary list of all jobs will update in the display as the program progresses.  If
 there are a large number of jobs, then this display may not be useful and the --display_slots
 option can be used to display the status of each slot as the program progresses.  In some cases,
 there will be too many slots to display, and the --display_compact option can used to further
 optimize the progress display.

 You may need to use the --boinc_home command option to specify the boinc home directory, which
 is required, since boinccmd is used.

 All WUs in the WU_test directory will be used in the creation of jobs to be run, unless the 
 --std_signals option is used, in which case, WUs in the WU_std_signal will be used.  The
 APPS_GPU and APPS_CPU can have more apps than are specified to run in the BenchCFG file, but must
 contain apps specified in BenchCFG.  The APPS_REF must contain a single CPU reference app with a
 file prefix of "ref-cpu.".  The stock CPU app is suggested, as this is only used to test
 integrity of the results.  Elapsed time analysis is expected to be limited to apps/arg
 combinations specified in BenchCFG.

 The results will be stored in a unique subdir of the testData directory. There is an overall run
 log txt file, a .psv file useful for importing into an analytics tools, and the .sah and stderr
 files for each job run. A run name can be specified with the --run_name commane line option.  
 This name will be included in the name of the testData subdirectory for the current run.


    Copyright (C) 2018  RueiKe

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""
__author__ = "RueiKe"
__copyright__ = "Copyright (C) 2018 RueiKe"
__credits__ = "Testing: Keith Myers"
__license__ = "GNU General Public License"
__program_name__ = "benchMT"
__version__ = "v1.3.0"
__maintainer__ = "RueiKe"
__status__ = "Under Development"

import argparse
import re
import subprocess
import shlex
import socket
import os
import platform
import sys
import time
from datetime import datetime
from uuid import uuid4
import glob 
import shutil 


class MB_CONST:
    def __init__(self):
        self.boinc_home = "/home/boinc/BOINC/"
        self.cpu_app_subdir = "APPS_CPU/"
        self.gpu_app_subdir = "APPS_GPU/"
        self.ref_app_subdir = "APPS_REF/"
        self.ref_results_subdir = "REF_RESULTS/"
        self.wu_subdir = "WU_test/"
        self.std_signal_subdir = "WU_std_signal/"
        self.testdata_subdir = "testData/"
        self.workdir_subdir = "workdir/"
        self.slots_subdir = "Slots/"
        self.command_line_filename = "BenchCFG"
        self.boinccmd = "boinccmd"
        self.wu_cmp = "rescmpv5_l"
        self.suspend_args = ["boinccmd --set_gpu_mode never 172800", "boinccmd --set_run_mode never 172800"]
        self.resume_args = ["boinccmd --set_gpu_mode never 1", "boinccmd --set_run_mode never 1"]
        self.activeWU = "work_unit.sah"
        self.DEBUG = False
mb_const=MB_CONST()

class CFG_MODES:
    def __init__(self):
        self.modes = {
                "yes" : None,
                "run_name" : None,
                "boinc_home" : None,
                "noBS" : None,
                "display_compact" : None,
                "display_slots" : None,
                "num_repetitions" : None,
                "max_threads" : None,
                "max_gpus" : None,
                "gpu_devices" : None,
                "std_signals" : None,
                }
        self.type = {
                "yes" : "Logical",
                "run_name" : "String",
                "boinc_home" : "String",
                "noBS" : "Logical",
                "display_compact" : "Logical",
                "display_slots" : "Logical",
                "num_repetitions" : "Numeric",
                "max_threads" : "Numeric",
                "max_gpus" : "Numeric",
                "gpu_devices" : "String",
                "std_signals" : "Logical",
                }

    def set_mode(self, mode_name, mode_value):
        if mode_name in self.modes.keys() == False:
            return False

        if self.type[mode_name] == "Logical":
            if mode_value == "True":
                self.modes[mode_name] = True
                return True
            elif mode_value == "False":
                self.modes[mode_name] = False
                return True
            return False
        elif self.type[mode_name] == "Numeric":
            if re.fullmatch('[-]*[0-9]+', mode_value):
                self.modes[mode_name] = int(mode_value)
                return True
            else:
                return False
        elif self.type[mode_name] == "String":
            self.modes[mode_name] = mode_value
        else:
            return False

    def mode_value(self, mode_name):
        if mode_name in self.modes.keys() == False:
            return False
        return(self.modes[mode_name])


class BENCH_ENV:
    def __init__(self):
        self.time_now = ""
        self.time_now_short = ""
        self.hostname = ""
        self.platform = ""
        self.os_desc = ""
        self.cpu_model = ""
        self.cpu_mhz = ""
        self.total_cpu_threads = 0
        self.total_cpu_cores = 0
        self.total_gpu_threads = 0               # TODO currently total_gpu_threads = total_gpu_count, both needed for GPU SMT
        self.total_gpu_count = 0
        self.allocated_cthreads = 0
        self.allocated_gthreads = 0
        self.gpu_devices = []
        self.gpu_str = ""
        self.current_dir = ""
        self.cpu_app_path = ""
        self.gpu_app_path = ""
        self.ref_app_path = ""
        self.ref_results_path = ""
        self.wu_path = ""
        self.wu_std_signal_path = ""
        self.testdata_path = ""
        self.slots_path = ""
        self.command_line_file = ""
        self.boinc_home = ""
        self.boinccmd = ""
        self.wucmpcmd = ""
        self.repetitions = 1
        self.summary_path = ""
        self.run_name = ""
        self.summary_file = ""
        self.sum_file_ptr = None
        self.psv_file = ""
        self.psv_file_ptr = None
        self.workdir_path = ""
        self.lockfile = ""
        self.mode_std_signals = False
        self.mode_display_slots = False
        self.mode_display_compact = False
        self.mode_no_ref = False


    def set_env(self):
        """ Setup the working environment to run benchmarks
                - Get time and system parameters
                - Use standard subdirectory and filenames in the mb_const class
                - Verify all required direcories and files exist
            Retrun (logical) True if all files and directories exist, else False
        """
        valid = True
        t = datetime.utcnow()
        self.time_now = t.strftime('%c')
        self.time_now_short = t.strftime('%m%d_%H%M%S')
        self.hostname = socket.gethostname()
        self.platform = platform.system() + " " + platform.release()

        # Get OS details
        if shutil.which("lsb_release") == None:
            print("OS Command [lsb_release] not found")
            valid = False
        else:
            cmd = subprocess.Popen('lsb_release -a 2>/dev/null', shell=True, stdout=subprocess.PIPE)
            for line in cmd.stdout:
                linestr = line.decode("utf-8").strip()
                searchObj = re.search('Description', linestr)
                if(searchObj != None):
                    lineItem = linestr.split(':')
                    self.os_desc = lineItem[1].strip()
                    cmd.stdout.close()
                    break

        # Get CPU details
        if shutil.which("lscpu") == None:
            print("OS Command [lscpu] not found")
            valid = False
        else:
            cpu_max_mhz = ""
            cmd = subprocess.Popen('lscpu 2>/dev/null', shell=True, stdout=subprocess.PIPE)
            for line in cmd.stdout:
                linestr = line.decode("utf-8").strip()
                searchObj = re.search('Model name', linestr)
                if(searchObj != None):
                    lineItem = linestr.split(':')
                    self.cpu_model = lineItem[1].strip()
                    continue
                searchObj = re.search('CPU max MHz', linestr)
                if(searchObj != None):
                    lineItem = linestr.split(':')
                    cpu_max_mhz = lineItem[1].strip()
                    continue
                searchObj = re.search('CPU MHz', linestr)
                if(searchObj != None):
                    lineItem = linestr.split(':')
                    cpu_mhz = lineItem[1].strip()
                    continue
            if cpu_max_mhz == "" :
               self.cpu_mhz = cpu_mhz
            else :
                self.cpu_mhz = cpu_max_mhz
            cmd.stdout.close()

            # Get CPU details
            cmd = subprocess.Popen('lscpu -e 2>/dev/null | tail -1', shell=True, stdout=subprocess.PIPE)
            for line in cmd.stdout:
                linestr = line.decode("utf-8").strip()
                lineItem = linestr.split()
                self.total_cpu_threads = int(lineItem[0].strip()) + 1
                self.total_cpu_cores = int(lineItem[3].strip()) + 1
            cmd.stdout.close()

        # Get GPU details
        #TODO consider using opencl to get valid GPU compute platforms
        if shutil.which("lshw") == None:
            print("OS Command [lshw] not found")
            valid = False
        else:
            gpu_cnt=0
            gpu_str = ""
            cmd = subprocess.Popen('lshw -short 2>/dev/null | grep display', shell=True, stdout=subprocess.PIPE)
            for line in cmd.stdout:
                linestr = line.decode("utf-8").strip()
                searchObj = re.search('display', linestr)
                if(searchObj != None):
                    gpu_cnt += 1
                    lineItem = linestr.split('[')
                    gpu_str = gpu_str + " [" + lineItem[1]
                    continue
            cmd.stdout.close()
            self.total_gpu_count =  gpu_cnt
            self.total_gpu_threads =  gpu_cnt
            for gi in range(0, gpu_cnt):
                self.gpu_devices[len(self.gpu_devices):] = [gi]
            self.gpu_str =  gpu_str

        # Set working directories
        self.current_dir = os.getcwd()
        self.boinc_home = mb_const.boinc_home 
        self.workdir_path = self.current_dir + "/" + mb_const.workdir_subdir
        self.cpu_app_path = self.current_dir + "/" + mb_const.cpu_app_subdir
        self.gpu_app_path = self.current_dir + "/" + mb_const.gpu_app_subdir
        self.ref_app_path = self.current_dir + "/" + mb_const.ref_app_subdir
        self.wu_path = self.current_dir + "/" + mb_const.wu_subdir
        self.wu_std_signal_path = self.current_dir + "/" + mb_const.std_signal_subdir
        self.testdata_path = self.current_dir + "/" + mb_const.testdata_subdir
        self.ref_results_path = self.ref_app_path + "/" + mb_const.ref_results_subdir
        self.slots_path = self.workdir_path + "/" + mb_const.slots_subdir
        self.lockfile = self.workdir_path + "/.benchMTlockfile" 
        self.summary_path = self.testdata_path + "/" + self.hostname + "_benchMT_" + self.run_name + "_" + self.time_now_short
        self.summary_file = self.summary_path + "/" + self.hostname + ".testlog." + self.time_now_short + ".txt"
        self.init_data_template_file = self.workdir_path + "/init_data.xml.template"
        self.psv_file = self.summary_path + "/" + self.hostname + ".timelog." + self.time_now_short + ".psv"

        # Check working directories
        if(os.path.isdir(self.workdir_path) == False): 
            print("benchMT workdir Path [", self.workdir_path,"] doesn't exist, making...")
            os.mkdir(self.workdir_path)
            if(os.path.isdir(self.workdir_path) == False):
                print("Failed to make benchMT workdir Path [", self.workdir_path,"]")
                valid = False
        if(os.path.isdir(self.testdata_path) == False): 
            print("TestData Path [", self.testdata_path,"] doesn't exist, making...")
            os.mkdir(self.testdata_path)
            if(os.path.isdir(self.testdata_path) == False):
                print("Failed to make TestData Path [", self.testdata_path,"]")
                valid = False
        if(os.path.isdir(self.cpu_app_path) == False): 
            print("CPU APP Path [", self.cpu_app_path,"] doesn't exist")
            valid = False
        if(os.path.isdir(self.ref_app_path) == False): 
            print("REFERENCE APP Path [", self.ref_app_path,"] doesn't exist")
            valid = False
        if(os.path.isdir(self.ref_results_path) == False): 
            print("REFERENCE RESULTS Path [", self.ref_results_path,"] doesn't exist")
            valid = False
        if(os.path.isdir(self.gpu_app_path) == False): 
            print("GPU APP Path [", self.gpu_app_path,"] doesn't exist")
            valid = False
        if(os.path.isdir(self.wu_path) == False): 
            print("WU Path [", self.wu_path,"] doesn't exist")
            valid = False
        if(os.path.isdir(self.wu_std_signal_path) == False): 
            print("STD SIGNAL WU Path [", self.wu_std_signal_path,"] doesn't exist")
            valid = False
        if(os.path.isdir(self.boinc_home) == False): 
            print("BOINC Home Path [", self.boinc_home,"] doesn't exist")
            print("Please set the correct BOINC Home Path with the --boinc_home command line option")
            valid = False

        # Set file locations
        self.command_line_file = self.current_dir + "/" + mb_const.command_line_filename
        if(os.path.isfile(self.command_line_file) == False): 
            print("BenchCFG [", self.command_line_file,"] doesn't exist")
            valid = False
        self.wucmpcmd = self.current_dir + "/" + mb_const.wu_cmp
        if(os.path.isfile(self.wucmpcmd) == False): 
            print("Results Compare Utility [", self.wucmpcmd,"] doesn't exist")
            valid = False
        self.boinccmd = self.boinc_home + "/" + mb_const.boinccmd
        if(os.path.isfile(self.boinccmd) == False): 
            print("boinccmd [", self.boinccmd,"] doesn't exist")
            valid = False
        if(os.path.isfile(self.init_data_template_file) == False): 
            print("init_data.xml_template file [", self.init_data_template_file,"] doesn't exist, creating...")
            fileptr = open(self.init_data_template_file, 'w')
            print("<app_init_data>", file=fileptr)
            print("<app_name>setiathome_v8</app_name>", file=fileptr)
            print("<project_dir>" + self.workdir_path + "</project_dir>", file=fileptr)
            print("<boinc_dir>" + self.boinc_home + "</boinc_dir>", file=fileptr)
            print("</app_init_data>", file=fileptr)
            fileptr.close()
        return(valid)

    def makedirs(self):
        """ Check existence of required directories and make if missing
            Return (void) 
        """
        # Check/Make working directories
        if(os.path.isdir(self.cpu_app_path) == False): 
            print("CPU APP Path [", self.cpu_app_path,"] doesn't exist, making...")
            os.mkdir(self.cpu_app_path)
        if(os.path.isdir(self.gpu_app_path) == False): 
            print("GPU APP Path [", self.gpu_app_path,"] doesn't exist, making...")
            os.mkdir(self.gpu_app_path)
        if(os.path.isdir(self.ref_app_path) == False): 
            print("REFERENCE APP Path [", self.ref_app_path,"] doesn't exist, making...")
            os.mkdir(self.ref_app_path)
        if(os.path.isdir(self.ref_results_path) == False): 
            print("REFERENCE RESULTS Path [", self.ref_results_path,"] doesn't exist, making...")
            os.mkdir(self.ref_results_path)
        if(os.path.isdir(self.wu_path) == False): 
            print("WU Path [", self.wu_path,"] doesn't exist, making...")
            os.mkdir(self.wu_path)
        if(os.path.isdir(self.wu_std_signal_path) == False): 
            print("STD SIGNAL WU Path [", self.wu_std_signal_path,"] doesn't exist, making...")
            os.mkdir(self.wu_std_signal_path)
        if(os.path.isdir(self.testdata_path) == False): 
            print("TestData Path [", self.testdata_path,"] doesn't exist, making...")
            os.mkdir(self.testdata_path)

    def is_bench_conflict(self):
        """return true if there is another instance running.  Check lock file for pid
        if there is a valid process with that pid, then there is a conflict.

        if no conflict, then write current pid to lockfile and return false"""
        mypid = os.getpid()
        if(os.path.isfile(self.lockfile) == False): 
            # no lockfile, so assume no conflict
            file_ptr = open(self.lockfile, 'w')
            print(str(mypid), file=file_ptr)
            file_ptr.close()
            return(False)
        else:
            file_ptr = open(self.lockfile, 'r')
            line = file_ptr.readline().strip()
            file_ptr.close()
            if line.isdigit():
                pid = int(line)
                try:
                    os.kill(pid, 0)
                except OSError:
                    #not running
                    file_ptr = open(self.lockfile, 'w')
                    print(str(mypid), file=file_ptr)
                    file_ptr.close()
                    return(False)
                else:
                    #running
                    return(True)


    def is_boinc_running(self):
        cmd = subprocess.Popen('ps -C boinc -o pid 2>/dev/null', shell=True, stdout=subprocess.PIPE)
        output = cmd.stdout.read()
        cmd.stdout.close()
        cmd.wait()
        if output.decode("utf-8").strip() == 'PID':
            return(False)
        else:
            return(True)

    def suspend_boinc(self):
        if self.is_boinc_running() == False:
            print("boinc is not running, skip suspend")
            return
        cwd = os.getcwd()
        os.chdir(mb_const.boinc_home)
        for cmd_str in mb_const.suspend_args:
            cmd_str = mb_const.boinc_home + str(cmd_str)
            #cmd_str_lst = cmd_str.split(sep=' ', maxsplit=1)
            if mb_const.DEBUG == True: print("Suspend cmd: ", cmd_str)
            cmd = subprocess.Popen(cmd_str, shell=True, stdout=subprocess.PIPE)
            while True:
                if cmd.poll() != None:
                    break
                time.sleep(1)
        os.chdir(cwd)

    def resume_boinc(self):
        if self.is_boinc_running() == False:
            print("boinc is not running, skip resume")
            return
        cwd = os.getcwd()
        os.chdir(mb_const.boinc_home)
        for cmd_str in mb_const.resume_args:
            cmd_str = mb_const.boinc_home + str(cmd_str)
            #cmd_str_lst = cmd_str.split(sep=' ', maxsplit=1)
            if mb_const.DEBUG == True: print("Resume cmd: ", cmd_str)
            cmd = subprocess.Popen(cmd_str, shell=True, stdout=subprocess.PIPE)
            while True:
                if cmd.poll() != None:
                    break
                time.sleep(1)
        os.chdir(cwd)
        
    def print(self, fileptr=sys.stdout):
        """ Print all evironment Details
            Return (void) 
        """
        print("Hostname: ", self.hostname, file=fileptr)
        print("Run Name: ", self.run_name, file=fileptr)
        print("Platform: ", self.platform, file=fileptr)
        print("OS Description: ", self.os_desc, file=fileptr)
        print("CPU Model: ", self.cpu_model, file=fileptr)
        print("CPU MHz: ", self.cpu_mhz, file=fileptr)
        print("CPU Cores: ", self.total_cpu_cores, file=fileptr)
        print("CPU Threads: ", self.total_cpu_threads, file=fileptr)
        print("GPU Count: ", self.total_gpu_count, file=fileptr)
        print("GPU Threads: ", self.total_gpu_threads, file=fileptr)
        print("GPU Devices: ", str(self.gpu_devices), file=fileptr)
        print("GPU Details: ", self.gpu_str, file=fileptr)
        print("Current Dir: ", self.current_dir, file=fileptr)
        print("Slots Dir: ", self.slots_path, file=fileptr)
        print("TimeNow: ", self.time_now, file=fileptr)
        print("TimeNowShort: ", self.time_now_short, file=fileptr)
        print("CPU App Path: ", self.cpu_app_path, file=fileptr)
        print("GPU App Path: ", self.gpu_app_path, file=fileptr)
        print("REF App Path: ", self.ref_app_path, file=fileptr)
        print("Reference Results Path: ", self.ref_results_path, file=fileptr)
        print("STD Signal WU Path: ", self.wu_std_signal_path, file=fileptr)
        print("WU Path: ", self.wu_path, file=fileptr)
        print("Test Data Path: ", self.testdata_path, file=fileptr)
        print("BOINC Home: ", mb_const.boinc_home, file=fileptr)
        print("Repetitions: ", self.repetitions, file=fileptr)
        print("Allocated CPU Threads: ", self.allocated_cthreads, file=fileptr)
        print("Allocated GPU Threads: ", self.allocated_gthreads, file=fileptr)



class BENCH_JOB:
    def __init__(self, item_id):
        self.uuid = item_id
        self.cmd = ""
        self.slot = -1
        self.start_time = "not started"
        self.complete_time = "not started"
        self.exit_status = ""
        self.state = "PENDING"              #PENDING, ACTIVE, COMPLETE
        self.app_name = ""
        self.app_args = ""
        self.platform = "UNKNOWN"           #UNKNOWN, CPU, GPU
        self.wu_name = "not assigned"
        self.wu_path = "not assigned"
        self.error = ""
        self.slot_dir = ""
        self.similarity = "UNKNOWN"
        self.q_value = "UNKNOWN"
        self.angle_range = 0.0
        self.cnt_spike = 0
        self.cnt_autocorr = 0
        self.cnt_pulse = 0
        self.cnt_triplet = 0
        self.cnt_gaussian = 0

    def copy(self, src):
        # Don't copy uuid self.uuid = item_id src.uuid
        self.cmd = src.cmd 
        self.start_time = src.start_time 
        self.complete_time = src.complete_time
        self.exit_status = src.exit_status
        self.state = src.state
        self.app_name = src.app_name
        self.app_args = src.app_args
        self.platform = src.platform
        self.wu_name = src.wu_name
        self.wu_path = src.wu_path
        self.error = src.error
        self.slot_dir = src.slot_dir
        self.similarity = src.similarity
        self.q_value = src.q_value
        self.angle_range = src.angle_range
        self.cnt_spike = src.cnt_spike
        self.cnt_autocorr = src.cnt_autocorr
        self.cnt_pulse = src.cnt_pulse
        self.cnt_triplet = src.cnt_triplet
        self.cnt_gaussian = src.cnt_gaussian

class JOB_LIST:
    def __init__(self):
        self.list = {}

    def read_benchcfg(self, env, modes):
        """ read the default benchCFG file or one specified by user on command line.  Extract 
        modes, app_names and app_args"""
        clfptr = open(env.command_line_file, 'r')
        for line in clfptr:
            line = line.strip()
            if len(line) == 0 : continue
            if line[0] == '#': continue
            if len(line) <2 : continue
            lineitems = line.split(sep=' ', maxsplit=1)
            #check if entry is a mode item
            if lineitems[0] == "mode":
                modeitems = lineitems[1].split(sep=' ', maxsplit=2)
                if len(modeitems) < 2 :
                    continue
                #process mode
                mode_name = modeitems[0].strip()
                mode_value = modeitems[1].strip()
                if modes.set_mode(mode_name, mode_value) == False:
                    print("Invalid mode specified in CFG file: [", mode_name, "][", mode_value, "]", sep='')
                else:
                    print("Read valid mode from CFG file: [", mode_name, "][", mode_value, "]", sep='')
                continue

            #process appname and apparg
            job = BENCH_JOB(uuid4().hex)
            job.app_name = lineitems[0]
            if len(lineitems) > 1:
                argstr = lineitems[1]
                searchObj = re.search(r'[-]+[dD]evice\s+[0-9]+', argstr)
                if(searchObj != None):
                    argstr = re.sub(r'[-]+[dD]evice\s+[0-9]+', '', argstr)
                    print(lineitems[1])
                    print("Removed [-device X] argument as conflicts with slot assignment process")
                    print(argstr)
                job.app_args = argstr
            else:
                job.app_args = ""
            if(os.path.isfile(env.cpu_app_path + job.app_name) == True): 
                job.platform = "CPU"
            elif(os.path.isfile(env.gpu_app_path + job.app_name) == True): 
                job.platform = "GPU"
            else:
                job.platform = "UNKNOWN"
            self.list[job.uuid] = job
        clfptr.close

    def read_wu_list(self, env):
        """Prepare a list of WUs based on the contents of the wu_path or std_signal_path
        depending on command line arguments or CFG mode settings"""
        if env.mode_std_signals == True :
            wu_path=env.wu_std_signal_path
        else :
            wu_path=env.wu_path
        filelist = os.listdir(path=wu_path)
        for line in filelist:
            line = line.strip()
            #print(line)
            if line.endswith('.wu') == True :
                job = BENCH_JOB(uuid4().hex)
                job.wu_name = line
                job.wu_path = wu_path
                self.list[job.uuid] = job

    def create_ref_list(self, ref_app, wulist, env):
        """create a reference job entry for every WU found using the specified 
        ref_app.  Set state to pending"""
        for wu_key, wu_value in wulist.list.items() :
            job = BENCH_JOB(uuid4().hex)
            job.copy(ref_app)
            job.platform = "REF"
            job.state = "PENDING"
            job.wu_name = wu_value.wu_name
            job.wu_path = wu_value.wu_path
            self.list[job.uuid] = job

    def check_ref_results(self, env):
        """check if ref_file exist for each ref_job in the list. 
           If it exists, change status from PENDING to COMPLETE """
        for k, v in self.list.items() :
            ref_app_name = v.app_name.replace('ref-cpu.','')
            ref_file_name = env.ref_results_path + "ref-result." + ref_app_name + "." + v.wu_name + ".sah"
            if(os.path.isfile(ref_file_name) == True): 
                v.state = "COMPLETE"
                v.start_time = "NA"
                v.complete_time = "NA"

    def create_job_list(self, applist, wulist, env):
        """ based on a list of apps and a list of WUs, create an job list which uses every app
        to run every WU"""
        for i in range(0, env.repetitions):
            for wu_key, wu_value in wulist.list.items() :
                for app_key, app_value in applist.list.items() :
                    if app_value.platform != "UNKNOWN" :
                        job = BENCH_JOB(uuid4().hex)
                        job.copy(app_value)
                        job.state = "PENDING"
                        job.wu_name = wu_value.wu_name
                        job.wu_path = wu_value.wu_path
                        self.list[job.uuid] = job

    def append_job_list(self, newlist):
        """ append jobs in newlist to self, but check if jobs are already in self """
        for nl_key, nl_value in newlist.list.items() :
            if nl_key in self.list.keys():
                #SKIP if new Job is already in the list
                continue
            else:
                self.list[nl_value.uuid] = nl_value

    def print(self, compact_flag=False, show_skipped=False, fileptr=sys.stdout, title=""):
        i = 0
        #Print is optimized for 112 columns
        num_jobs = self.jobcount_bystatus()
        if title == "":
            print("\n   " + str(num_jobs["COMPLETE"]) + " of " + str(num_jobs["TOTAL"]) + " jobs complete\n", file=fileptr)
        else:
            print("\n   " + title)
        print("┌─".ljust(5,'─'), "─".ljust(4,'─'), "─".ljust(3,'─'),  "─".ljust(60,'─'),
                "─".ljust(8,'─'),  "─".ljust(8,'─'), "─".ljust(11,'─'),
                "─".ljust(8,'─') + "┐", file=fileptr, sep="┬")

        if fileptr == sys.stdout:
            print("│" + '\x1b[1;36m'+ "Job#".ljust(4,' ') +'\x1b[0m',
                    '\x1b[1;36m'+ "Slot".ljust(4,' ') +'\x1b[0m',
                    '\x1b[1;36m'+ "xPU".ljust(3,' ') +'\x1b[0m',
                    '\x1b[1;36m'+ "app_name".ljust(60,' ') +'\x1b[0m',
                    '\x1b[1;36m'+ "  start".ljust(8,' ') +'\x1b[0m',
                    '\x1b[1;36m'+ " finish".ljust(8,' ') +'\x1b[0m',
                    '\x1b[1;36m'+ "tot_time".ljust(11,' ') +'\x1b[0m',
                    '\x1b[1;36m'+ " state".ljust(8,' ') +'\x1b[0m' + "│", file=fileptr, sep="│")
            print("│"+ '\x1b[1;36m'+ " ".ljust(4,' ') +'\x1b[0m',
                    '\x1b[1;36m'+ " ".ljust(4,' ') +'\x1b[0m',
                    '\x1b[1;36m'+ " ".ljust(3,' ') +'\x1b[0m',
                    '\x1b[1;36m'+ "app_args".ljust(60,' ') +'\x1b[0m',
                    '\x1b[1;36m'+ "wu_name".ljust(38,' ') +'\x1b[0m' + "│", file=fileptr, sep="│")
        else:
            print("│Job#".ljust(5,' '), "Slot".ljust(4,' '), "xPU".ljust(3,' '), "app_name".ljust(60,' '),
                    "  start".ljust(8,' '), " finish".ljust(8,' '), "tot_time".ljust(11,' '),
                    " state".ljust(8,' ') + "│", file=fileptr, sep="│")
            print("│".ljust(5,' '), " ".ljust(4,' '), " ".ljust(3,' '), "app_args".ljust(60,' '),
                    "wu_name".ljust(38,' ') + "│", file=fileptr, sep="│")

        for k, v in self.list.items() :
            if v.slot == -1:
                slot_str =  " NA"
            else:
                slot_str =  " " + str(v.slot)

            if (v.state == "ACTIVE" or v.state == "COMPLETE") and v.start_time != "NA" :
                start_time_str = v.start_time.strftime('%H:%M:%S')
            elif v.start_time == "NA":
                start_time_str = "SKIPPED"
                if show_skipped == False: continue
            else :
                start_time_str = "  NA  "

            if v.state == "COMPLETE" and v.start_time != "NA" :
                complete_time_str = v.complete_time.strftime('%H:%M:%S')
                elapsed_time = v.complete_time - v.start_time
            elif v.start_time == "NA" :
                complete_time_str = "SKIPPED"
                elapsed_time = "SKIPPED"
                if show_skipped == False: continue
            else :
                complete_time_str = "  NA  "
                elapsed_time = "  NA  "

            #if printing to stdout, use state colors
            if fileptr == sys.stdout:
                if v.state == "ACTIVE":
                    #Blue
                    state_str = '\x1b[1;37;44m' + v.state.ljust(8,' ')[:8] + '\x1b[0m'
                elif v.state == "PENDING":
                    #Yellow
                    state_str = '\x1b[1;30;43m' + v.state.ljust(8,' ')[:8] + '\x1b[0m'
                elif v.state == "COMPLETE":
                    #Green
                    state_str = '\x1b[1;30;42m' + v.state.ljust(8,' ')[:8] + '\x1b[0m'
            else:
                state_str = v.state.ljust(8,' ')[:8]

            if compact_flag == False:
                print("├─".ljust(5,'─'), "─".ljust(4,'─'), "─".ljust(3,'─'), "─".ljust(60,'─'),
                    "─".ljust(8,'─') +"┬"+ "─".ljust(8,'─') +"┬"+ "─".ljust(11,'─') +"┬"+ "─".ljust(8,'─') + "┤",
                    file=fileptr, sep="┼")
            print("│"+str(i).ljust(4,' '), slot_str.ljust(4,' '), v.platform.ljust(3,' ')[:3], v.app_name.ljust(60,' ')[:60],
                    start_time_str.ljust(8,' '), complete_time_str.ljust(8,' '), str(elapsed_time).ljust(11,' ')[:11],
                    state_str  + "│", file=fileptr, sep="│")
            print("│"+" ".ljust(4,' '), " ".ljust(4,' '), " ".ljust(3,' ')[:3], v.app_args.ljust(60,' ')[:60],
                    v.wu_name.ljust(38,' ')[:38] + "│", file=fileptr, sep="│")
            i += 1

        print("└─".ljust(5,'─'), "─".ljust(4,'─'), "─".ljust(3,'─'),  "─".ljust(60,'─'),
                "─".ljust(8,'─') +"─"+  "─".ljust(8,'─') +"─"+ "─".ljust(11,'─') +"─"+
                "─".ljust(8,'─') + "┘", file=fileptr, sep="┴")

    def print_app_names(self, fileptr=sys.stdout):
        for k, v in self.list.items() :
            print(v.app_name, file=fileptr)

    def print_wu_names(self, fileptr=sys.stdout):
        for k, v in self.list.items() :
            print(v.wu_name, file=fileptr)

    def psv_print(self, env, fileptr=sys.stdout):
        print("Host", "CPU","CPU-MHz", "JobID", "Platform", "app_name", "app_args", "wu_name", "angle_range",
                "spike_cnt", "autocorr_cnt", "pulse_cnt", "triplet_cnt", "gaussian_cnt", "start_time", "complete_time",
                "elapsed_time", "state", "Q", "similarity", "error", file=fileptr, sep="|")
        for k, v in self.list.items() :
            if (v.state == "ACTIVE" or v.state == "COMPLETE") and v.start_time != "NA" :
                start_time_str = v.start_time.strftime('%H:%M:%S')
            else :
                start_time_str = "SKIPPED"
                #don't output skipped items to the psv file
                continue
            if v.state == "COMPLETE" and v.start_time != "NA" :
                complete_time_str = v.complete_time.strftime('%H:%M:%S')
                elapsed_time = v.complete_time - v.start_time
            else :
                complete_time_str = "SKIPPED"
                elapsed_time = "SKIPPED"
            if v.error == "":
                error_str = "None"
            else:
                error_str = v.error
            print(env.hostname, env.cpu_model, env.cpu_mhz, v.uuid, v.platform, v.app_name, v.app_args,
                    v.wu_name, v.angle_range, v.cnt_spike, v.cnt_autocorr, v.cnt_pulse, v.cnt_triplet,
                    v.cnt_gaussian, start_time_str, complete_time_str, elapsed_time, v.state,
                    v.q_value, v.similarity, error_str, file=fileptr, sep="|")

    def jobcount_bystatus(self):
        num_pending_jobs = {"PENDING":0, "COMPLETE":0, "ACTIVE":0, "TOTAL":0}
        for k, v in self.list.items() :
            num_pending_jobs[v.state] += 1
            num_pending_jobs["TOTAL"] += 1
        return(num_pending_jobs)

    def pending_pjobs(self):
        num_pending_jobs = {"GPU": 0, "CPU": 0, "REF":0}
        for k, v in self.list.items() :
            if v.state == "PENDING":
                num_pending_jobs[v.platform] += 1
        return(num_pending_jobs)

    def pending_jobs(self):
        num_pending_jobs = 0
        for k, v in self.list.items() :
            if v.state == "PENDING":
                num_pending_jobs += 1
        return(num_pending_jobs)

    def all_complete(self, platform=""):
        for k, v in self.list.items() :
            if platform != "":
                if v.platform != platform:
                    continue
            if v.state != "COMPLETE" :
                return(False)
        return(True)

    def num_cpu_jobs(self):
        cnt = 0
        for k, v in self.list.items() :
            if v.platform == "CPU" or v.platform == "REF":
                cnt += 1
        return(cnt)

    def num_gpu_jobs(self):
        cnt = 0
        for k, v in self.list.items() :
            if v.platform == "GPU":
                cnt += 1
        return(cnt)

    def count_pending_pjobs(self, platform_list=["CPU", "GPU"]):
        num_pending_jobs = 0
        for plat in platform_list:
            num_pending_jobs += self.pending_pjobs()[plat]
        return(num_pending_jobs)

    def request_job(self, platform):
        for k, v in self.list.items() :
            if v.state == "PENDING" and v.platform == platform:
                return(v.uuid)
        return(-1)

    def wait_for_complete_job(self, env) :
        while True :
            time.sleep(3)
            for k, v in self.list.items() :
                if v.state == "ACTIVE" :
                    es = v.cmd.poll()
                    if es != None:
                        v.complete_time = datetime.utcnow()
                        v.state = "COMPLETE"
                        v.exit_status = es

                        if v.platform != "REF" :
                            #find ref-result file
                            file_srch = glob.glob(env.ref_results_path + "/ref-result." + "*." + v.wu_name + ".sah")
                            if len(file_srch) > 0:
                                ref_result_file = glob.glob(env.ref_results_path + "/ref-result." + "*." + v.wu_name + ".sah")[0]
                            else:
                                ref_result_file = ""
                                v.error = v.error + "[Can not open ref-result file]"
                            #copy result and stderr files to testData
                            cur_result_file = env.summary_path + "/result." + v.app_name + "." + v.wu_name + "." + v.uuid + ".sah"
                            if(os.path.isfile(v.slot_dir + "/result.sah") == True): 
                                shutil.copy2(v.slot_dir + "/result.sah", cur_result_file)
                                os.remove(v.slot_dir + "/result.sah")
                                if mb_const.DEBUG == True: print("Copy2: " + v.slot_dir + "/results.sah", cur_result_file)
                            else:
                                v.error = v.error + "[No results.sah file]"
                            cur_stderr_file = env.summary_path + "/stderr." + v.app_name + "." + v.wu_name + "." + v.uuid  + ".txt"
                            if(os.path.isfile(v.slot_dir + "/stderr.txt") == True): 
                                shutil.copy2(v.slot_dir + "/stderr.txt", cur_stderr_file)
                                os.remove(v.slot_dir + "/stderr.txt")
                                if mb_const.DEBUG == True: print("Copy2: " + v.slot_dir + "/stderr.txt", cur_stderr_file)
                            else:
                                v.error = v.error + "[No stderr.txt file]"

                            # Get parameters like AR and signal counts from results file
                            v.cnt_spike = 0
                            v.cnt_autocorr = 0
                            v.cnt_pulse = 0
                            v.cnt_triplet = 0
                            v.cnt_gaussian = 0

                            if(os.path.isfile(cur_result_file) == True): 
                                resfptr = open(cur_result_file, 'r')
                                for line in resfptr:
                                    linestr = line.strip()
                                    if len(linestr) == 0 : continue
                                    if linestr[0] == '#': continue
                                    if len(linestr) <2 : continue
                                    if v.angle_range == 0:
                                        searchObj = re.search('true_angle_range', linestr)
                                        if(searchObj != None):
                                            lineItem = linestr.split('true_angle_range')
                                            ar_str = re.sub(r'[^\d.]', '', lineItem[1])
                                            print("Angle Range: ["+ar_str + "]")
                                            v.angle_range = float(ar_str)
                                            continue
                                    searchObj = re.search(r'<spike>', linestr)
                                    if(searchObj != None):
                                        v.cnt_spike += 1
                                        continue
                                    searchObj = re.search(r'<autocorr>', linestr)
                                    if(searchObj != None):
                                        v.cnt_autocorr += 1
                                        continue
                                    searchObj = re.search(r'<pulse>', linestr)
                                    if(searchObj != None):
                                        v.cnt_pulse += 1
                                        continue
                                    searchObj = re.search(r'<triplet>', linestr)
                                    if(searchObj != None):
                                        v.cnt_triplet += 1
                                        continue
                                    searchObj = re.search(r'<gaussian>', linestr)
                                    if(searchObj != None):
                                        v.cnt_gaussian += 1
                                        continue
                                resfptr.close()

                                # write to run log
                                print("=".ljust(80, "="), file=env.sum_file_ptr)
                                print("App Name: ", v.app_name, file=env.sum_file_ptr)
                                print("App Args: ", v.app_args, file=env.sum_file_ptr)
                                print("WU Name:  ", v.wu_name, file=env.sum_file_ptr)
                                print("WU Angle Range: ", v.angle_range, file=env.sum_file_ptr)
                                print("Spike count:    ", v.cnt_spike, file=env.sum_file_ptr)
                                print("Autocorr count: ", v.cnt_autocorr, file=env.sum_file_ptr)
                                print("Pulse count:    ", v.cnt_pulse, file=env.sum_file_ptr)
                                print("Triplet count:  ", v.cnt_triplet, file=env.sum_file_ptr)
                                print("Gaussian count: ", v.cnt_gaussian, file=env.sum_file_ptr)
                                print("Results:  ", cur_result_file, file=env.sum_file_ptr)
                                print("REF Name: ", ref_result_file, file=env.sum_file_ptr)
                                print("", file=env.sum_file_ptr)
    
                                if ref_result_file != "":
                                    # compare results to reference
                                    v.similarity = "Unknown"
                                    v.q_value = "Unknown"
                                    command_str = env.wucmpcmd + " " + cur_result_file + " " + ref_result_file + " 2>/dev/null"
                                    if mb_const.DEBUG == True: print("Results compare command: ", command_str)
                                    cmd = subprocess.Popen(command_str, shell=True, stdout=subprocess.PIPE)
                                    for line in cmd.stdout:
                                        linestr = line.decode("utf-8").strip()
                                        print(linestr, file=env.sum_file_ptr)
                                        if mb_const.DEBUG == True: print("Results compare output: ", linestr)
                                        searchObj = re.search('Result', linestr)
                                        if(searchObj != None):
                                            line_str_items = linestr.split(':')
                                            if len(line_str_items) >= 2 :
                                                result_str = line_str_items[1].strip()
                                                result_str_items = result_str.split(',')
                                                v.similarity = result_str_items[0].strip()
                                                v.similarity = v.similarity.replace('.','')
                                                if len(result_str_items) >= 2 :
                                                    q_str_items = result_str_items[1].split('=')
                                                    v.q_value = q_str_items[1].strip()
                                                else : 
                                                    v.q_value = "0.0%"
                                            else :
                                                v.similarity = "ERROR"
                                                v.q_value = "ERROR"
                                    cmd.stdout.close()
                                else:
                                    print("Error: No reference results file.", file=env.sum_file_ptr)
                                print("=".ljust(80, "="), file=env.sum_file_ptr)
                                print("", file=env.sum_file_ptr)
                            else:
                                print("ERROR: can not open results file: ", cur_result_file)
                                # write to run log
                                print("=".ljust(80, "="), file=env.sum_file_ptr)
                                print("ERROR: can not open results file: ", cur_result_file, file=env.sum_file_ptr)
                                print("App Name: ", v.app_name, file=env.sum_file_ptr)
                                print("App Args: ", v.app_args, file=env.sum_file_ptr)
                                print("WU Name:  ", v.wu_name, file=env.sum_file_ptr)
                                print("Results:  ", cur_result_file, file=env.sum_file_ptr)
                                print("REF Name: ", ref_result_file, file=env.sum_file_ptr)
                                print("", file=env.sum_file_ptr)

                        else : #v.platform == REF
                            # Move results file to testData or testData/REF_RESULTS
                            ref_app_name = v.app_name.replace('ref-cpu.','')
                            dest_file = env.ref_results_path + "/ref-result." + ref_app_name + "." + v.wu_name + ".sah"
                            if(os.path.isfile(v.slot_dir + "/result.sah") == True): 
                                shutil.copy2(v.slot_dir + "/result.sah", dest_file)
                                os.remove(v.slot_dir + "/result.sah")
                                if mb_const.DEBUG == True: print("Copy2: " + v.slot_dir + "/results.sah", dest_file)
                            else:
                                print("ERROR: can not open result file: ", v.slot_dir + "/result.sah")
                                v.error = v.error + "[No result.sah file]"
                            dest_file = env.ref_results_path + "/ref-stderr." + ref_app_name + "." + v.wu_name + ".txt"
                            if(os.path.isfile(v.slot_dir + "/stderr.txt") == True): 
                                shutil.copy2(v.slot_dir + "/stderr.txt", dest_file)
                                os.remove(v.slot_dir + "/stderr.txt")
                                if mb_const.DEBUG == True: print("Copy2: " + v.slot_dir + "/stderr.txt", dest_file)
                            else:
                                print("ERROR: can not open stderr file: ", v.slot_dir + "/stderr.txt")
                                v.error = v.error + "[No stderr.txt file]"

                        # Clean slot
                        for filename in ["boinc_finish_called", "boinc_lockfile", "state.sah", "wisdom.sah"] :
                            if(os.path.isfile(v.slot_dir +"/"+ filename) == True): 
                                os.remove(v.slot_dir +"/"+ filename)
                                if mb_const.DEBUG == True: print("Clean slots removed: ", v.slot_dir +"/"+ filename)

                        freed_slot = v.slot
                        v.slot = -1
                        return(freed_slot)

class SLOTS:
    def __init__(self, item_id):
        self.slot_num = item_id
        self.slot_dir = ""
        self.device = -1
        self.platform = ""              #GPU, CPU
        self.job = ""                   #Job uuid
        self.state = "EMPTY"            #EMPTY, ACTIVE

class SLOTS_LIST:
    def __init__(self):
        self.list = {}

    def create_slot_list(self, max_slots):
        self.list = {}
        for i in range(0, max_slots):
            self.list[i] = SLOTS(i)

    def initialize_slots(self, env, num_gpu_slots):
        if(os.path.isdir(env.slots_path) == True):
            shutil.rmtree(env.slots_path)
        os.mkdir(env.slots_path)
        if(os.path.isdir(env.slots_path) == False):
            print("Failed to make Slots directory [", env.slots_path,"]")
            return(False)
        if(num_gpu_slots > 0):
            #copy .cl files to workdir
            for file_str in glob.glob(env.gpu_app_path + "*.cl"):
                shutil.copy2(file_str, env.workdir_path +"/")
        gpu_device_index = 0
        for k, v in self.list.items() :
            v.slot_dir = env.slots_path + str(v.slot_num)
            os.mkdir(v.slot_dir)
            if(os.path.isdir(v.slot_dir) == False):
                print("Failed to make Slots directory [", v.slot_dir,"]")
                return(False)
            #copy init_data.xml from template to slot
            if(os.path.isfile(v.slot_dir + "/init_data.xml") == False): 
                shutil.copy2(env.init_data_template_file, v.slot_dir + "/init_data.xml")
            if(num_gpu_slots > 0):
                v.platform = "GPU"
                v.device = env.gpu_devices[gpu_device_index]
                num_gpu_slots -= 1
                gpu_device_index += 1
            else:
                v.platform = "CPU"
        return(True)

    def all_complete(self, platform=""):
        if platform == "REF": platform = "CPU"
        for k, v in self.list.items() :
            if platform != "":
                if v.platform != platform:
                    continue
            if v.state == "ACTIVE" or v.state == "PENDING":
                return(False)
        return(True)

    def available_pslots(self):
        num_avail_slots = {"GPU": 0, "CPU": 0, "REF": 0}
        for k, v in self.list.items() :
            if v.state == "EMPTY":
                num_avail_slots[v.platform] += 1
        num_avail_slots["REF"] = num_avail_slots["CPU"] 
        return(num_avail_slots)

    def available_slots(self):
        num_avail_slots = 0
        for k, v in self.list.items() :
            if v.state == "EMPTY":
                num_avail_slots += 1
        return(num_avail_slots)

    def assign_job(self, jobs, slot_ID, job_ID):
        self.list[slot_ID].state =  "ACTIVE"
        self.list[slot_ID].job =jobs.list[job_ID] 
        jobs.list[job_ID].state = "ACTIVE"
        jobs.list[job_ID].slot = slot_ID
        jobs.list[job_ID].slot_dir = self.list[slot_ID].slot_dir

    def request_slot(self, platform):
        if platform == "REF": platform = "CPU"
        for k, v in self.list.items() :
            if v.state == "EMPTY" and v.platform == platform:
                return(v.slot_num)
        return(-1)

    def free_slot(self, slot_ID):
        self.list[slot_ID].state = "EMPTY"
        self.list[slot_ID].job = ""

    def print(self, title=""):
        i = 0
        if title == "":
            print("Slot list:")
        else:
            print(title)

        print("SlotNum", "platform", "device", "state", "job", "SlotDir", sep=" | ")
        for k, v in self.list.items() :
            slotnum_str = "-" + str(v.slot_num)
            slotnum_str = slotnum_str.ljust(8, '-')
            plat_str = " " + v.platform
            plat_str = plat_str.ljust(8, ' ')
            if v.device < 0 :
                dev_str = " NA"
            else:
                dev_str = " " + str(v.device)
            dev_str = dev_str.ljust(7, ' ')
            state_str = v.state
            state_str = state_str.ljust(6, ' ')
            if v.job == "": 
                job_str = "None"
            else:
                job_str = v.job.uuid
            print( slotnum_str,"|  ", plat_str, "| ", dev_str, "| ", state_str, "| ", job_str, "| ", v.slot_dir, sep="")
            i += 1

        print("##### ",i, " total slots")

    def print_activity(self, joblist, compact_flag=False, fileptr=sys.stdout):
        #num_jobs = {"PENDING":0, "COMPLETE":0, "ACTIVE":0, "TOTAL":0}
        #Print is optimized for 112 columns
        num_jobs = joblist.jobcount_bystatus()
        print("\n   " + str(num_jobs["COMPLETE"]) + " of " + str(num_jobs["TOTAL"]) + " jobs complete\n", file=fileptr)
        print("┌─".ljust(5,'─'), "─".ljust(3,'─'), "─".ljust(3,'─'),  "─".ljust(40,'─'), "─".ljust(30,'─'),
                "─".ljust(10,'─'),  "─".ljust(10,'─') + "┐", file=fileptr, sep="┬")

        if fileptr == sys.stdout:
            print("│"+'\x1b[1;36m'+"Slot".ljust(4,' ')+'\x1b[0m',
                    '\x1b[1;36m'+"xPU".ljust(3,' ')+'\x1b[0m',
                    '\x1b[1;36m'+"DEV".ljust(3,' ')+'\x1b[0m',
                    '\x1b[1;36m'+"app_name".ljust(40,' ')+'\x1b[0m',
                    '\x1b[1;36m'+"app_args".ljust(30,' ')+'\x1b[0m',
                    '\x1b[1;36m'+"wu_name".ljust(10,' ')+'\x1b[0m',
                    '\x1b[1;36m'+" state".ljust(10,' ')+'\x1b[0m' + "│", file=fileptr, sep="│")
        else:
            print("│Slot".ljust(5,' '), "xPU".ljust(3,' '), "DEV".ljust(3,' '), "app_name".ljust(40,' '), "app_args".ljust(30,' '),
                "wu_name".ljust(10,' '), " state".ljust(10,' ') + "│", file=fileptr, sep="│")

        for k, v in self.list.items() :
            slotnum_str = " " + str(v.slot_num)
            if v.device < 0 :
                dev_str = " NA"
            else:
                dev_str = " " + str(v.device)
            state_str = v.state
            state_str = state_str.ljust(6, ' ')
            if v.job == "": 
                app_str = "None"
                app_arg_str = "None"
                wu_name_str = "None"
            else:
                app_str = joblist.list[v.job.uuid].app_name
                app_arg_str = joblist.list[v.job.uuid].app_args
                wu_name_str = joblist.list[v.job.uuid].wu_name

            #if printing to stdout, use state colors
            if fileptr == sys.stdout:
                if v.state == "ACTIVE":
                    #Blue
                    state_str = '\x1b[1;37;44m' + ("  "+v.state).ljust(10,' ')[:10] + '\x1b[0m'
                elif v.state == "EMPTY":
                    #Yellow
                    state_str = '\x1b[1;30;43m' + ("  "+v.state).ljust(10,' ')[:10] + '\x1b[0m'
            else:
                state_str = v.state.ljust(10,' ')[:10]

            if compact_flag == False :
                print("├─".ljust(5,'─'), "─".ljust(3,'─'), "─".ljust(3,'─'), "─".ljust(40,'─'), "─".ljust(30,'─'),
                    "─".ljust(10,'─'), "─".ljust(10,'─') + "┤", file=fileptr, sep="┼")
            print("│" + slotnum_str.ljust(4,' '), v.platform.ljust(3,' ')[:3], dev_str.ljust(3,' '), app_str.ljust(40,' ')[:40],
                    app_arg_str.ljust(30,' ')[:30], wu_name_str.ljust(10,' ')[:10], state_str + "│", file=fileptr, sep="│")

        print("└─".ljust(5,'─'), "─".ljust(3,'─'), "─".ljust(3,'─'),  "─".ljust(40,'─'), "─".ljust(30,'─'),
                "─".ljust(10,'─'), "─".ljust(10,'─') + "┘", file=fileptr, sep="┴")


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--about", help="README", action="store_true", default=False)
    parser.add_argument("-y", "--yes", help="Don't ask confirmation before running jobs", action="store_true", default=False)
    parser.add_argument("--cfg_file", help="Specify name alternative CFG file", type=str, default="BenchCFG")
    parser.add_argument("--run_name", help="Specify name of this run", type=str, default="")
    parser.add_argument("--boinc_home", help="Specify path for BOINC", type=str, default=mb_const.boinc_home)
    parser.add_argument("--noBS", help="Do not suspend BOINC", action="store_true", default=False)
    parser.add_argument("--display_compact", help="Display compact run status", action="store_true", default=False)
    parser.add_argument("--display_slots", help="Display run status by slots instead of jobs", action="store_true", default=False)
    parser.add_argument("--num_repetitions", help="Specify number of times to run benchmark", type=int, default=1)
    parser.add_argument("--max_threads", help="Specify max number of threads to load", type=int, default=0)
    parser.add_argument("--max_gpus", help="Specify max number of GPUs to load", type=int, default=0)
    parser.add_argument("--gpu_devices", help="Specify which GPUs to use: 0,1,2", type=str, default="")
    parser.add_argument("--std_signals", help="Use standard signal WUs instead of Test WUs", action="store_true", default=False)
    parser.add_argument("--no_ref", help="Do not generate reference results", action="store_true", default=False)
    parser.add_argument("--admin_mkdirs", help="Make required directories", action="store_true", default=False)
    parser.add_argument("-d", "--debug", help="Debug output", action="store_true", default=False)
    args = parser.parse_args()
    mb_const.boinc_home = args.boinc_home


    if args.debug == True :  mb_const.DEBUG = True
    # Set and verify working environment
    if args.about == True :  
        print(__doc__ )
        print("Author: ", __author__ )
        print("Copyright: ", __copyright__)
        print("Credits: ", __credits__)
        print("License: ", __license__)
        print("Version: ", __version__)
        print("Maintainer: ", __maintainer__)
        print("Status: ", __status__)
        exit(0)
    env = BENCH_ENV()
    if(env.set_env() == False): 
        if args.makedirs == True :
            env.makedirs()
            exit(0)
        print("Error in environment.  Exiting...")
        sys.exit(-1)

    if len(args.cfg_file) > 0 :
        if args.cfg_file != "BenchCFG" :
            test_command_line_file = env.current_dir + "/" + args.cfg_file
            if(os.path.isfile(test_command_line_file) == True): 
                env.command_line_file = test_command_line_file
            else:
                print("Specified BenchCFG [", test_command_line_file,"] doesn't exist")
                sys.exit(-1)

    # Read BenchCFG file and create list of provided apps and aguments.
    # Determine of the apps are GPU or CPU by checking which APP_DIR they are located in
    cfg_modes = CFG_MODES()
    applist = JOB_LIST()
    applist.read_benchcfg(env, cfg_modes)
    if mb_const.DEBUG == True: applist.print(title="Initial app list")

    # set modes with CFG file mode statements
    specified_max_threads = -1
    specified_max_gpus = -1
    if cfg_modes.mode_value("yes") == True :  args.yes = True
    if cfg_modes.mode_value("run_name") != None :
        if len(cfg_modes.mode_value("run_name")) > 0 :
            if cfg_modes.mode_value("run_name").isprintable():
                env.run_name = cfg_modes.mode_value("run_name").replace(' ','')
                env.run_name = env.run_name.replace('/','')
                env.run_name = env.run_name.replace('\\','')
    if cfg_modes.mode_value("std_signals") == True :  env.mode_std_signals = True
    if cfg_modes.mode_value("display_compact") == True :  env.mode_display_compact = True
    if cfg_modes.mode_value("display_slots") == True :  env.mode_display_slots = True
    # read user specified GPU device list
    cfg_gpu_devices = []
    if cfg_modes.mode_value("gpu_devices") != None:
        if re.fullmatch('([0-9],)*([0-9])+', cfg_modes.mode_value("gpu_devices")):
            gdev_items = cfg_modes.mode_value("gpu_devices").split(',')
            cfg_gpu_devices = []
            for gi in gdev_items:
                cfg_gpu_devices[len(cfg_gpu_devices):] = [int(gi)]
            if max(cfg_gpu_devices) > env.total_gpu_threads - 1:
                print("Invalid gpu_device mode, max of ", str(cfg_gpu_devices),
                        "is > number of GPUs [", env.total_gpu_threads, " - 1 ]")
                cfg_gpu_devices = []
            else:
                print("CFG gpu_devices: ", str(cfg_gpu_devices))
        else:
            print("Invalid CFG gpu_devices arg: [", cfg_modes.mode_value("gpu_devices"), "]")
    if cfg_modes.mode_value("num_repetitions") != None : 
        if cfg_modes.mode_value("num_repetitions") > 0 : 
            env.repetitions = cfg_modes.mode_value("num_repetitions")
        else:
            print("CFG: Invalid number of repetitions specified ["+ str(cfg_modes.mode_value("num_repetitions")) + "].  Ignoring...")
    if cfg_modes.mode_value("max_threads") != None : 
        if cfg_modes.mode_value("max_threads") > 0 : 
            specified_max_threads = cfg_modes.mode_value("max_threads")
    if cfg_modes.mode_value("max_gpus") != None : 
        if cfg_modes.mode_value("max_gpus") > 0 : 
            specified_max_gpus = cfg_modes.mode_value("max_gpus")

    # overwrite modes with command line arguments
    if len(args.run_name) > 0 :
        if args.run_name.isprintable():
            env.run_name = args.run_name.replace(' ','')
            env.run_name = env.run_name.replace('/','')
            env.run_name = env.run_name.replace('\\','')
    if args.std_signals == True :  env.mode_std_signals = True
    if args.display_compact == True :  env.mode_display_compact = True
    if args.display_slots == True :  env.mode_display_slots = True
    # read user specified GPU device list
    specified_gpu_devices = []
    if len(args.gpu_devices) > 0:
        if re.fullmatch('([0-9],)*([0-9])+', args.gpu_devices):
            gdev_items = args.gpu_devices.split(',')
            specified_gpu_devices = []
            for gi in gdev_items:
                specified_gpu_devices[len(specified_gpu_devices):] = [int(gi)]
            if max(specified_gpu_devices) > env.total_gpu_threads - 1:
                print("Invalid gpu_device specified, max of ", str(specified_gpu_devices),
                        "is > number of GPUs [", env.total_gpu_threads, " - 1 ]")
                specified_gpu_devices = []
            else:
                print("Specified gpu_devices: ", str(specified_gpu_devices))
        else:
            print("Invalid gpu_devices arg: [", args.gpu_devices, "]")
    if args.num_repetitions > 1 : 
        env.repetitions = args.num_repetitions

    if args.max_threads > 0: specified_max_threads = args.max_threads
    if specified_max_threads > 0 and specified_max_threads < env.total_cpu_threads :
        env.allocated_cthreads = specified_max_threads
    else:
        env.allocated_cthreads = env.total_cpu_threads

    if args.max_gpus > 0: specified_max_gpus = args.max_gpus
    if specified_max_gpus > 0 and specified_max_gpus < env.total_gpu_threads :
        env.allocated_gthreads = specified_max_gpus
    else:
        env.allocated_gthreads = env.total_gpu_threads

    if len(specified_gpu_devices) == 0:
        if len(cfg_gpu_devices) > 0:
            specified_gpu_devices = cfg_gpu_devices
    if len(specified_gpu_devices) > 0:
        if len(specified_gpu_devices) == env.allocated_gthreads:
            env.gpu_devices = specified_gpu_devices
            print("Set specified gpu_devices: ", str(specified_gpu_devices))
        else:
            print("Mismatch with allocated GPUS, specified gpu_devices NOT set: [", args.gpu_devices, "]")
            exit(-1)

    env.print()

    # Create a list of WUs to be processed
    wulist = JOB_LIST()
    wulist.read_wu_list(env)
    if mb_const.DEBUG == True: wulist.print(title="Initial WU list")

    if args.no_ref == False:
        # Create a reference job list
        reflist = JOB_LIST()
        ref_app = BENCH_JOB(uuid4().hex)
        #Determine ref_app name - only 1 app in REF_APP dir is used
        cwd = os.getcwd()
        os.chdir(env.ref_app_path)
        ref_app.app_name = glob.glob("ref-cpu.*")[0]
        if(os.path.isfile(ref_app.app_name) == False): 
            print("Error: can not access reference app: [" + ref_app.app_name + "]")
            valid_ref = False
        else:
            valid_ref = True
            ref_app.app_args = " --nographics"
            reflist.create_ref_list(ref_app, wulist, env)
            #reflist.print(title="Reference Job List")
        os.chdir(cwd)
        reflist.check_ref_results(env)
        reflist.print(title="Reference Job List", show_skipped=True)

    # Create a final job list from the applist and wulist and append reflist
    joblist = JOB_LIST()
    joblist.create_job_list(applist, wulist, env)
    if args.no_ref == False: joblist.append_job_list(reflist)
    joblist.print(title="Final Job List")

    # Prepare working slots
    num_cpu_jobs = max(joblist.pending_pjobs()["CPU"], joblist.pending_pjobs()["REF"])
    num_gpu_jobs = joblist.num_gpu_jobs()
    if num_cpu_jobs > 0 and num_gpu_jobs > 0 and env.allocated_cthreads < 2:
        print("ERROR: Insufficient threads available for specified jobs. Exiting...")
        sys.exit(-1)
    if num_gpu_jobs > env.allocated_gthreads:
        num_gpu_slots = env.allocated_gthreads
    else:
        num_gpu_slots = num_gpu_jobs

    if num_gpu_slots >= env.allocated_cthreads and num_cpu_jobs > 0 :
        num_gpu_slots = env.allocated_cthreads - 1
    elif num_gpu_slots >= env.allocated_cthreads and num_cpu_jobs == 0 :
        num_gpu_slots = env.allocated_cthreads 
    if num_gpu_slots < 1 and num_gpu_jobs > 0:
        print("ERROR: Insufficient threads available for specified jobs. Exiting...")
        sys.exit(-1)

    if num_cpu_jobs + num_gpu_slots < env.allocated_cthreads :
        env.allocated_cthreads = num_cpu_jobs + num_gpu_slots

    env.allocated_gthreads = num_gpu_slots
    print("For " + str(num_cpu_jobs) + " CPU jobs and " + str(env.allocated_gthreads) +
                " GPU slots. Allocated Threads reduced to " + str(env.allocated_cthreads))

    # check if there is already and instance running in this directory
    if env.is_bench_conflict() :
        print("Another instance of benchMT is running in this directory, exiting...")
        exit(-1)
    slots = SLOTS_LIST()
    slots.create_slot_list(env.allocated_cthreads)
    if slots.initialize_slots(env, num_gpu_slots) == False :
        sys.exit(-1)
    slots.print(title="List of Initialized Slots")

    # Execute the joblist
    num_available_pslots = slots.available_pslots()
    num_pending_pjobs = joblist.pending_pjobs()
    num_pending_jobs = num_pending_pjobs["CPU"] + num_pending_pjobs["GPU"]
    print("Pending jobs (CPU/GPU): ", num_pending_pjobs["CPU"],"/", num_pending_pjobs["GPU"])
    print("Pending reference jobs: ", num_pending_pjobs["REF"])
    if args.yes == False :
        if input("Execute listed jobs? [y/N]").lower() != 'y': exit(1)
    # check if there is already and instance running in this directory
    #This check is too late in the flow
    #if env.is_bench_conflict() :
        #print("Another instance of benchMT is running in this directory, exiting...")
        #exit(-1)


    if mb_const.DEBUG == False: os.system('clear')
    if env.mode_display_slots == True:
        slots.print_activity(joblist, env.mode_display_compact)
    else:
        joblist.print(env.mode_display_compact)

    #Make testData subdirectory for this run and open summary file for writing
    # update summary_path in case the run name was set
    env.summary_path = env.testdata_path + "/" + env.hostname + "_benchMT_" + env.run_name + "_" + env.time_now_short
    env.summary_file = env.summary_path + "/" + env.hostname + ".testlog." + env.run_name + "_" + env.time_now_short + ".txt"
    env.psv_file = env.summary_path + "/" + env.hostname + ".timelog." + env.run_name + "_" + env.time_now_short + ".psv"

    os.mkdir(env.summary_path)
    if(os.path.isdir(env.summary_path) == False):
        print("Failed to make benchMT testData subdir [", env.summary_path,"]")
        exit(-1)
    env.sum_file_ptr = open(env.summary_file, 'w', 1)
    env.psv_file_ptr = open(env.psv_file, 'w', 1)
    print(__program_name__ + " " +  __version__ +  " \u2015 SETI MB Benchmarking Utility \u2015 Linux edition\n",
            file=env.sum_file_ptr)
    if args.noBS == False:
        print("Suspending BOINC\n", file=env.sum_file_ptr)
        env.suspend_boinc()
    print("System Details", file=env.sum_file_ptr)
    env.print(fileptr=env.sum_file_ptr)
    print("\nAPP List", file=env.sum_file_ptr)
    applist.print_app_names(fileptr=env.sum_file_ptr)
    print("\nWU List", file=env.sum_file_ptr)
    wulist.print_wu_names(fileptr=env.sum_file_ptr)
    print("", file=env.sum_file_ptr)

    #Loop to run all of the jobs
    if num_pending_pjobs["REF"] > 0 :
        platform_list = ["REF"]
    else:
        platform_list = ["CPU", "GPU"]

    while(True):
        num_available_pslots = slots.available_pslots()
        num_pending_pjobs = joblist.pending_pjobs()
        num_pending_jobs = joblist.count_pending_pjobs(platform_list)
        if(num_pending_jobs > 0):
            for plat in platform_list:
                if mb_const.DEBUG == True:
                    print("Platform: ", plat, "Total Pending Jobs: ", num_pending_jobs)
                    print("Pending jobs (CPU/GPU/REF): ", num_pending_pjobs["CPU"],"/", num_pending_pjobs["GPU"], "/", num_pending_pjobs["REF"])
                    print("Available slots (CPU/GPU): ", num_available_pslots["CPU"],"/", num_available_pslots["GPU"], "\n")
                while num_available_pslots[plat] > 0 and num_pending_pjobs[plat] > 0 :
                    #get an available job for open slot
                    slot_num = slots.request_slot(plat)
                    job_num = joblist.request_job(plat)
                    if mb_const.DEBUG: print("SlotNum: ", slot_num, "JobUUID: ", job_num)
                    slots.assign_job(joblist, slot_num, job_num) #changes states in both job and slot

                    #Copy WU to slot
                    shutil.copy2(slots.list[slot_num].job.wu_path + slots.list[slot_num].job.wu_name,
                            slots.list[slot_num].slot_dir +"/" + mb_const.activeWU)

                    #Construct app/arg list 
                    if plat == "GPU":
                        device_arg = " -device " + str(slots.list[slot_num].device) + " "
                        slots.list[slot_num].job.app_args = device_arg + slots.list[slot_num].job.app_args 
                        cmd_str = env.gpu_app_path + slots.list[slot_num].job.app_name + " " + slots.list[slot_num].job.app_args
                    elif plat == "CPU":
                        cmd_str = env.cpu_app_path + slots.list[slot_num].job.app_name + " " + slots.list[slot_num].job.app_args
                    else:
                        cmd_str = env.ref_app_path + slots.list[slot_num].job.app_name + " " + slots.list[slot_num].job.app_args
                    if mb_const.DEBUG == True: print(cmd_str)


                    #cd to slot dir and execute app with args
                    # TODO should consider executing job with time command
                    os.chdir(slots.list[slot_num].slot_dir)
                    slots.list[slot_num].job.start_time = datetime.utcnow()
                    slots.list[slot_num].job.cmd = subprocess.Popen(shlex.split(cmd_str), shell=False, stdout=subprocess.PIPE)
                    # TODO deal with an immediate fail to spawn a process
                    os.chdir(env.current_dir)
                    num_available_pslots = slots.available_pslots()
                    num_pending_pjobs = joblist.pending_pjobs()
                    #end while
                #end for plat
                num_pending_jobs = joblist.count_pending_pjobs(platform_list)
            #end if num_pending_jobs > 0

        #refresh screen
        if mb_const.DEBUG == False: os.system('clear')
        if env.mode_display_slots == True:
            slots.print_activity(joblist, env.mode_display_compact)
        else:
            joblist.print(env.mode_display_compact)

        #This is the part where we wait for jobs to complete
        num_pending_jobs = joblist.count_pending_pjobs(platform_list)
        if num_pending_jobs == 0 :
            #wait for all jobs to finish
            if platform_list[0] == "REF":
                wait_str="REF"
            else:
                wait_str=""
            while slots.all_complete(platform=wait_str) == False : 
                freed_slot = joblist.wait_for_complete_job(env)
                slots.free_slot(freed_slot)
                if mb_const.DEBUG == False: os.system('clear')
                if env.mode_display_slots == True:
                    slots.print_activity(joblist, env.mode_display_compact)
                else:
                    joblist.print(env.mode_display_compact)
            # no more pending jobs and all active jobs complete
            if platform_list[0] == "REF":
                if mb_const.DEBUG == True: print("Switching platforms")
                platform_list = ["CPU", "GPU"]
        else:
            #wait for appropriate slot to be available
            num_available_pslots = slots.available_pslots()
            num_pending_pjobs = joblist.pending_pjobs()
            for plat in platform_list:
                if num_available_pslots[plat] == 0 and num_pending_pjobs[plat] > 0 :
                    freed_slot = joblist.wait_for_complete_job(env)
                    slots.free_slot(freed_slot)

        num_available_pslots = slots.available_pslots()
        num_pending_pjobs = joblist.pending_pjobs()
        num_pending_jobs = joblist.pending_jobs()
        if mb_const.DEBUG == True: print(num_pending_jobs)
        if joblist.all_complete() == True : break
        #end of while True

    if mb_const.DEBUG == False: os.system('clear')
    if env.mode_display_slots == True:
        slots.print_activity(joblist, env.mode_display_compact)
    else:
        joblist.print(env.mode_display_compact)
    if mb_const.DEBUG == True: slots.print()

    # finalize reports
    joblist.print(fileptr=env.sum_file_ptr)
    joblist.psv_print(env, fileptr=env.psv_file_ptr)

    os.chdir(env.current_dir)
    if args.noBS == False:
        print("Resuming BOINC", file=env.sum_file_ptr)
        env.resume_boinc()

    complete_time = datetime.utcnow()
    print("Finish Time: " + complete_time.strftime('%c'), file=env.sum_file_ptr)

    # close files 
    env.sum_file_ptr.close()
    env.psv_file_ptr.close()

    # Remove lockfile
    if(os.path.isfile(env.lockfile) == True): 
        os.remove(env.lockfile)


if __name__ == "__main__":
    main()
