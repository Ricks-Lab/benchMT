#!/usr/bin/env python3
"""benchMT  -  SETI multi-threaded MB/AP Benchmark Tool

    This tool will extract the total number of CPU cores/threads and GPU platforms from the user's
    environment and utilize them in running a list of apps/args specified in the benchCFG file.  Using
    less than the total number of CPU threads can be specified in the command line.  This tool will
    read a list of MB/AP apps/args from the BenchCFG file and search for the specified MB/AP apps in the
    APP_CPU and APP_GPU directories to validate and determine platform.  It will then leverage allocated
    threads, as specified, to run all benchmark jobs, storing results in the testData directory.  Use
    the *--help* option to get a description of valid command line arguments. In support of automation,
    some command line arguments can be specified as modes in the BenchCFG file.

    By default, a summary list of all jobs will update in the display as the program progresses.  If
    there are a large number of jobs, then this display may not be useful and the *--display_slots*
    option can be used to display the status of each slot as the program progresses.  In some cases,
    there will be too many slots to display, and the *--display_compact* option can used to further
    optimize the progress display.

    You may need to use the *--boinc_home* command option to specify the boinc home directory, which
    is required, since boinccmd is used. Specifying --noBS on the command line will allow benchMT to 
    function without a boinc installation.  An alternative BenchCFG file can be specified with the
    command line option *--cfg_file filename*.

    All WUs in the WU_test directory will be used in the creation of jobs to be run, unless the
    *--std_signals* option is used, in which case, WUs in the WU_std_signal will be used.  The
    APPS_GPU and APPS_CPU directories can have more apps than are specified to run in the BenchCFG
    file, but must contain apps specified in BenchCFG.  The APPS_REF directory must contain a single
    CPU reference app with a file prefix of "ref-cpu.".  The stock CPU app is suggested, as this is
    only used to test integrity of the results.  Elapsed time analysis is expected to be limited to
    apps/arg combinations specified in BenchCFG.  The generation of reference results can be skipped
    with the *--no_ref* option or forced with the *--force_ref* option. The *--energy* option can be
    used if your system has amdgpu drivers with compatible GPUs to give the energy used in running a
    task.  In order to correctly associate a GPU card number with a BOINC device number, you must
    specify this with the *--devmap B:C,B2:C2* option.  I know of no reobust way to make this mapping
    other than manually running each card individually and observing which card is being used.  If
    you are running an AstroPulse app, you must specify the *--astropulse* option in order for it to
    run properly.

    The results will be stored in a unique subdir of the testData directory. There is an overall run
    log txt file, a psv file useful for importing into an analytics tools, and the sah and stderr
    files for each job run. A run name can be specified with the *--run_name* commane line option. This
    name will be included in the name of the testData subdirectory for the current run.

    Copyright (C) 2018  RueiKe

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
"""
__author__ = 'RueiKe'
__copyright__ = 'Copyright (C) 2018 RueiKe'
__credits__ = ['Keith Myers - Testing and Verification']
__license__ = 'GNU General Public License'
__program_name__ = 'benchMT'
__version__ = 'v2.0.0'
__maintainer__ = 'RueiKe'
__status__ = 'Beta Release - Testing only, please use official release if not interested in testing.'
__docformat__ = 'reStructuredText'

import argparse
import re
import subprocess
import shlex
import socket
import os
import platform
import sys
import time
from datetime import datetime
from uuid import uuid4
import glob 
import shutil 
from pathlib import Path
from typing import Union


class MB_CONST:
    """
    Defines benchMT constants used through out the code.
    """
    def __init__(self):
        self.boinc_home = '/home/boinc/BOINC/'
        self.cpu_app_subdir = 'APPS_CPU/'
        self.gpu_app_subdir = 'APPS_GPU/'
        self.ref_app_subdir = 'APPS_REF/'
        self.ref_results_subdir = 'REF_RESULTS/'
        self.wu_subdir = 'WU_test/'
        self.std_signal_subdir = 'WU_std_signal/'
        self.testdata_subdir = 'testData/'
        self.workdir_subdir = 'workdir/'
        self.slots_subdir = 'Slots/'
        self.command_line_filename = 'BenchCFG'
        self.boinccmd = 'boinccmd'
        self.template_file = 'init_data.xml.template'
        self.wu_cmp = 'rescmpv5_l'
        self.suspend_args = ['boinccmd --set_gpu_mode never 172800', 'boinccmd --set_run_mode never 172800']
        self.resume_args = ['boinccmd --set_gpu_mode never 1', 'boinccmd --set_run_mode never 1']
        self.activeWU = 'work_unit.sah'
        self.activeAPWU = 'in.dat'
        self.DEBUG = False
        self.noBS = False
        self.env = None
        # Items required for Energy feature
        self.card_root = '/sys/class/drm/'
        self.hwmon_sub = 'hwmon/hwmon'
        # System command definitions
        self.cmd_lspci = None
        self.cmd_lshw = None
        self.cmd_lscpu = None
        self.cmd_clinfo = None
        self.cmd_time = None
        self.cmd_lsb_release = None
        self.cmd_nvidia_smi = None

    def print(self):
        """
        Print all elements an MB_CONST object.
        :return: None
        :rtype: None
        """
        print('mb_const.boinc_home: [{}]'.format(self.boinc_home))
        print('mb_const.cpu_app_subdir: [{}]'.format(self.cpu_app_subdir))
        print('mb_const.gpu_app_subdir: [{}]'.format(self.gpu_app_subdir))
        print('mb_const.ref_app_subdir: [{}]'.format(self.ref_app_subdir))
        print('mb_const.ref_results_subdir: [{}]'.format(self.ref_results_subdir))
        print('mb_const.wu_subdir: [{}]'.format(self.wu_subdir))
        print('mb_const.std_signal_subdir: [{}]'.format(self.std_signal_subdir))
        print('mb_const.testdata_subdir: [{}]'.format(self.testdata_subdir))
        print('mb_const.workdir_subdir: [{}]'.format(self.workdir_subdir))
        print('mb_const.slots_subdir: [{}]'.format(self.slots_subdir))
        print('mb_const.command_line_filename: [{}]'.format(self.command_line_filename))
        print('mb_const.boinccmd: [{}]'.format(self.boinccmd))
        print('mb_const.template_file: [{}]'.format(self.template_file))
        print('mb_const.wu_cmp: [{}]'.format(self.wu_cmp))
        print('mb_const.suspend_args: [{}]'.format(self.suspend_args))
        print('mb_const.resume_args: [{}]'.format(self.resume_args))
        print('mb_const.activeWU: [{}]'.format(self.activeWU))
        print('mb_const.activeAPWU: [{}]'.format(self.activeAPWU))
        print('mb_const.DEBUG: [{}]'.format(self.DEBUG))
        print('mb_const.noBS: [{}]'.format(self.noBS))
        print('mb_const.env: [{}]'.format(self.env))
        # Items required for Energy feature
        print('mb_const.card_root: [{}]'.format(self.card_root))
        print('mb_const.hwmon_sub: [{}]'.format(self.hwmon_sub))
        # System command definitions
        print('mb_const.cmd_lspci: [{}]'.format(self.cmd_lspci))
        print('mb_const.cmd_lshw: [{}]'.format(self.cmd_lshw))
        print('mb_const.cmd_lscpu: [{}]'.format(self.cmd_lscpu))
        print('mb_const.cmd_clinfo: [{}]'.format(self.cmd_clinfo))
        print('mb_const.cmd_time: [{}]'.format(self.cmd_time))
        print('mb_const.cmd_lsb_release: [{}]'.format(self.cmd_lsb_release))
        print('mb_const.cmd_nvidia_smi: [{}]'.format(self.cmd_nvidia_smi))


mb_const = MB_CONST()


class CFG_MODES:
    """
    Defines benchMT configuration modes.
    """
    def __init__(self):
        self.modes = {'yes': None,
                      'run_name': None,
                      'boinc_home': None,
                      'noBS': None,
                      'display_compact': None,
                      'display_slots': None,
                      'num_repetitions': None,
                      'max_threads': None,
                      'max_gpus': None,
                      'gpu_devices': None,
                      'devmap': None,
                      'std_signals': None,
                      'no_ref': None,
                      'force_ref': None,
                      'energy': None,
                      'astropulse': None}
        self.type = {'yes': 'Logical',
                     'run_name': 'String',
                     'boinc_home': 'String',
                     'noBS': 'Logical',
                     'display_compact': 'Logical',
                     'display_slots': 'Logical',
                     'num_repetitions': 'Numeric',
                     'max_threads': 'Numeric',
                     'max_gpus': 'Numeric',
                     'gpu_devices': 'String',
                     'devmap': 'String',
                     'std_signals': 'Logical',
                     'no_ref': 'Logical',
                     'force_ref': 'Logical',
                     'energy': 'Logical',
                     'astropulse': 'Logical'}

    def set_mode(self, mode_name, mode_value):
        """
        Set given mode to the specified value.
        :param mode_name: Name of the mode to be updated
        :type mode_name: str
        :param mode_value: Value
        :type mode_value: str
        :return: True if successful
        :rtype: bool
        """
        if mode_name not in self.modes:
            return False
        if mode_name not in self.type:
            return False

        if self.type[mode_name] == 'Logical':
            if mode_value == 'True':
                self.modes[mode_name] = True
                return True
            elif mode_value == 'False':
                self.modes[mode_name] = False
                return True
            return False
        elif self.type[mode_name] == 'Numeric':
            if re.fullmatch('[-]*[0-9]+', mode_value):
                self.modes[mode_name] = int(mode_value)
                return True
            else:
                return False
        elif self.type[mode_name] == 'String':
            self.modes[mode_name] = mode_value
        else:
            return False

    def mode_value(self, mode_name):
        """
        Get value for given mode.
        :param mode_name:
        :type mode_name: str
        :return:  value
        :rtype: Union([str, bool])
        """
        if mode_name not in self.modes.keys():
            return False
        return self.modes[mode_name]

    def print(self):
        """
        Print modes.
        :return: None
        :rtype: None
        """
        for m, v in self.modes.items():
            print('CFG_mode: {} {}'.format(m, str(v)))


class GPU_ITEM:
    """
    Defines a data object that represents a GPU.
    """
    def __init__(self, item_id):
        self.uuid = item_id
        self.card_num = None
        self.boinc_device_num = None
        self.model = ''
        self.vendor = ''
        self.card_path = None
        self.hwmon_path = None
        self.pcie_id = ''
        self.driver = ''
        self.energy_compatible = False
        self.compute_compatible = False
        self.ocl_device_name = None
        self.ocl_device_version = None
        self.ocl_device_index = None
        time_0 = datetime.utcnow()
        self.energy = {'t0': time_0, 'tn': time_0, 'cumulative': 0.0}
        self.power = -1

    def populate(self, pcie_id, gpu_name, vendor, driver_module, card_path, hwmon_path,
                 energy, compute, ocl_dev, ocl_ver, ocl_index):
        """
        Populate elements of a GPU_ITEM.
        :param pcie_id: The pcid ID of the GPU.
        :type pcie_id: str
        :param gpu_name:  Model name of the GPU
        :type gpu_name: str
        :param vendor:  The make of the GPU (AMD, NVIDIA, ...)
        :type vendor: str
        :param driver_module: The name of the driver.
        :type driver_module: str
        :param card_path: The path to the GPU.
        :type card_path: str
        :param hwmon_path: Path to the hardware monitor files.
        :type hwmon_path: str
        :param energy: Energy compatibility flag
        :type energy: bool
        :param compute: Compute compatibility flag
        :type compute: bool
        :param ocl_dev:  openCL device
        :type ocl_dev: str
        :param ocl_ver: openCL version
        :type ocl_ver: str
        :param ocl_ver: openCL index
        :type ocl_ver: str
        :return: None
        :rtype: None
        """
        self.pcie_id = pcie_id
        self.model = gpu_name
        self.vendor = vendor
        self.driver = driver_module
        self.card_path = card_path
        self.card_num = int(card_path.replace('{}card'.format(mb_const.card_root), '').replace('/device', ''))
        self.hwmon_path = hwmon_path
        self.energy_compatible = energy
        self.compute_compatible = compute
        self.ocl_device_name = ocl_dev
        self.ocl_device_version = ocl_ver
        self.ocl_device_index = ocl_index

    def print(self):
        """
        Print GPU_ITEM.
        :return: None
        :rtype: None
        """
        print('GPU_ITEM: uuid: {}'.format(self.uuid))
        print('    pcie_id: {}'.format(self.pcie_id))
        print('    model: {}'.format(self.model))
        print('    vendor: {}'.format(self.vendor))
        print('    driver: {}'.format(self.driver))
        print('    openCL Device: {}'.format(self.ocl_device_name))
        print('    openCL Version: {}'.format(self.ocl_device_version))
        print('    openCL Index: {}'.format(self.ocl_device_index))
        print('    card number: {}'.format(self.card_num))
        print('    BOINC Device number: {}'.format(self.boinc_device_num))
        print('    card path: {}'.format(self.card_path))
        print('    hwmon path: {}'.format(self.hwmon_path))
        print('    Compute compatible: {}'.format(self.compute_compatible))
        print('    Energy compatible: {}'.format(self.energy_compatible))

    def reset_energy(self):
        """
        Reset energy metrics to time zero state.
        :return: None
        :rtype: None
        """
        time_0 = datetime.utcnow()
        self.energy = {'t0': time_0, 'tn': time_0, 'cumulative': 0.0}

    def get_energy(self):
        """
        Return the cumulative energy.
        :return:  cumulative energy
        :rtype: float
        """
        return self.energy['cumulative']

    def update_energy_data(self):
        """
        Update energy metrics my getting current power and adding it product with time since last
        call to the cumulative energy value.
        :return: True if successful
        :rtype: bool
        """
        if not self.energy_compatible:
            return False
        self.power = self.get_power()
        if self.power:
            time_n = datetime.utcnow()
            delta_hrs = ((time_n - self.energy['tn']).total_seconds())/3600
            self.energy['tn'] = time_n
            self.energy['cumulative'] += delta_hrs * self.power/1000
            if mb_const.DEBUG: print('Cumulative Energy for {}: {} kWh'.format(self.pcie_id,
                                                                               round(self.energy['cumulative'], 6)))
            return True
        else:
            print('Error: Power read failed for GPU-{}: [{}]'.format(self.card_num, self.pcie_id), file=sys.stderr)
            return False

    def get_power(self, set_energy_compatibility=False):
        """
        Get power from GPU and set energy compatible flag if desired.
        :param set_energy_compatibility: True if GPU_ITEM energy_compatible flag is to be not checked and set.
        :type set_energy_compatibility: bool
        :return: power reading in Watts
        :rtype: Union([float, None])
        """
        power_reading = None
        # If not called as part of compatibility check, then check compatibility
        if not set_energy_compatibility:
            if not self.energy_compatible:
                return None

        if self.vendor == 'AMD':
            # AMD power reading
            if self.hwmon_path:
                hw_power_file = os.path.join(self.hwmon_path, 'power1_average')
                if os.path.isfile(hw_power_file):
                    try:
                        with open(hw_power_file) as hwmon_file:
                            power_reading = int(hwmon_file.readline())/1000000.0
                    except:
                        power_reading = None
                        if mb_const.DEBUG: print('Failed to make power reading for {}'.format(self.pcie_id))
        elif self.vendor == 'NVIDIA':
            # NVIDIA power reading
            if mb_const.cmd_nvidia_smi:
                try:
                    nsmi_items = subprocess.check_output(
                                 '{} -i {} --query-gpu=power.draw --format=csv,noheader,nounits'.format(
                                 mb_const.cmd_nvidia_smi, self.pcie_id), shell=True).decode().split('\n')
                    power_reading = nsmi_items[0]
                except:
                    power_reading = None
                    if mb_const.DEBUG: print('Failed to make power reading for {}'.format(self.pcie_id))

        if mb_const.DEBUG: print('Power reading for {}: {} W'.format(self.pcie_id, power_reading))
        if set_energy_compatibility:
            self.energy_compatible = True if power_reading else False

        return power_reading


class GPU_LIST:
    """
    An object that stores all GPU objects and other critial parameters.
    """
    def __init__(self):
        self.list = {}
        self.devmap = {}
        self.opencl_map = {}

    def print(self):
        """
        Print every GPU_ITEM in the GPU_LIST object.
        :return:  None
        :rtype:  None
        """
        for k, v in self.list.items():
            v.print()

    def add(self, gpu_item):
        """
        Add given GPU_ITEM to the GPU_LIST
        :param gpu_item:  Item to be added
        :type gpu_item: GPU_ITEM
        :return: None
        :rtype: None
        """
        self.list[gpu_item.uuid] = gpu_item

    def read_gpu_opencl_data(self):
        """
        Use clinfo system call to get openCL details for relevant GPUs.
        :return:  Returns True if successful
        :rtype:  bool
        """
        # Check access to clinfo command
        if not mb_const.cmd_clinfo:
            print('OS Command [clinfo] not found.  Use sudo apt-get install clinfo to install', file=sys.stderr)
            return False
        cmd = subprocess.Popen(shlex.split('{} --raw'.format(mb_const.cmd_clinfo)), shell=False, stdout=subprocess.PIPE)
        ocl_pcie_id = ''
        ocl_device_name = ''
        ocl_device_version = ''
        ocl_index = ''
        ocl_pcie_slot_id = ocl_pcie_bus_id = None
        for line in cmd.stdout:
            linestr = line.decode('utf-8').strip()
            if len(linestr) < 1:
                continue
            if linestr[0] != '[':
                continue
            linestr = re.sub(r'   [ ]*', ':-:', linestr)
            lineItems = linestr.split(':-:')
            if len(lineItems) != 3:
                continue
            cl_vender, cl_index = tuple(re.sub(r'[\[\]]', '', lineItems[0]).split('/'))
            # print('cl_vendor: {}, cl_index: {}'.format(cl_vender, cl_index))
            if cl_index == '*':
                continue
            if ocl_index == '':
                ocl_index = cl_index
                ocl_pcie_slot_id = ocl_pcie_bus_id = None

            # If new cl_index, then update opencl_map
            if cl_index != ocl_index:
                self.opencl_map.update({ocl_pcie_id: [ocl_device_name, ocl_device_version, ocl_index]})
                if mb_const.DEBUG: print('cl_index: {}'.format(self.opencl_map[ocl_pcie_id]))
                ocl_index = cl_index
                ocl_pcie_id = ''
                ocl_device_name = ''
                ocl_device_version = ''
                ocl_pcie_slot_id = ocl_pcie_bus_id = None

            param_str = lineItems[1]
            searchObj = re.search('CL_DEVICE_NAME', param_str)
            if searchObj:
                ocl_device_name = lineItems[2].strip()
                if mb_const.DEBUG: print('ocl_device_name [{}]'.format(ocl_device_name))
                continue
            searchObj = re.search('CL_DEVICE_VERSION', param_str)
            if searchObj:
                ocl_device_version = lineItems[2].strip()
                if mb_const.DEBUG: print('ocl_device_version [{}]'.format(ocl_device_version))
                continue
            searchObj = re.search('CL_DEVICE_TOPOLOGY', param_str)
            if searchObj:
                ocl_pcie_id = (lineItems[2].split()[1]).strip()
                if mb_const.DEBUG: print('ocl_pcie_id [{}]'.format(ocl_pcie_id))
                continue
            searchObj = re.search('CL_DEVICE_PCI_BUS_ID_NV', param_str)
            if searchObj:
                ocl_pcie_bus_id = hex(int(lineItems[2].strip()))
                if ocl_pcie_slot_id is not None:
                    ocl_pcie_id = '{}:{}.0'.format(ocl_pcie_bus_id[2:].zfill(2), ocl_pcie_slot_id[2:].zfill(2))
                    ocl_pcie_slot_id = ocl_pcie_bus_id = None
                    if mb_const.DEBUG: print('ocl_pcie_id [{}]'.format(ocl_pcie_id))
                if mb_const.DEBUG: print('ocl_pcie_id [{}]'.format(ocl_pcie_id))
                continue
            searchObj = re.search('CL_DEVICE_PCI_SLOT_ID_NV', param_str)
            if searchObj:
                ocl_pcie_slot_id = hex(int(lineItems[2].strip()))
                if ocl_pcie_bus_id is not None:
                    ocl_pcie_id = '{}:{}.0'.format(ocl_pcie_bus_id[2:].zfill(2), ocl_pcie_slot_id[2:].zfill(2))
                    ocl_pcie_slot_id = ocl_pcie_bus_id = None
                    if mb_const.DEBUG: print('ocl_pcie_id [{}]'.format(ocl_pcie_id))
                continue

        self.opencl_map.update({ocl_pcie_id: [ocl_device_name, ocl_device_version, ocl_index]})
        if mb_const.DEBUG: print('cl_index: {}'.format(self.opencl_map[ocl_pcie_id]))
        return True

    def set_gpu_list(self):
        """
        Use lspci to populate list of all installed GPUs.
        :return: True on success
        :rtype: bool
        """
        if not mb_const.cmd_lspci:
            return False
        self.read_gpu_opencl_data()
        if mb_const.DEBUG: print(self.opencl_map)

        try:
            pcie_ids = subprocess.check_output('{} | grep -E \"^.*(VGA|3D|Display).*$\" | grep -Eo \
                                               \"^([0-9a-fA-F]+:[0-9a-fA-F]+.[0-9a-fA-F])\"'.format(mb_const.cmd_lspci),
                                               shell=True).decode().split()
        except:
            print('lspci failed to find GPUs')
            return False

        if mb_const.DEBUG: print('Found {} GPUs'.format(len(pcie_ids)))
        for pcie_id in pcie_ids:
            gpu_uuid = uuid4().hex
            self.add(GPU_ITEM(gpu_uuid))
            if mb_const.DEBUG: print('GPU: ', pcie_id)
            energy = compute = False
            lspci_items = subprocess.check_output('{} -k -s {}'.format(mb_const.cmd_lspci, pcie_id),
                                                  shell=True).decode().split('\n')
            if mb_const.DEBUG: print(lspci_items)

            # Get Long GPU Name
            gpu_name = 'UNKNOWN'
            gpu_name_items = lspci_items[0].split(': ', maxsplit=1)
            if len(gpu_name_items) >= 2:
                gpu_name = gpu_name_items[1]
            # Check for Fiji ProDuo
            searchObj = re.search('Fiji', gpu_name)
            if searchObj:
                searchObj = re.search(r'Radeon Pro Duo', lspci_items[1].split('[AMD/ATI]')[1])
                if searchObj:
                    gpu_name = 'Radeon Fiji Pro Duo'

            # Get GPU brand: AMD, INTEL, NVIDIA, ASPEED
            vendor = 'UNKNOWN'
            opencl_device_name = None
            opencl_device_version = None
            opencl_device_index = None
            searchObj = re.search(r'(AMD|amd|ATI|ati)', gpu_name)
            if searchObj:
                vendor = 'AMD'
                compute = False
                if self.opencl_map:
                    if pcie_id in self.opencl_map.keys():
                        opencl_device_name = self.opencl_map[pcie_id][0]
                        opencl_device_version = self.opencl_map[pcie_id][1]
                        opencl_device_index = self.opencl_map[pcie_id][2]
                        compute = True
                else:
                    compute = True
            searchObj = re.search(r'(NVIDIA|nvidia|nVidia)', gpu_name)
            if searchObj:
                vendor = 'NVIDIA'
                compute = False
                if self.opencl_map:
                    if pcie_id in self.opencl_map.keys():
                        opencl_device_name = self.opencl_map[pcie_id][0]
                        opencl_device_version = self.opencl_map[pcie_id][1]
                        opencl_device_index = self.opencl_map[pcie_id][2]
                        compute = True
                else:
                    compute = True
                compute = True  # Always set compute = True for nvidia since I can not detect cuda
            searchObj = re.search(r'(INTEL|intel|Intel)', gpu_name)
            if searchObj:
                vendor = 'INTEL'
                compute = False
                if self.opencl_map:
                    if pcie_id in self.opencl_map.keys():
                        opencl_device_name = self.opencl_map[pcie_id][0]
                        opencl_device_version = self.opencl_map[pcie_id][1]
                        opencl_device_index = self.opencl_map[pcie_id][2]
                        compute = True
                else:
                    searchObj = re.search(r' 530', gpu_name)
                    if searchObj:
                        compute = False
                    else:
                        compute = True
            searchObj = re.search(r'(ASPEED|aspeed|Aspeed)', gpu_name)
            if searchObj:
                vendor = 'ASPEED'
                compute = False
            searchObj = re.search(r'(MATROX|matrox|Matrox)', gpu_name)
            if searchObj:
                vendor = 'MATROX'
                compute = False

            # Get Driver Name
            driver_module = 'UNKNOWN'
            for lspci_line in lspci_items:
                searchObj = re.search(r'(Kernel|kernel)', lspci_line)
                if searchObj:
                    driver_module_items = lspci_line.split(': ')
                    if len(driver_module_items) >= 2:
                        driver_module = driver_module_items[1].strip()

            # Get full card path
            card_path = None
            device_dirs = glob.glob(mb_const.card_root + 'card?/device')
            for device_dir in device_dirs:
                sysfspath = str(Path(device_dir).resolve())
                if pcie_id == sysfspath[-7:]:
                    card_path = device_dir

            # Get full hwmon path
            hwmon_path = None
            hw_file_srch = glob.glob(os.path.join(card_path, mb_const.hwmon_sub) + '?')
            if mb_const.DEBUG: print('hw_file_search: ', hw_file_srch)
            if len(hw_file_srch) > 1:
                print('More than one hwmon file found: ', hw_file_srch)
            elif len(hw_file_srch) == 1:
                hwmon_path = hw_file_srch[0] + '/'

            self.list[gpu_uuid].populate(pcie_id, gpu_name, vendor, driver_module,
                                         card_path, hwmon_path, energy, compute,
                                         opencl_device_name, opencl_device_version, opencl_device_index)

            # Set energy compatibility
            self.list[gpu_uuid].get_power(set_energy_compatibility=True)
        return True

    def apply_devmap(self):
        for k, v in self.list.items():
            for dmk, dmv in self.devmap.items():
                if v.card_num == dmv:
                    v.boinc_device_num = dmk
                    break

    def set_default_devmap(self, bd_list, cn_list):
        """
        Set a default devmap based on it being reverse of cn_list.
        :param bd_list:  BOINC device number list
        :type bd_list: list
        :param cn_list:  Linux card number list
        :type cn_list: list
        :return:  true on success
        :rtype: bool
        .. note:: Confirmed invalid approach, do not use.
        """
        if len(bd_list) != len(cn_list):
            return False
        boinc_dev_list = bd_list[:]
        card_num_list = cn_list[:]

        card_num_list.sort(reverse=True)
        boinc_dev_list.sort()
        mb_const.env.devmap = self.devmap = dict(zip(boinc_dev_list, card_num_list))
        return True

    def set_devmap(self, devmap, bd_list, cn_list):
        """
        Verify consistency of devmap to boinc and card number lists and set if ok.
        :param devmap:  The device mapping dictionary
        :type devmap: dict
        :param bd_list:  BOINC device number list
        :type bd_list: list
        :param cn_list:  Linux card number list
        :type cn_list: list
        :return:  true on success
        :rtype: bool
        """
        self.devmap = devmap
        ret_value = True
        for k, v in devmap.items():
            if k not in bd_list:
                print('Error in devmap: BOINC Device {} not in valid BOINC Devices [{}]'.format(k, bd_list))
                ret_value = False
            if v not in cn_list:
                print('Error in devmap: Card Number {} not in valid Driver Card Numbers [{}]'.format(v, cn_list))
                ret_value = False
        self.apply_devmap()
        return ret_value

    def get_device_gpu(self, device_num):
        """
        A function that uses the devmap dictionary to lookup a BOINC Device number and uses the corresponding
        card number to return the matching GPU.
        :param device_num:  An integer representing a BOINC Device number
        :type device_num:  int
        :return:  Returns the GPU_ITEM which corresponds to the card number in devmap
        :rtype: GPU_ITEM
        .. todo:: with the implementation of apply_devmap, this function could be optimized.
        """
        if not self.devmap:
            return None
        if device_num not in self.devmap:
            print('Error: Invalid device map, BOINC device number [{}] not in devmap [{}]'.format(device_num,
                                                                                                  self.devmap))
            print('Exiting...')
            mb_const.env.resume_boinc()
            sys.exit(-1)
        card_num = self.devmap[device_num]

        for k, v in self.list.items():
            if v.card_num == card_num:
                if mb_const.DEBUG: print('Device {} maps to card {}'.format(device_num, v.card_num))
                return v

        print('Error: Invalid device map [{}] BOINC Device to GPU Card num'.format(device_num))
        print('       Card [{}] mapped to BOINC device number [{}] does not exist'.format(card_num, device_num))
        print('Exiting...')
        mb_const.env.resume_boinc()
        sys.exit(-1)

    def set_env_boinc_gpu_details(self, env):
        """
        Set the remaining env parameters after GPU details are read.
        :param env:  The execution environment
        :type env: BENCH_ENV
        :return:  None
        """
        env.total_gpu_threads = env.total_gpu_count = len(self.get_card_number_list(compute=True))
        env.boinc_dev_list = []
        for gi in range(0, env.total_gpu_count):
            env.boinc_dev_list.append(int(gi))

    def get_gpu_details(self, compute=False, energy=False):
        """
        This function returns a list of all valid card details. If compute is true, then only compute
        compatible cards are returned.  If energy is true then only compute compatible GPUs with energy capability
        are returned.
        :param compute: if True return list of compute capable cards
        :type compute: bool
        :param energy: if True return list of compute capable cards that are energy capable
        :type energy: bool
        :return: Returns a list of GPU details.
        :rtype: list
        """
        gdlist = []
        for k, v in self.list.items():
            if v.card_num is not None:
                if compute:
                    if v.compute_compatible:
                        if mb_const.DEBUG: v.print()
                        gdlist.append('Card{}, PCIE ID: {}, Model: {}'.format(v.card_num, v.pcie_id, v.model))
                elif energy:
                    if v.compute_compatible and v.energy_compatible:
                        if mb_const.DEBUG: v.print()
                        gdlist.append('Card{}, PCIE ID: {}, Model: {}'.format(v.card_num, v.pcie_id, v.model))
                else:
                    gdlist.append('Card{}, PCIE ID: {}, Model: {}'.format(v.card_num, v.pcie_id, v.model))
        return gdlist

    def get_card_number_list(self, compute=False, energy=False):
        """
        This function returns a list of all valid card numbers. If compute is true, then only compute
        compatible cards are returned.  If energy is true then only compute compatible GPUs with energy capability
        are returned.
        :param compute: if True return list of compute capable cards
        :type compute: bool
        :param energy: if True return list of compute capable cards that are energy capable
        :type energy: bool
        :return: Returns a list of valid GPU card numbers
        :rtype: list
        """
        cnlist = []
        for k, v in self.list.items():
            if v.card_num >= 0:
                if compute:
                    if v.compute_compatible:
                        if mb_const.DEBUG: v.print()
                        cnlist.append(v.card_num)
                elif energy:
                    if v.compute_compatible and v.energy_compatible:
                        if mb_const.DEBUG: v.print()
                        cnlist.append(v.card_num)
                else:
                    cnlist.append(v.card_num)
        return cnlist


class BENCH_ENV:
    """
    benchMT environment parameters.
    """
    def __init__(self):
        self.time_now = ''
        self.time_now_short = ''
        self.hostname = ''
        self.platform = ''
        self.os_desc = ''
        self.cpu_model = ''
        self.cpu_mhz = ''
        self.total_cpu_threads = 0
        self.total_cpu_cores = 0
        self.specified_max_threads = 0
        self.total_gpu_threads = 0        # TODO currently total_gpu_threads = total_gpu_count, both needed for GPU SMT
        self.total_gpu_count = 0
        self.allocated_cthreads = 0
        self.allocated_gthreads = 0
        self.boinc_dev_list = []
        self.card_num_list = []
        self.specified_max_gpus = 0
        self.gpu_devices = []
        self.devmap = {}
        self.gpu_details = []
        self.current_dir = ''
        self.cpu_app_path = ''
        self.gpu_app_path = ''
        self.ref_app_path = ''
        self.ref_results_path = ''
        self.wu_path = ''
        self.wu_std_signal_path = ''
        self.testdata_path = ''
        self.slots_path = ''
        self.command_line_file = ''
        self.boinccmd = ''
        self.wucmpcmd = ''
        self.repetitions = 1
        self.summary_path = ''
        self.run_name = ''
        self.summary_file = ''
        self.sum_file_ptr = None
        self.psv_file = ''
        self.psv_file_ptr = None
        self.workdir_path = ''
        self.lockfile = ''
        self.mode_devmap = {}
        self.mode_gpu_devices = []
        self.mode_std_signals = False
        self.mode_display_slots = False
        self.mode_display_compact = False
        self.mode_no_ref = False
        self.mode_force_ref = False
        self.mode_energy = False
        self.mode_yes = False
        self.mode_noBS = False
        self.mode_astropulse = False
        self.boinc_home = mb_const.boinc_home
        self.init_data_template_file = ''

    def process_options(self, args, cfg_modes):
        """
        This function takes command line arguments and configuration modes to determine
        final operating mode of benchMT.  Command line args will over ride config file modes.
        :param args:  Command line arguments
        :param cfg_modes:  Config file modes
        :return: None
        :rtype: None
        """
        # mode_yes
        if args.yes: self.mode_yes = True
        elif cfg_modes.mode_value('yes'): self.mode_yes = True

        # mode_force_ref
        if args.force_ref: self.mode_force_ref = True
        elif cfg_modes.mode_value('force_ref'): self.mode_force_ref = True
    
        # mode_no_ref
        if args.no_ref: self.mode_no_ref = True
        elif cfg_modes.mode_value('no_ref'): self.mode_no_ref = True
    
        if self.mode_no_ref and self.mode_force_ref:
            print('ERROR: --no_ref and --force_ref are mutually exclusive.  Exiting...')
            sys.exit(-1)
    
        # mode_noBS
        if args.noBS: self.mode_noBS = True
        elif cfg_modes.mode_value('noBS'): self.mode_noBS = True
    
        # mode_std_signals
        if args.std_signals: self.mode_std_signals = True
        elif cfg_modes.mode_value('std_signals'): self.mode_std_signals = True
    
        # mode_display_compact
        if args.display_compact: self.mode_display_compact = True
        elif cfg_modes.mode_value('display_compact'): self.mode_display_compact = True
    
        # mode_display_slots
        if args.display_slots: self.mode_display_slots = True
        elif cfg_modes.mode_value('display_slots'): self.mode_display_slots = True
    
        # mode_energy
        if args.energy: self.mode_energy = True
        elif cfg_modes.mode_value('energy'): self.mode_energy = True
    
        # mode_astropulse
        if args.astropulse: self.mode_astropulse = True
        elif cfg_modes.mode_value('astropulse'): self.mode_astropulse = True
    
        # mode_boinc_home
        if len(args.boinc_home) > 0 and args.boinc_home.isprintable():
            self.boinc_home = args.boinc_home
        elif cfg_modes.mode_value('boinc_home'):
            if len(cfg_modes.mode_value('boinc_home')) > 0 and cfg_modes.mode_value('boinc_home').isprintable():
                self.boinc_home = cfg_modes.mode_value('boinc_home')
    
        # mode_run_name
        if len(args.run_name) > 0 and args.run_name.isprintable():
            self.run_name = args.run_name.replace(' ', '').replace('/', '').replace('\\', '')
        elif cfg_modes.mode_value('run_name'):
            if len(cfg_modes.mode_value('run_name')) > 0 and cfg_modes.mode_value('run_name').isprintable():
                self.run_name = cfg_modes.mode_value('run_name').replace(' ', '').replace('/', '').replace('\\', '')
    
        # mode_devmap
        specified_devmap = {}
        self.devmap = {}
        devmap_str = ''
        if len(args.devmap) > 0:
            devmap_str = args.devmap
        elif cfg_modes.mode_value('devmap'):
            devmap_str = cfg_modes.mode_value('devmap')
        if len(devmap_str) > 0:
            if re.fullmatch('([0-9]:[0-9],)*([0-9]:[0-9])+', devmap_str):
                gdev_items = devmap_str.split(',')
                for gi in gdev_items:
                    giItems = gi.split(':')
                    specified_devmap[int(giItems[0])] = int(giItems[1])
                self.devmap = specified_devmap
            else:
                print('Invalid devmap arg: [', devmap_str, ']')

        # mode_gpu_devices
        self.mode_gpu_devices = []
        gpu_devices_str = ''
        if len(args.gpu_devices) > 0:
            gpu_devices_str = args.gpu_devices
        elif cfg_modes.mode_value('gpu_devices'):
            gpu_devices_str = cfg_modes.mode_value('gpu_devices')
        if len(gpu_devices_str) > 0:
            if re.fullmatch('([0-9],)*([0-9])+', gpu_devices_str):
                gdev_items = gpu_devices_str.split(',')
                for gi in gdev_items:
                    self.mode_gpu_devices.append(int(gi))
            else:
                print('Invalid gpu_devices arg: [{}]'.format(gpu_devices_str))
    
        # mode_num_repetitions
        if args.num_repetitions > 0: self.repetitions = args.num_repetitions
        elif cfg_modes.mode_value('num_repetitions'):
            if int(cfg_modes.mode_value('num_repetitions')) > 0:
                self.repetitions = cfg_modes.mode_value('num_repetitions')
            else:
                print('CFG: Invalid number of repetitions specified [{}].  Ignoring...'.format(
                      str(cfg_modes.mode_value('num_repetitions'))))
        else:
            self.repetitions = 1

        # mode_max_threads
        self.specified_max_threads = -1
        if args.max_threads > 0: self.specified_max_threads = args.max_threads
        elif cfg_modes.mode_value('max_threads'):
            if cfg_modes.mode_value('max_threads') > 0:
                self.specified_max_threads = cfg_modes.mode_value('max_threads')
    
        # mode_max_gpus
        self.specified_max_gpus = -1
        if args.max_gpus > 0:
            self.specified_max_gpus = args.max_gpus
        elif cfg_modes.mode_value('max_gpus'):
            if cfg_modes.mode_value('max_gpus') > 0:
                self.specified_max_gpus = cfg_modes.mode_value('max_gpus')

    @staticmethod
    def check_env():
        """
        Return 0 if all good, -1 if python version issue, -2 if OS issue, -3 if system command issue.
        :return:  Integer check code
        :rtype: int
        """
        # Check python version
        required_pversion = [3, 6]
        (python_major, python_minor, python_patch) = platform.python_version_tuple()
        if mb_const.DEBUG: print('Using python ' + python_major + '.' + python_minor + '.' + python_patch)
        if int(python_major) < required_pversion[0]:
            print('Using python' + python_major + ', but ' + __program_name__ + ' requires python ' +
                  str(required_pversion[0]) + '.' + str(required_pversion[1]) + ' or higher.',
                  file=sys.stderr)
            return -1
        elif int(python_major) == required_pversion[0] and int(python_minor) < required_pversion[1]:
            print('Using python ' + python_major + '.' + python_minor + '.' + python_patch + ', but ' +
                  __program_name__ + ' requires python ' + str(required_pversion[0]) + '.' +
                  str(required_pversion[1]) + ' or higher.', file=sys.stderr)
            return -1

        # Check Linux Kernel version
        required_kversion = [4, 8]
        linux_version = platform.release()
        if int(linux_version.split('.')[0]) < required_kversion[0]:
            print('Using Linux Kernel ' + linux_version + ', but ' + __program_name__ + ' requires > ' +
                  str(required_kversion[0]) + '.' + str(required_kversion[1]), file=sys.stderr)
            return -2
        elif int(linux_version.split('.')[0]) == required_kversion[0] and \
                                              int(linux_version.split('.')[1]) < required_kversion[1]:
            print('Using Linux Kernel ' + linux_version + ', but ' + __program_name__ + ' requires > ' +
                  str(required_kversion[0]) + '.' + str(required_kversion[1]), file=sys.stderr)
            return -2

        # Check access/paths to system commands
        command_access_fail = False
        mb_const.cmd_lspci = shutil.which('lspci')
        if not mb_const.cmd_lspci:
            print('OS command [lspci] executable not found.')
            command_access_fail = True
        mb_const.cmd_lshw = shutil.which('lshw')
        if not mb_const.cmd_lshw:
            print('OS command [lshw] executable not found.')
            command_access_fail = True
        mb_const.cmd_lscpu = shutil.which('lscpu')
        if not mb_const.cmd_lscpu:
            print('OS command [lscpu] executable not found.')
            command_access_fail = True
        mb_const.cmd_clinfo = shutil.which('clinfo')
        if not mb_const.cmd_clinfo:
            print('Package addon [clinfo] executable not found.  Use sudo apt-get install clinfo to install')
        mb_const.cmd_time = shutil.which('time')
        if not mb_const.cmd_time:
            print('OS command [time] executable not found.')
            command_access_fail = True
        mb_const.cmd_nvidia_smi = shutil.which('nvidia-smi')
        if not mb_const.cmd_nvidia_smi:
            print('Package addon [nvidia-smi] executable not found.')
        mb_const.cmd_lsb_release = shutil.which('lsb_release')
        if not mb_const.cmd_lsb_release:
            print('OS command [lsb_release] executable not found.')
            command_access_fail = True
        if command_access_fail:
            return -3
        return 0

    def set_env(self):
        """
        Setup the working environment to run benchmarks
                - Get time and system parameters
                - Use standard subdirectory and filenames in the mb_const class
                - Verify all required directories and files exist
        :return: True if all files and directories exist, else False
        :rtype: bool
        """
        valid = True
        t = datetime.utcnow()
        self.time_now = t.strftime('%c')
        self.time_now_short = t.strftime('%m%d_%H%M%S')
        self.hostname = socket.gethostname()
        self.platform = platform.system() + ' ' + platform.release()

        # Get OS details
        if not mb_const.cmd_lsb_release:
            print('OS Command [lsb_release] not found', file=sys.stderr)
            valid = False
        else:
            cmd_str = '{} -a 2>/dev/null'.format(mb_const.cmd_lsb_release)
            try:
                cmd = subprocess.Popen(cmd_str, shell=True, stdout=subprocess.PIPE)
                for line in cmd.stdout:
                    linestr = line.decode('utf-8').strip()
                    searchObj = re.search('Description', linestr)
                    if searchObj:
                        lineItem = linestr.split(':')
                        self.os_desc = lineItem[1].strip()
                        cmd.stdout.close()
                        break
            except:
                print('Warning: can not determine OS', file=sys.stderr)
                self.os_desc = 'UNKNOWN'

        # Get CPU details
        if not mb_const.cmd_lscpu:
            print('OS Command [lscpu] not found')
            valid = False
        else:
            cpu_max_mhz = ''
            cmd_str = '{} 2>/dev/null'.format(mb_const.cmd_lscpu)
            try:
                cmd = subprocess.Popen(cmd_str, shell=True, stdout=subprocess.PIPE)
                for line in cmd.stdout:
                    linestr = line.decode('utf-8').strip()
                    searchObj = re.search('Model name', linestr)
                    if searchObj:
                        lineItem = linestr.split(':')
                        self.cpu_model = lineItem[1].strip()
                        continue
                    searchObj = re.search('CPU max MHz', linestr)
                    if searchObj:
                        lineItem = linestr.split(':')
                        cpu_max_mhz = lineItem[1].strip()
                        continue
                    searchObj = re.search('CPU MHz', linestr)
                    if searchObj:
                        lineItem = linestr.split(':')
                        cpu_mhz = lineItem[1].strip()
                        continue
                if cpu_max_mhz == '':
                    self.cpu_mhz = cpu_mhz
                else:
                    self.cpu_mhz = cpu_max_mhz
                cmd.stdout.close()
            except:
                print('Warning: can not determine CPU details', file=sys.stderr)
                self.cpu_model = 'UNKNOWN'
                cpu_max_mhz = 'UNKNOWN'
                cpu_mhz = 'UNKNOWN'

            # Get CPU details
            cmd_str = '{} -e 2>/dev/null | tail -1'.format(mb_const.cmd_lscpu)
            try:
                cmd = subprocess.Popen(cmd_str, shell=True, stdout=subprocess.PIPE)
                for line in cmd.stdout:
                    linestr = line.decode('utf-8').strip()
                    lineItem = linestr.split()
                    self.total_cpu_threads = int(lineItem[0].strip()) + 1
                    self.total_cpu_cores = int(lineItem[3].strip()) + 1
                cmd.stdout.close()
            except:
                print('Error: can not determine CPU core details', file=sys.stderr)
                valid = False

        # Set working directories
        self.current_dir = os.getcwd() + '/'
        self.workdir_path = os.path.join(self.current_dir, mb_const.workdir_subdir)
        self.cpu_app_path = os.path.join(self.current_dir, mb_const.cpu_app_subdir)
        self.gpu_app_path = os.path.join(self.current_dir, mb_const.gpu_app_subdir)
        self.ref_app_path = os.path.join(self.current_dir, mb_const.ref_app_subdir)
        self.wu_path = os.path.join(self.current_dir, mb_const.wu_subdir)
        self.wu_std_signal_path = os.path.join(self.current_dir, mb_const.std_signal_subdir)
        self.testdata_path = os.path.join(self.current_dir, mb_const.testdata_subdir)
        self.ref_results_path = os.path.join(self.ref_app_path, mb_const.ref_results_subdir)
        self.slots_path = os.path.join(self.workdir_path, mb_const.slots_subdir)
        self.lockfile = self.workdir_path + '.benchMTlockfile'
        self.summary_path = os.path.join(self.testdata_path,
                                         (self.hostname + '_benchMT_' + self.run_name + '_' + self.time_now_short))
        self.summary_file = self.summary_path + self.hostname + '.testlog.' + self.time_now_short + '.txt'
        self.init_data_template_file = self.workdir_path + mb_const.template_file
        self.psv_file = self.summary_path + self.hostname + '.timelog.' + self.time_now_short + '.psv'

        # Check working directories
        if not os.path.isdir(self.workdir_path):
            print('benchMT workdir Path [', self.workdir_path, '] does not exist, making...')
            os.mkdir(self.workdir_path)
            if not os.path.isdir(self.workdir_path):
                print('Failed to make benchMT workdir Path [', self.workdir_path, ']')
                valid = False
        if not os.path.isdir(self.testdata_path):
            print('TestData Path [', self.testdata_path, '] does not exist, making...')
            os.mkdir(self.testdata_path)
            if not os.path.isdir(self.testdata_path):
                print('Failed to make TestData Path [', self.testdata_path, ']')
                valid = False
        if not os.path.isdir(self.cpu_app_path):
            print('CPU APP Path [', self.cpu_app_path, '] does not exist')
            valid = False
        if not os.path.isdir(self.ref_app_path):
            print('REFERENCE APP Path [', self.ref_app_path, '] does not exist')
            valid = False
        if not os.path.isdir(self.ref_results_path):
            print('REFERENCE RESULTS Path [', self.ref_results_path, '] does not exist')
            valid = False
        if not os.path.isdir(self.gpu_app_path):
            print('GPU APP Path [', self.gpu_app_path, '] does not exist')
            valid = False
        if not os.path.isdir(self.wu_path):
            print('WU Path [', self.wu_path, '] does not exist')
            valid = False
        if not os.path.isdir(self.wu_std_signal_path):
            print('STD SIGNAL WU Path [', self.wu_std_signal_path, '] does not exist')
            valid = False
        # Set CFG file location
        self.command_line_file = os.path.join(self.current_dir, mb_const.command_line_filename)
        if not os.path.isfile(self.command_line_file):
            print('BenchCFG [', self.command_line_file, '] does not exist.')
            valid = False
        return valid

    def set_env_boinc(self):
        """
        Set boinc environment components.
        :return:  True if all ok
        :rtype: bool
        """
        valid = True
        if not mb_const.noBS:
            if not os.path.isdir(self.boinc_home):
                print('BOINC Home Path [', self.boinc_home, '] does not exist')
                print('Please set the correct BOINC Home Path with the --boinc_home command line option')
                valid = False

        self.wucmpcmd = os.path.join(self.current_dir, mb_const.wu_cmp)
        if not os.path.isfile(self.wucmpcmd):
            print('Results Compare Utility [', self.wucmpcmd, '] does not exist')
            valid = False
        if not mb_const.noBS:
            self.boinccmd = os.path.join(self.boinc_home, mb_const.boinccmd)
            if not os.path.isfile(self.boinccmd):
                print('boinccmd [', self.boinccmd, '] does not exist')
                valid = False
        if not os.path.isfile(self.init_data_template_file):
            print('init_data.xml_template file [', self.init_data_template_file, '] does not exist, creating...')
            with open(self.init_data_template_file, 'w') as fileptr:
                print('<app_init_data>', file=fileptr)
                print('<app_name>setiathome_v8</app_name>', file=fileptr)
                print('<project_dir>' + self.workdir_path + '</project_dir>', file=fileptr)
                print('<boinc_dir>' + self.boinc_home + '</boinc_dir>', file=fileptr)
                print('</app_init_data>', file=fileptr)
        return valid

    def purge_workdir_cache(self):
        """
        Purge openCL kernels from working directory.
        :return: None
        :rtype: None
        """
        if not os.path.isdir(self.workdir_path):
            print('benchMT workdir Path [{}] does not exist, can not purge cache...'.format(self.workdir_path))
        else:
            print('Purging cached kernels from: [{}]'.format(self.workdir_path))
        for file_str in glob.glob(self.workdir_path + 'MB_clFFTplan*'):
            os.remove(file_str)
            print('Removed: {}'.format(file_str))
        for file_str in glob.glob(self.workdir_path + 'MultiBeam_Kernels*.cl[0-9,a-z,A-Z]*'):
            os.remove(file_str)
            print('Removed: {}'.format(file_str))

    def makedirs(self):
        """
        Check existence of required directories and make if missing
        :return: None
        :rtype: None
        """
        # Check/Make working directories
        if not os.path.isdir(self.cpu_app_path):
            print('CPU APP Path [', self.cpu_app_path, '] does not exist, making...')
            os.mkdir(self.cpu_app_path)
        if not os.path.isdir(self.gpu_app_path):
            print('GPU APP Path [', self.gpu_app_path, '] does not exist, making...')
            os.mkdir(self.gpu_app_path)
        if not os.path.isdir(self.ref_app_path):
            print('REFERENCE APP Path [', self.ref_app_path, '] does not exist, making...')
            os.mkdir(self.ref_app_path)
        if not os.path.isdir(self.ref_results_path):
            print('REFERENCE RESULTS Path [', self.ref_results_path, '] does not exist, making...')
            os.mkdir(self.ref_results_path)
        if not os.path.isdir(self.wu_path):
            print('WU Path [', self.wu_path, '] does not exist, making...')
            os.mkdir(self.wu_path)
        if not os.path.isdir(self.wu_std_signal_path):
            print('STD SIGNAL WU Path [', self.wu_std_signal_path, '] does not exist, making...')
            os.mkdir(self.wu_std_signal_path)
        if not os.path.isdir(self.testdata_path):
            print('TestData Path [', self.testdata_path, '] does not exist, making...')
            os.mkdir(self.testdata_path)

    def is_bench_conflict(self):
        """
        Return true if there is another instance running.  Check lock file for pid
        if there is a valid process with that pid, then there is a conflict.
        if no conflict, then write current pid to lockfile and return false
        :return: True if there is a conflict
        :rtype: bool
        """
        mypid = os.getpid()
        if not os.path.isfile(self.lockfile):
            # No lockfile, so assume no conflict
            with open(self.lockfile, 'w') as file_ptr:
                print(str(mypid), file=file_ptr)
            return False
        else:
            with open(self.lockfile, 'r') as file_ptr:
                line = file_ptr.readline().strip()
            if line.isdigit():
                pid = int(line)
                try:
                    os.kill(pid, 0)
                except OSError:
                    # Not running
                    with open(self.lockfile, 'w') as file_ptr:
                        print(str(mypid), file=file_ptr)
                    return False
                else:
                    # Running
                    return True

    @staticmethod
    def is_boinc_running():
        """
        Check if boinc is running.
        :return: True if running
        :rtype: bool
        """
        cmd_str = 'ps -C boinc -o pid 2>/dev/null'
        try:
            cmd = subprocess.Popen(cmd_str, shell=True, stdout=subprocess.PIPE)
            output = cmd.stdout.read()
            cmd.stdout.close()
            cmd.wait()
            if output.decode('utf-8').strip() == 'PID':
                return False
            else:
                return True
        except:
            print('Warning: can not check if boinc is running', file=sys.stderr)
            return True

    def suspend_boinc(self):
        """
        Run boinc suspend script
        :return: None
        :rtype: None
        """
        if not self.is_boinc_running():
            print('boinc is not running, skip suspend')
            return
        cwd = os.getcwd()
        os.chdir(self.boinc_home)
        for cmd_str in mb_const.suspend_args:
            cmd_str = self.boinc_home + str(cmd_str)
            if mb_const.DEBUG: print('Suspend cmd: ', cmd_str)
            try:
                cmd = subprocess.Popen(shlex.split(cmd_str), shell=False, stdout=subprocess.PIPE)
                while True:
                    if cmd.poll() is not None:
                        break
                    time.sleep(1)
            except:
                print('Error: could not execute boinccmd: {}'.format(cmd_str), file=sys.stderr)
        os.chdir(cwd)

    def resume_boinc(self):
        """
        Run boinc resume script
        :return: None
        :rtype: None
        """
        if not self.is_boinc_running():
            print('boinc is not running, skip resume')
            return
        cwd = os.getcwd()
        os.chdir(self.boinc_home)
        for cmd_str in mb_const.resume_args:
            cmd_str = self.boinc_home + str(cmd_str)
            if mb_const.DEBUG: print('Resume cmd: ', cmd_str)
            try:
                cmd = subprocess.Popen(shlex.split(cmd_str), shell=False, stdout=subprocess.PIPE)
                while True:
                    if cmd.poll() is not None:
                        break
                    time.sleep(1)
            except:
                print('Error: could not execute boinccmd: {}'.format(cmd_str), file=sys.stderr)
        os.chdir(cwd)
        
    def print(self, fileptr=sys.stdout):
        """
        Print all environment details.
        :return: None
        :rtype: None
        """
        print('Hostname: ', self.hostname, file=fileptr)
        print('Run Name: ', self.run_name, file=fileptr)
        if self.mode_astropulse:
            print('APP Mode: ', 'AstroPulse', file=fileptr)
        else:
            print('APP Mode: ', 'MultiBeam', file=fileptr)
        print('benchMT version: ', __version__, file=fileptr)
        print('Platform: ', self.platform, file=fileptr)
        print('OS Description: ', self.os_desc, file=fileptr)
        print('CPU Model: ', self.cpu_model, file=fileptr)
        print('CPU MHz: ', self.cpu_mhz, file=fileptr)
        print('CPU Cores: ', self.total_cpu_cores, file=fileptr)
        print('CPU Threads: ', self.total_cpu_threads, file=fileptr)
        print('GPU Count: ', self.total_gpu_count, file=fileptr)
        print('GPU Threads: ', self.total_gpu_threads, file=fileptr)
        print('Specified GPU Device List: ', str(self.gpu_devices), file=fileptr)
        print('Devices Map: ', str(self.devmap), file=fileptr)
        print('BOINC Device List: ', str(self.boinc_dev_list), file=fileptr)
        print('GPU Card Number List: ', str(self.card_num_list), file=fileptr)
        print('GPU Details: ', file=fileptr)
        for gpi in self.gpu_details:
            print('    {}'.format(gpi), file=fileptr)
        print('Current Dir: ', self.current_dir, file=fileptr)
        print('Slots Dir: ', self.slots_path, file=fileptr)
        print('TimeNow: ', self.time_now, file=fileptr)
        print('TimeNowShort: ', self.time_now_short, file=fileptr)
        print('CPU App Path: ', self.cpu_app_path, file=fileptr)
        print('GPU App Path: ', self.gpu_app_path, file=fileptr)
        print('REF App Path: ', self.ref_app_path, file=fileptr)
        print('Reference Results Path: ', self.ref_results_path, file=fileptr)
        print('STD Signal WU Path: ', self.wu_std_signal_path, file=fileptr)
        print('WU Path: ', self.wu_path, file=fileptr)
        print('Test Data Path: ', self.testdata_path, file=fileptr)
        print('BOINC Home: ', self.boinc_home, file=fileptr)
        print('Repetitions: ', self.repetitions, file=fileptr)
        print('Allocated CPU Threads: ', self.allocated_cthreads, file=fileptr)
        print('Allocated GPU Threads: ', self.allocated_gthreads, file=fileptr)
        # Print Modes
        print('Mode {}: {}'.format('yes', self.mode_yes), file=fileptr)
        print('Mode {}: {}'.format('noBS', self.mode_noBS), file=fileptr)
        print('Mode {}: {}'.format('std_signals', self.mode_std_signals), file=fileptr)
        print('Mode {}: {}'.format('display_slots', self.mode_display_slots), file=fileptr)
        print('Mode {}: {}'.format('display_compact', self.mode_display_compact), file=fileptr)
        print('Mode {}: {}'.format('no_ref', self.mode_no_ref), file=fileptr)
        print('Mode {}: {}'.format('force_ref', self.mode_force_ref), file=fileptr)
        print('Mode {}: {}'.format('energy', self.mode_energy), file=fileptr)
        print('Mode {}: {}'.format('astropulse', self.mode_astropulse), file=fileptr)


class BENCH_JOB:
    """
    Object which represents a processing job.
    """
    def __init__(self, item_id):
        self.uuid = item_id
        self.cmd = ''
        self.slot = None
        self.start_time = 'not started'
        self.complete_time = 'not started'
        self.exit_status = ''
        self.state = 'PENDING'              # PENDING, ACTIVE, COMPLETE
        self.app_name = ''
        self.app_args = ''
        self.platform = 'UNKNOWN'           # UNKNOWN, CPU, GPU
        self.wu_name = 'not assigned'
        self.wu_path = 'not assigned'
        self.error = ''
        self.slot_dir = ''
        self.similarity = 'UNKNOWN'
        self.q_value = 'UNKNOWN'
        self.angle_range = 0.0
        self.cnt_spike = 0
        self.cnt_autocorr = 0
        self.cnt_pulse = 0
        self.cnt_triplet = 0
        self.cnt_gaussian = 0
        self.time_real = -1
        self.time_user = -1
        self.time_system = -1
        self.time_maxmem = -1
        self.time_swapnum = -1
        self.time_ctxswt = -1
        self.time_majpf = -1
        self.energy = -1

    def copy(self, src):
        """
        Copy a BENCH_JOB object to self.
        :param src:
        :type src: BENCH_JOB
        :return: None
        """
        # Don't copy uuid self.uuid = item_id src.uuid
        self.cmd = src.cmd 
        self.start_time = src.start_time 
        self.complete_time = src.complete_time
        self.exit_status = src.exit_status
        self.state = src.state
        self.app_name = src.app_name
        self.app_args = src.app_args
        self.platform = src.platform
        self.wu_name = src.wu_name
        self.wu_path = src.wu_path
        self.error = src.error
        self.slot_dir = src.slot_dir
        self.similarity = src.similarity
        self.q_value = src.q_value
        self.angle_range = src.angle_range
        self.cnt_spike = src.cnt_spike
        self.cnt_autocorr = src.cnt_autocorr
        self.cnt_pulse = src.cnt_pulse
        self.cnt_triplet = src.cnt_triplet
        self.cnt_gaussian = src.cnt_gaussian
        self.time_real = src.time_real
        self.time_user = src.time_user
        self.time_system = src.time_system
        self.time_maxmem = src.time_maxmem
        self.time_swapnum = src.time_swapnum
        self.time_ctxswt = src.time_ctxswt
        self.time_majpf = src.time_majpf


class JOB_LIST:
    """
    An object that aggregates jobs.
    """
    def __init__(self):
        self.list = {}

    def read_benchcfg(self, env, modes):
        """
        Read the default benchCFG file or one specified by user on command line.  Extract
        modes, app_names and app_args
        :param env:
        :type env: BENCH_ENV
        :param modes:
        :type modes: CFG_MODES
        :return:  None
        """
        with open(env.command_line_file, 'r') as clfptr:
            for line in clfptr:
                line = line.strip()
                if len(line) == 0: continue
                if line[0] == '#': continue
                if len(line) < 2: continue
                lineitems = line.split(maxsplit=1)

                # check if entry is a mode item
                if lineitems[0] == 'mode':
                    modeitems = lineitems[1].split(maxsplit=2)
                    if len(modeitems) < 2: continue
                    # process mode
                    mode_name = modeitems[0].strip()
                    mode_value = modeitems[1].strip()
                    if not modes.set_mode(mode_name, mode_value):
                        print('Invalid mode specified in CFG file: [', mode_name, '][', mode_value, ']', sep='')
                    else:
                        print('Read valid mode from CFG file: [', mode_name, '][', mode_value, ']', sep='')
                    continue

                # process appname and apparg
                job = BENCH_JOB(uuid4().hex)
                job.app_name = lineitems[0]
                if len(lineitems) > 1:
                    argstr = lineitems[1]
                    searchObj = re.search(r'[-]+[dD]evice\s+[0-9]+', argstr)
                    if searchObj:
                        argstr = re.sub(r'[-]+[dD]evice\s+[0-9]+', '', argstr)
                        print(lineitems[1])
                        print('Removed [-device X] argument as conflicts with slot assignment process')
                        print(argstr)
                    job.app_args = argstr
                else:
                    job.app_args = ''

                # print(env.cpu_app_path + job.app_name)
                if os.path.isfile(env.cpu_app_path + job.app_name):
                    job.platform = 'CPU'
                elif os.path.isfile(env.gpu_app_path + job.app_name):
                    job.platform = 'GPU'
                else:
                    job.platform = 'UNKNOWN'
                self.list[job.uuid] = job

    def read_wu_list(self, env):
        """
        Prepare a list of WUs based on the contents of the wu_path or std_signal_path
        depending on command line arguments or CFG mode settings
        :param env: environment object
        :type env: BENCH_ENV
        :return: None
        """
        if env.mode_std_signals:
            wu_path = env.wu_std_signal_path
        else:
            wu_path = env.wu_path
        filelist = os.listdir(path=wu_path)
        for line in filelist:
            line = line.strip()
            if line.endswith('.wu'):
                job = BENCH_JOB(uuid4().hex)
                job.wu_name = line
                job.wu_path = wu_path
                self.list[job.uuid] = job

    def create_ref_list(self, ref_app, wulist):
        """
        Create a reference job entry for every WU found using the specified
        ref_app.  Set state to pending.
        :param ref_app: A bench job object for reference app
        :type ref_app: BENCH_JOB
        :param wulist:  Work unit job list
        :type wulist:  JOB_LIST
        :return:  None
        """
        for wu_key, wu_value in wulist.list.items():
            job = BENCH_JOB(uuid4().hex)
            job.copy(ref_app)
            job.platform = 'REF'
            job.state = 'PENDING'
            job.wu_name = wu_value.wu_name
            job.wu_path = wu_value.wu_path
            self.list[job.uuid] = job

    def check_ref_results(self, env):
        """
        Check if ref_file exist for each ref_job in the list.
        If it exists, change status from PENDING to COMPLETE
        :param env:  environment
        :type env: BENCH_ENV
        :return: None
        """
        for k, v in self.list.items():
            ref_app_name = v.app_name.replace('ref-cpu.', '')
            ref_file_name = env.ref_results_path + 'ref-result.' + ref_app_name + '.' + v.wu_name + '.sah'
            if os.path.isfile(ref_file_name):
                v.state = 'COMPLETE'
                v.start_time = 'NA'
                v.complete_time = 'NA'

    def create_job_list(self, applist, wulist, env):
        """
        Based on a list of apps and a list of WUs, create an job list which uses every app
        to run every WU.
        :param applist: Application List
        :type applist: JOB_LIST
        :param wulist:  Work Unit List
        :type wulist: JOB_LIST
        :param env: Environment
        :type env: BENCH_ENV
        :return: None
        """
        for i in range(0, env.repetitions):
            for wu_key, wu_value in wulist.list.items():
                for app_key, app_value in applist.list.items():
                    if app_value.platform != 'UNKNOWN':
                        job = BENCH_JOB(uuid4().hex)
                        job.copy(app_value)
                        job.state = 'PENDING'
                        job.wu_name = wu_value.wu_name
                        job.wu_path = wu_value.wu_path
                        self.list[job.uuid] = job

    def append_job_list(self, newlist):
        """
        Append jobs in newlist to self, but check if jobs are already in self
        :param newlist:  Job list to be appended to self
        :type newlist: JOB_LIST
        :return: None
        """
        for nl_key, nl_value in newlist.list.items():
            if nl_key in self.list.keys():
                # SKIP if new Job is already in the list
                continue
            else:
                self.list[nl_value.uuid] = nl_value

    def print(self, compact_flag=False, show_skipped=False, fileptr=sys.stdout, title=''):
        """
        Output formatted job list table.
        :param compact_flag: Use compact format if true
        :type compact_flag: bool
        :param show_skipped:  show skipped jobs if true
        :type show_skipped: bool
        :param fileptr: Output fileptr
        :type fileptr: file
        :param title:  Title of the table
        :type title: str
        :return: None
        """
        # Print is optimized for 112 columns
        i = 0
        num_jobs = self.jobcount_bystatus()
        if title == '':
            print('\n   ' + str(num_jobs['COMPLETE']) + ' of ' + str(num_jobs['TOTAL']) +
                  ' jobs complete\n', file=fileptr)
        else:
            print('\n   ' + title)
        print(''.ljust(5, ''), ''.ljust(4, ''), ''.ljust(3, ''),  ''.ljust(60, ''),
              ''.ljust(8, ''),  ''.ljust(8, ''), ''.ljust(11, ''),
              ''.ljust(8, '') + '', file=fileptr, sep='')

        if fileptr == sys.stdout:
            print('' + '\x1b[1;36m' + 'Job#'.ljust(4, ' ') + '\x1b[0m',
                  '\x1b[1;36m' + 'Slot'.ljust(4, ' ') + '\x1b[0m',
                  '\x1b[1;36m' + 'xPU'.ljust(3, ' ') + '\x1b[0m',
                  '\x1b[1;36m' + 'app_name'.ljust(60, ' ') + '\x1b[0m',
                  '\x1b[1;36m' + '  start'.ljust(8, ' ') + '\x1b[0m',
                  '\x1b[1;36m' + ' finish'.ljust(8, ' ') + '\x1b[0m',
                  '\x1b[1;36m' + 'tot_time'.ljust(11, ' ') + '\x1b[0m',
                  '\x1b[1;36m' + ' state'.ljust(8, ' ') + '\x1b[0m' + '', file=fileptr, sep='')
            print('' + '\x1b[1;36m' + ' '.ljust(4, ' ') + '\x1b[0m',
                  '\x1b[1;36m' + ' '.ljust(4, ' ') + '\x1b[0m',
                  '\x1b[1;36m' + ' '.ljust(3, ' ') + '\x1b[0m',
                  '\x1b[1;36m' + 'app_args'.ljust(60, ' ') + '\x1b[0m',
                  '\x1b[1;36m' + 'wu_name'.ljust(38, ' ') + '\x1b[0m' + '', file=fileptr, sep='')
        else:
            print('Job#'.ljust(5, ' '), 'Slot'.ljust(4, ' '), 'xPU'.ljust(3, ' '), 'app_name'.ljust(60, ' '),
                  '  start'.ljust(8, ' '), ' finish'.ljust(8, ' '), 'tot_time'.ljust(11, ' '),
                  ' state'.ljust(8, ' ') + '', file=fileptr, sep='')
            print(''.ljust(5, ' '), ' '.ljust(4, ' '), ' '.ljust(3, ' '), 'app_args'.ljust(60, ' '),
                  'wu_name'.ljust(38, ' ') + '', file=fileptr, sep='')

        for k, v in self.list.items():
            if v.slot is None:
                slot_str = ' NA'
            else:
                slot_str = ' ' + str(v.slot)

            if (v.state == 'ACTIVE' or v.state == 'COMPLETE') and v.start_time != 'NA':
                start_time_str = v.start_time.strftime('%H:%M:%S')
            elif v.start_time == 'NA':
                start_time_str = 'SKIPPED'
                if not show_skipped: continue
            else:
                start_time_str = '  NA  '

            if v.state == 'COMPLETE' and v.start_time != 'NA':
                complete_time_str = v.complete_time.strftime('%H:%M:%S')
                elapsed_time = v.complete_time - v.start_time
            elif v.start_time == 'NA':
                complete_time_str = 'SKIPPED'
                elapsed_time = 'SKIPPED'
                if not show_skipped: continue
            else:
                complete_time_str = '  NA  '
                elapsed_time = '  NA  '

            # if printing to stdout, use state colors
            if fileptr == sys.stdout:
                if v.state == 'ACTIVE':
                    # Blue
                    state_str = '\x1b[1;37;44m' + v.state.ljust(8, ' ')[:8] + '\x1b[0m'
                elif v.state == 'PENDING':
                    # Yellow
                    state_str = '\x1b[1;30;43m' + v.state.ljust(8, ' ')[:8] + '\x1b[0m'
                elif v.state == 'COMPLETE' and (v.exit_status == 0 or v.exit_status == ''):
                    # Green
                    state_str = '\x1b[1;30;42m' + v.state.ljust(8, ' ')[:8] + '\x1b[0m'
                elif v.state == 'COMPLETE':
                    # Red
                    state_str = '\x1b[1;37;41m' + ' ERROR'.ljust(8, ' ')[:8] + '\x1b[0m'
            else:
                if v.exit_status == 0 or v.exit_status == '':
                    state_str = v.state.ljust(8, ' ')[:8]
                else:
                    state_str = ' ERROR'.ljust(8, ' ')[:8]

            if not compact_flag:
                print(''.ljust(5, ''), ''.ljust(4, ''), ''.ljust(3, ''), ''.ljust(60, ''),
                      ''.ljust(8, '') + '' + ''.ljust(8, '') + '' + ''.ljust(11, '') + '' +
                      ''.ljust(8, '') + '', file=fileptr, sep='')
            print('' + str(i).ljust(4, ' '), slot_str.ljust(4, ' '), v.platform.ljust(3, ' ')[:3],
                  v.app_name.ljust(60, ' ')[:60], start_time_str.ljust(8, ' '), complete_time_str.ljust(8, ' '),
                  str(elapsed_time).ljust(11, ' ')[:11], state_str + '', file=fileptr, sep='')
            print('' + ' '.ljust(4, ' '), ' '.ljust(4, ' '), ' '.ljust(3, ' ')[:3], v.app_args.ljust(60, ' ')[:60],
                  v.wu_name.ljust(38, ' ')[:38] + '', file=fileptr, sep='')
            i += 1

        print(''.ljust(5, ''), ''.ljust(4, ''), ''.ljust(3, ''),  ''.ljust(60, ''),
              ''.ljust(8, '') + '' + ''.ljust(8, '') + '' + ''.ljust(11, '') + '' +
              ''.ljust(8, '') + '', file=fileptr, sep='')

    def print_app_names(self, fileptr=sys.stdout):
        """
        Output app names for given job list.
        :param fileptr: fileptr for output, default is stdout
        :type fileptr: file
        :return: None
        """
        for k, v in self.list.items():
            print(v.app_name, file=fileptr)

    def print_wu_names(self, fileptr=sys.stdout):
        """
        Output work unit names for given job list.
        :param fileptr: fileptr for output, default is stdout
        :type fileptr: file
        :return: None
        """
        for k, v in self.list.items():
            print(v.wu_name, file=fileptr)

    def psv_print(self, env, fileptr=sys.stdout):
        """
        Output self to psv file or stdout bu default.
        :param env:  environment
        :type env: BENCH_ENV
        :param fileptr: fileptr for output, default is stdout
        :type fileptr: file
        :return: None
        """
        print('Host', 'RunName', 'CPU', 'CPU-MHz', 'JobID', 'Platform', 'app_name', 'app_args', 'wu_name',
              'angle_range', 'spike_cnt', 'autocorr_cnt', 'pulse_cnt', 'triplet_cnt', 'gaussian_cnt', 'start_time',
              'complete_time', 'elapsed_time', 'real_time', 'user_time', 'sys_time', 'energy', 'maxmem', 'swapnum',
              'ctxswt', 'majpf', 'state', 'Q', 'similarity', 'error', file=fileptr, sep='|')
        for k, v in self.list.items():
            if (v.state == 'ACTIVE' or v.state == 'COMPLETE') and v.start_time != 'NA':
                start_time_str = v.start_time.strftime('%H:%M:%S')
            else:
                start_time_str = 'SKIPPED'
                # don't output skipped items to the psv file
                continue
            if v.state == 'COMPLETE' and v.start_time != 'NA':
                complete_time_str = v.complete_time.strftime('%H:%M:%S')
                elapsed_time = v.complete_time - v.start_time
            else:
                complete_time_str = 'SKIPPED'
                elapsed_time = 'SKIPPED'
            if v.error == '':
                error_str = 'None'
            else:
                error_str = v.error
            if env.run_name == '':
                psv_run_name = 'NA'
            else:
                psv_run_name = env.run_name
                
            print(env.hostname, psv_run_name, env.cpu_model, env.cpu_mhz, v.uuid, v.platform, v.app_name, v.app_args,
                  v.wu_name, v.angle_range, v.cnt_spike, v.cnt_autocorr, v.cnt_pulse, v.cnt_triplet,
                  v.cnt_gaussian, start_time_str, complete_time_str, elapsed_time, v.time_real,
                  v.time_user, v.time_system, v.energy, v.time_maxmem, v.time_swapnum, v.time_ctxswt, v.time_majpf,
                  v.state, v.q_value, v.similarity, error_str, file=fileptr, sep='|')

    def jobcount_bystatus(self):
        """
        Return a dictionary of job counts with status as keys.
        :return: dictionary with job counts by status.
        :rtype: dict
        """
        num_pending_jobs = {'PENDING': 0, 'COMPLETE': 0, 'ACTIVE': 0, 'TOTAL': 0}
        for k, v in self.list.items():
            num_pending_jobs[v.state] += 1
            num_pending_jobs['TOTAL'] += 1
        return num_pending_jobs

    def pending_pjobs(self):
        """
        Return a dictionary of pending job counts with type as keys.
        :return: dictionary with pending job counts by type.
        :rtype: dict
        """
        num_pending_jobs = {'GPU': 0, 'CPU': 0, 'REF': 0}
        for k, v in self.list.items():
            if v.state == 'PENDING':
                num_pending_jobs[v.platform] += 1
        return num_pending_jobs

    def pending_jobs(self):
        """
        Return count of pending jobs.
        :return: pending job count
        :rtype: int
        """
        num_pending_jobs = 0
        for k, v in self.list.items():
            if v.state == 'PENDING':
                num_pending_jobs += 1
        return num_pending_jobs

    def all_complete(self, platform=''):
        """
        Check if all jobs are complete. If platform is specified, then check is limited to that platform.
        :param platform:  The target platform, all if not specified
        :type platform: str
        :return:  True if all jobs complete
        :rtype: bool
        """
        for k, v in self.list.items():
            if platform != '':
                if v.platform != platform:
                    continue
            if v.state != 'COMPLETE':
                return False
        return True

    def num_cpu_jobs(self):
        """
        Return the number of cpu jobs.
        :return: Number of cpu jobs
        :rtype: int
        """
        cnt = 0
        for k, v in self.list.items():
            if v.platform == 'CPU' or v.platform == 'REF':
                cnt += 1
        return cnt

    def num_gpu_jobs(self):
        """
        Return the number of gpu jobs.
        :return: Number of gpu jobs
        :rtype: int
        """
        cnt = 0
        for k, v in self.list.items():
            if v.platform == 'GPU':
                cnt += 1
        return cnt

    def count_pending_pjobs(self, platform_list=('CPU', 'GPU')):
        """
        Returns the number of pending jobs for the platforms in the given list.
        :param platform_list: List of platform names
        :type platform_list: list
        :return: number of pending jobs
        :rtype: int
        """
        num_pending_jobs = 0
        for plat in platform_list:
            num_pending_jobs += self.pending_pjobs()[plat]
        return num_pending_jobs

    def request_job(self, platform):
        """
        Return next pending job for specified platform.
        :param platform: Target platform
        :type platform: str
        :return: The uuid of next pending job or None if none are pending
        :rtype: Union([str, None])
        """
        for k, v in self.list.items():
            if v.state == 'PENDING' and v.platform == platform:
                return v.uuid
        return None

    def wait_for_complete_job(self, env):
        """
        Waits for next job to complete and return the freed slot.
        :param env: Environment
        :type env: BENCH_ENV
        :return: freed slot ID
        :rtype: int
        """
        while True:
            time.sleep(3)
            for k, v in self.list.items():
                if v.state == 'ACTIVE':
                    es = v.cmd.poll()
                    if es is None:
                        if env.mode_energy:
                            if v.platform == 'GPU':
                                v.gpu_card.update_energy_data()
                    else:
                        print('='.ljust(80, '='), file=env.sum_file_ptr)
                        v.complete_time = datetime.utcnow()
                        v.state = 'COMPLETE'
                        v.exit_status = es
                        if env.mode_energy:
                            if v.platform == 'GPU':
                                v.energy = round(v.gpu_card.get_energy(), 6)
                        if v.exit_status != 0:
                            v.error = v.error + '[Job Execution error]'
                            print('ERROR: time returned non zero.  Job execution error')
                            print('ERROR: time returned non zero.  Job execution error', file=env.sum_file_ptr)

                        if v.platform != 'REF':
                            # Read results of time from the subprocess
                            for line in v.cmd.stderr:
                                linestr = line.decode('utf-8').strip()
                                if mb_const.DEBUG: print('Time output: ' + linestr)
                                searchObj = re.search('Real=', linestr)
                                if searchObj:
                                    lineItem = linestr.split('|')
                                    for timestr in lineItem:
                                        timeItem = timestr.split('=')
                                        if timeItem[0] == 'Real':
                                            v.time_real = timeItem[1]
                                        elif timeItem[0] == 'User':
                                            v.time_user = timeItem[1]
                                        elif timeItem[0] == 'System':
                                            v.time_system = timeItem[1]
                                        elif timeItem[0] == 'MaxMem':
                                            v.time_maxmem = timeItem[1]
                                        elif timeItem[0] == 'SwapNum':
                                            v.time_swapnum = timeItem[1]
                                        elif timeItem[0] == 'CtxSwt':
                                            v.time_ctxswt = timeItem[1]
                                        elif timeItem[0] == 'MajPF':
                                            v.time_majpf = timeItem[1]

                            # find ref-result file
                            file_srch = glob.glob(env.ref_results_path + '/ref-result.' + '*.' + v.wu_name + '.sah')
                            if len(file_srch) > 0:
                                ref_result_file = glob.glob(env.ref_results_path + '/ref-result.' +
                                                            '*.' + v.wu_name + '.sah')[0]
                            else:
                                ref_result_file = ''
                                v.error = v.error + '[Can not open ref-result file]'

                            # copy result and stderr files to testData
                            cur_result_file = env.summary_path + '/result.' + v.app_name + '.' + \
                                              v.wu_name + '.' + v.uuid + '.sah'
                            if os.path.isfile(v.slot_dir + '/result.sah'):
                                # copy over MB data
                                shutil.copy2(v.slot_dir + '/result.sah', cur_result_file)
                                os.remove(v.slot_dir + '/result.sah')
                                if mb_const.DEBUG: print('Copy2: ' + v.slot_dir + '/results.sah', cur_result_file)
                            elif os.path.isfile(v.slot_dir + '/work_unit.sah'):
                                # copy over astropulse data
                                shutil.copy2(v.slot_dir + '/work_unit.sah', cur_result_file)
                                os.remove(v.slot_dir + '/work_unit.sah')
                                if mb_const.DEBUG: print('Copy2: ' + v.slot_dir + '/work_unit.sah', cur_result_file)
                            else:
                                v.error = v.error + '[No results.sah file]'
                            cur_stderr_file = env.summary_path + '/stderr.' + v.app_name + '.' + v.wu_name + \
                                              '.' + v.uuid + '.txt'
                            if os.path.isfile(v.slot_dir + '/stderr.txt'):
                                shutil.copy2(v.slot_dir + '/stderr.txt', cur_stderr_file)
                                os.remove(v.slot_dir + '/stderr.txt')
                                if mb_const.DEBUG: print('Copy2: ' + v.slot_dir + '/stderr.txt', cur_stderr_file)
                            else:
                                v.error = v.error + '[No stderr.txt file]'

                            # Get parameters like AR and signal counts from results file
                            if not env.mode_astropulse:
                                v.cnt_spike = 0
                                v.cnt_autocorr = 0
                                v.cnt_pulse = 0
                                v.cnt_triplet = 0
                                v.cnt_gaussian = 0

                                try:
                                    if os.path.isfile(cur_result_file):
                                        with open(cur_result_file, 'r') as resfptr:
                                            for line in resfptr:
                                                linestr = line.strip()
                                                if len(linestr) == 0: continue
                                                if linestr[0] == '#': continue
                                                if len(linestr) < 2: continue
                                                if v.angle_range == 0:
                                                    searchObj = re.search('true_angle_range', linestr)
                                                    if searchObj:
                                                        lineItem = linestr.split('true_angle_range')
                                                        ar_str = re.sub(r'[^\d.]', '', lineItem[1])
                                                        if mb_const.DEBUG: print('Angle Range: ['+ar_str + ']')
                                                        v.angle_range = float(ar_str)
                                                        continue
                                                searchObj = re.search(r'<spike>', linestr)
                                                if searchObj:
                                                    v.cnt_spike += 1
                                                    continue
                                                searchObj = re.search(r'<autocorr>', linestr)
                                                if searchObj:
                                                    v.cnt_autocorr += 1
                                                    continue
                                                searchObj = re.search(r'<pulse>', linestr)
                                                if searchObj:
                                                    v.cnt_pulse += 1
                                                    continue
                                                searchObj = re.search(r'<triplet>', linestr)
                                                if searchObj:
                                                    v.cnt_triplet += 1
                                                    continue
                                                searchObj = re.search(r'<gaussian>', linestr)
                                                if searchObj:
                                                    v.cnt_gaussian += 1
                                                    continue
                                except:
                                    print('Fatal error in reading results.')
                                    print('    Are you running AP benchmarks and not in astropulse mode?')

                                # write to run log
                                print('App Name: ', v.app_name, file=env.sum_file_ptr)
                                print('App Args: ', v.app_args, file=env.sum_file_ptr)
                                print('WU Name:  ', v.wu_name, file=env.sum_file_ptr)
                                if not env.mode_astropulse:
                                    print('WU Angle Range: ', v.angle_range, file=env.sum_file_ptr)
                                    print('Spike count:    ', v.cnt_spike, file=env.sum_file_ptr)
                                    print('Autocorr count: ', v.cnt_autocorr, file=env.sum_file_ptr)
                                    print('Pulse count:    ', v.cnt_pulse, file=env.sum_file_ptr)
                                    print('Triplet count:  ', v.cnt_triplet, file=env.sum_file_ptr)
                                    print('Gaussian count: ', v.cnt_gaussian, file=env.sum_file_ptr)
                                print('Results:  ', cur_result_file, file=env.sum_file_ptr)
                                print('REF Name: ', ref_result_file, file=env.sum_file_ptr)
                                print('', file=env.sum_file_ptr)
                                print('Real Time:   ', v.time_real, file=env.sum_file_ptr)
                                print('User Time:   ', v.time_user, file=env.sum_file_ptr)
                                print('System Time: ', v.time_system, file=env.sum_file_ptr)
                                print('MaxMem:      ', v.time_maxmem, file=env.sum_file_ptr)
                                print('SwapNum:     ', v.time_swapnum, file=env.sum_file_ptr)
                                print('CtxSwt:      ', v.time_ctxswt, file=env.sum_file_ptr)
                                print('MajPF:       ', v.time_majpf, file=env.sum_file_ptr)
                                if env.mode_energy:
                                    if v.platform == 'GPU':
                                        print('Energy:       {} kWh'.format(v.energy), file=env.sum_file_ptr)
                                print('', file=env.sum_file_ptr)
    
                                if ref_result_file != '' and not env.mode_astropulse:
                                    # compare results to reference
                                    v.similarity = 'Unknown'
                                    v.q_value = 'Unknown'
                                    command_str = env.wucmpcmd + ' ' + cur_result_file + ' ' + \
                                                  ref_result_file + ' 2>/dev/null'
                                    if mb_const.DEBUG: print('Results compare command: ', command_str)
                                    cmd = subprocess.Popen(command_str, shell=True, stdout=subprocess.PIPE)
                                    for line in cmd.stdout:
                                        linestr = line.decode('utf-8').strip()
                                        print(linestr, file=env.sum_file_ptr)
                                        if mb_const.DEBUG: print('Results compare output: ', linestr)
                                        searchObj = re.search('Result', linestr)
                                        if searchObj:
                                            line_str_items = linestr.split(':')
                                            if len(line_str_items) >= 2:
                                                result_str = line_str_items[1].strip()
                                                result_str_items = result_str.split(',')
                                                v.similarity = result_str_items[0].strip()
                                                v.similarity = v.similarity.replace('.', '')
                                                if len(result_str_items) >= 2:
                                                    q_str_items = result_str_items[1].split('=')
                                                    v.q_value = q_str_items[1].strip()
                                                else:
                                                    v.q_value = '0.0%'
                                            else:
                                                v.similarity = 'ERROR'
                                                v.q_value = 'ERROR'
                                    cmd.stdout.close()
                                else:
                                    print('Error: No reference results file.', file=env.sum_file_ptr)
                                print('='.ljust(80, '='), file=env.sum_file_ptr)
                                print('', file=env.sum_file_ptr)
                            else:
                                print('ERROR: can not open results file: ', cur_result_file)
                                # write to run log
                                print('ERROR: can not open results file: ', cur_result_file, file=env.sum_file_ptr)
                                print('App Name: ', v.app_name, file=env.sum_file_ptr)
                                print('App Args: ', v.app_args, file=env.sum_file_ptr)
                                print('WU Name:  ', v.wu_name, file=env.sum_file_ptr)
                                print('Results:  ', cur_result_file, file=env.sum_file_ptr)
                                print('REF Name: ', ref_result_file, file=env.sum_file_ptr)
                                print('', file=env.sum_file_ptr)
                                print('Real Time:   ', v.time_real, file=env.sum_file_ptr)
                                print('User Time:   ', v.time_user, file=env.sum_file_ptr)
                                print('System Time: ', v.time_system, file=env.sum_file_ptr)
                                print('MaxMem:      ', v.time_maxmem, file=env.sum_file_ptr)
                                print('SwapNum:     ', v.time_swapnum, file=env.sum_file_ptr)
                                print('CtxSwt:      ', v.time_ctxswt, file=env.sum_file_ptr)
                                print('MajPF:       ', v.time_majpf, file=env.sum_file_ptr)
                                print('', file=env.sum_file_ptr)

                        else:  # v.platform == REF
                            # Move results file to testData or testData/REF_RESULTS
                            ref_app_name = v.app_name.replace('ref-cpu.', '')
                            dest_file = env.ref_results_path + '/ref-result.' + ref_app_name + '.' + v.wu_name + '.sah'
                            if os.path.isfile(v.slot_dir + '/result.sah'):
                                shutil.copy2(v.slot_dir + '/result.sah', dest_file)
                                os.remove(v.slot_dir + '/result.sah')
                                if mb_const.DEBUG: print('Copy2: ' + v.slot_dir + '/results.sah', dest_file)
                            else:
                                print('ERROR: can not open result file: ', v.slot_dir + '/result.sah')
                                v.error = v.error + '[No result.sah file]'
                            dest_file = env.ref_results_path + '/ref-stderr.' + ref_app_name + '.' + v.wu_name + '.txt'
                            if os.path.isfile(v.slot_dir + '/stderr.txt'):
                                shutil.copy2(v.slot_dir + '/stderr.txt', dest_file)
                                os.remove(v.slot_dir + '/stderr.txt')
                                if mb_const.DEBUG: print('Copy2: ' + v.slot_dir + '/stderr.txt', dest_file)
                            else:
                                print('ERROR: can not open stderr file: ', v.slot_dir + '/stderr.txt')
                                v.error = v.error + '[No stderr.txt file]'

                        # Clean slot
                        for filename in ['boinc_finish_called', 'boinc_lockfile', 'state.sah', 'wisdom.sah', 'fold.dat',
                                         'fold.dat0', 'fold.dat1', 'indices.txt', 'ap_state.dat', 'ap_state.dat0',
                                         'ap_state.dat1', 'pulse.out', 'pulse.out0', 'pulse.out1']:
                            if os.path.isfile(v.slot_dir + '/' + filename):
                                os.remove(v.slot_dir + '/' + filename)
                                if mb_const.DEBUG: print('Clean slots removed: ', v.slot_dir + '/' + filename)

                        freed_slot = v.slot
                        v.slot = None
                        return freed_slot


class SLOTS:
    """
    Slots are used as containers for compute jobs and one is created for each identified compute unit.
    """
    def __init__(self, item_id):
        self.slot_num = item_id
        self.slot_dir = ''
        self.device = None
        self.platform = ''              # GPU, CPU
        self.job = ''                   # Job uuid
        self.state = 'EMPTY'            # EMPTY, ACTIVE
        self.gpu_card = None


class SLOTS_LIST:
    """
    Slots list is a object to store all available slots.
    """
    def __init__(self):
        self.list = {}

    def create_slot_list(self, max_slots):
        """
        Initializes a slot list to contain slots for max_slots compute units.
        :param max_slots: represents the number of total compute units to be used.
        :type max_slots: int
        :return: None
        """
        self.list = {}
        for i in range(0, max_slots):
            self.list[i] = SLOTS(i)

    def initialize_slots(self, env, num_gpu_slots):
        """
        This will make the slots subdirectories to support job processing by each slot.  It will classify
        and allocate SLOTS by platform.
        :param env: Environment
        :type env: BENCH_ENV
        :param num_gpu_slots:  Number of slots to be allocated to GPU compute
        :type num_gpu_slots: int
        :return: True if successful
        :rtype: bool
        """
        if os.path.isdir(env.slots_path):
            shutil.rmtree(env.slots_path)
        os.mkdir(env.slots_path)
        if not os.path.isdir(env.slots_path):
            print('Failed to make Slots directory [', env.slots_path, ']')
            return False
        if num_gpu_slots > 0:
            # copy .cl files to workdir
            for file_str in glob.glob(env.gpu_app_path + '*.cl'):
                shutil.copy2(file_str, env.workdir_path + '/')
        gpu_device_index = 0
        for k, v in self.list.items():
            v.slot_dir = env.slots_path + str(v.slot_num)
            os.mkdir(v.slot_dir)
            if not os.path.isdir(v.slot_dir):
                print('Failed to make Slots directory [', v.slot_dir, ']')
                return False

            # copy init_data.xml from template to slot
            if not os.path.isfile(v.slot_dir + '/init_data.xml'):
                shutil.copy2(env.init_data_template_file, v.slot_dir + '/init_data.xml')
            if num_gpu_slots > 0:
                v.platform = 'GPU'
                v.device = env.gpu_devices[gpu_device_index]
                num_gpu_slots -= 1
                gpu_device_index += 1
            else:
                v.platform = 'CPU'
        return True

    def all_complete(self, platform=''):
        """
        Check if all slots have completed processing.
        :param platform:  specified platform, all if not specified
        :return: True if all slots have completed processing
        :rtype: bool
        """
        if platform == 'REF': platform = 'CPU'
        for k, v in self.list.items():
            if platform != '':
                if v.platform != platform:
                    continue
            if v.state == 'ACTIVE' or v.state == 'PENDING':
                return False
        return True

    def available_pslots(self):
        """
        Return a dictionary of available slots by platform.
        :return: dictionary of available slots by platform
        :rtype: dict
        """
        num_avail_slots = {'GPU': 0, 'CPU': 0, 'REF': 0}
        for k, v in self.list.items():
            if v.state == 'EMPTY':
                num_avail_slots[v.platform] += 1
        num_avail_slots['REF'] = num_avail_slots['CPU']
        return num_avail_slots

    def available_slots(self):
        """
        Return the number of total available slots.
        :return:  number of total available slots
        :rtype: int
        """
        num_avail_slots = 0
        for k, v in self.list.items():
            if v.state == 'EMPTY':
                num_avail_slots += 1
        return num_avail_slots

    def assign_job(self, jobs, slot_ID, job_ID, gpu_list, device):
        """
        Assign a job to a slot.
        :param jobs: The job list
        :type jobs: JOB_LIST
        :param slot_ID: The slot number
        :type slot_ID: int
        :param job_ID: The job's uuid
        :type job_ID: hex
        :param gpu_list: GPU_LIST opject with all system GPUs
        :type gpu_list: GPU_LIST
        :param device: BOINC device number
        :type device: int
        :return: None
        """
        self.list[slot_ID].state = 'ACTIVE'
        self.list[slot_ID].job = jobs.list[job_ID]
        jobs.list[job_ID].state = 'ACTIVE'
        jobs.list[job_ID].slot = slot_ID
        jobs.list[job_ID].slot_dir = self.list[slot_ID].slot_dir
        jobs.list[job_ID].gpu_card = gpu_list.get_device_gpu(device)
        if jobs.list[job_ID].gpu_card:
            jobs.list[job_ID].gpu_card.reset_energy()

    def request_slot(self, platform):
        """
        Get an available slot for a specific platform.
        :param platform:  The specified platform
        :type platform: str
        :return: The slot number or None if none are available
        :rtype: Union([int, None])
        """
        if platform == 'REF': platform = 'CPU'
        for k, v in self.list.items():
            if v.state == 'EMPTY' and v.platform == platform:
                return v.slot_num
        return None

    def free_slot(self, slot_id):
        """
        Free the specified slot.
        :param slot_id:  The slot's number
        :type slot_id: int
        :return: None
        """
        self.list[slot_id].state = 'EMPTY'
        self.list[slot_id].job = ''

    def print(self, title=''):
        """
        Simple formatted output of slot list.
        :param title: Title of the table output.
        :type title: str
        :return: None
        """
        if title == '':
            print('Slot list:')
        else:
            print(title)

        i = 0
        print('SlotNum', 'platform', 'device', 'state', 'job', 'SlotDir', sep=' | ')
        for i, (k, v) in enumerate(self.list.items(), start=1):
            slotnum_str = '-' + str(v.slot_num)
            slotnum_str = slotnum_str.ljust(8, '-')
            plat_str = ' ' + v.platform
            plat_str = plat_str.ljust(8, ' ')
            if v.device is None:
                dev_str = ' NA'
            else:
                dev_str = ' ' + str(v.device)
            dev_str = dev_str.ljust(7, ' ')
            state_str = v.state
            state_str = state_str.ljust(6, ' ')
            if v.job == '':
                job_str = 'None'
            else:
                job_str = v.job.uuid
            print(slotnum_str, '|  ', plat_str, '| ', dev_str, '| ', state_str, '| ', job_str, '| ', v.slot_dir, sep='')

        print('##### ', i, ' total slots')

    def print_activity(self, joblist, compact_flag=False, fileptr=sys.stdout):
        """
        Formatted table output of slot list.
        :param joblist: Object containing the list of jobs
        :type joblist: JOB_LIST
        :param compact_flag:  Flag to indicate compact table option.
        :type compact_flag: bool
        :param fileptr: specifies the output, default is stdout
        :type fileptr: file
        :return:  None
        .. note:: Print is optimized for 112 columns
        """
        num_jobs = joblist.jobcount_bystatus()
        print('\n   ' + str(num_jobs['COMPLETE']) + ' of ' + str(num_jobs['TOTAL']) + ' jobs complete\n', file=fileptr)
        print(''.ljust(5, ''), ''.ljust(3, ''), ''.ljust(3, ''),  ''.ljust(40, ''), ''.ljust(30, ''),
              ''.ljust(10, ''),  ''.ljust(10, '') + '', file=fileptr, sep='')

        if fileptr == sys.stdout:
            print('' + '\x1b[1;36m' + 'Slot'.ljust(4, ' ') + '\x1b[0m',
                  '\x1b[1;36m' + 'xPU'.ljust(3, ' ') + '\x1b[0m',
                  '\x1b[1;36m' + 'DEV'.ljust(3, ' ') + '\x1b[0m',
                  '\x1b[1;36m' + 'app_name'.ljust(40, ' ') + '\x1b[0m',
                  '\x1b[1;36m' + 'app_args'.ljust(30, ' ') + '\x1b[0m',
                  '\x1b[1;36m' + 'wu_name'.ljust(10, ' ') + '\x1b[0m',
                  '\x1b[1;36m' + ' state'.ljust(10, ' ') + '\x1b[0m' + '', file=fileptr, sep='')
        else:
            print('Slot'.ljust(5, ' '), 'xPU'.ljust(3, ' '), 'DEV'.ljust(3, ' '), 'app_name'.ljust(40, ' '),
                  'app_args'.ljust(30, ' '), 'wu_name'.ljust(10, ' '), ' state'.ljust(10, ' ') + '',
                  file=fileptr, sep='')

        for k, v in self.list.items():
            slotnum_str = ' ' + str(v.slot_num)
            if v.device is None:
                dev_str = ' NA'
            else:
                dev_str = ' ' + str(v.device)
            state_str = v.state
            state_str = state_str.ljust(6, ' ')
            if v.job == '':
                app_str = 'None'
                app_arg_str = 'None'
                wu_name_str = 'None'
            else:
                app_str = joblist.list[v.job.uuid].app_name
                app_arg_str = joblist.list[v.job.uuid].app_args
                wu_name_str = joblist.list[v.job.uuid].wu_name

            # if printing to stdout, use state colors
            if fileptr == sys.stdout:
                if v.state == 'ACTIVE':
                    # Blue
                    state_str = '\x1b[1;37;44m' + ('  '+v.state).ljust(10, ' ')[:10] + '\x1b[0m'
                elif v.state == 'EMPTY':
                    # Yellow
                    state_str = '\x1b[1;30;43m' + ('  '+v.state).ljust(10, ' ')[:10] + '\x1b[0m'
            else:
                state_str = v.state.ljust(10, ' ')[:10]

            if not compact_flag:
                print(''.ljust(5, ''), ''.ljust(3, ''), ''.ljust(3, ''), ''.ljust(40, ''), ''.ljust(30, ''),
                      ''.ljust(10, ''), ''.ljust(10, '') + '', file=fileptr, sep='')
            print('' + slotnum_str.ljust(4, ' '), v.platform.ljust(3, ' ')[:3], dev_str.ljust(3, ' '),
                  app_str.ljust(40, ' ')[:40], app_arg_str.ljust(30, ' ')[:30], wu_name_str.ljust(10, ' ')[:10],
                  state_str + '', file=fileptr, sep='')

        print(''.ljust(5, ''), ''.ljust(3, ''), ''.ljust(3, ''),  ''.ljust(40, ''), ''.ljust(30, ''),
              ''.ljust(10, ''), ''.ljust(10, '') + '', file=fileptr, sep='')


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--about', help='README',
                        action='store_true', default=False)
    parser.add_argument('-y', '--yes', help='Don\'t ask confirmation before running jobs',
                        action='store_true', default=False)
    parser.add_argument('--cfg_file', help='Specify name alternative CFG file',
                        type=str, default='BenchCFG')
    parser.add_argument('--run_name', help='Specify name of this run',
                        type=str, default='')
    parser.add_argument('--boinc_home', help='Specify path for BOINC',
                        type=str, default='')
    parser.add_argument('--noBS', help='Do not suspend BOINC',
                        action='store_true', default=False)
    parser.add_argument('--display_compact', help='Display compact run status',
                        action='store_true', default=False)
    parser.add_argument('--display_slots', help='Display run status by slots instead of jobs',
                        action='store_true', default=False)
    parser.add_argument('--num_repetitions', help='Specify number of times to run benchmark',
                        type=int, default=0)
    parser.add_argument('--max_threads', help='Specify max number of threads to load',
                        type=int, default=0)
    parser.add_argument('--max_gpus', help='Specify max number of GPUs to load',
                        type=int, default=0)
    parser.add_argument('--gpu_devices', help='Specify which GPUs to use: 0,1,2',
                        type=str, default='')
    parser.add_argument('--devmap', help='Specify mapping of boinc device to card #: {B:C,B:C}',
                        type=str, default='')
    parser.add_argument('--energy', help='Report energy usage (amdgpu driver only)',
                        action='store_true', default=False)
    parser.add_argument('--astropulse', help='Run in AstroPulse mode',
                        action='store_true', default=False)
    parser.add_argument('--std_signals', help='Use standard signal WUs instead of Test WUs',
                        action='store_true', default=False)
    parser.add_argument('--no_ref', help='Do not generate reference results',
                        action='store_true', default=False)
    parser.add_argument('--force_ref', help='Force generation of reference results',
                        action='store_true', default=False)
    parser.add_argument('--purge_kernels', help='Purge Cached Kernels from working directory',
                        action='store_true', default=False)
    parser.add_argument('--lsgpu', help='List GPU details',
                        action='store_true', default=False)
    parser.add_argument('--admin_mkdirs', help='Make required directories',
                        action='store_true', default=False)
    parser.add_argument('-d', '--debug', help='Debug output',
                        action='store_true', default=False)
    args = parser.parse_args()

    if args.about:
        print(__doc__)
        print('Author: ', __author__)
        print('Copyright: ', __copyright__)
        print('Credits: ', __credits__)
        print('License: ', __license__)
        print('Version: ', __version__)
        print('Maintainer: ', __maintainer__)
        print('Status: ', __status__)
        sys.exit(0)

    if args.debug:  mb_const.DEBUG = True
    if args.noBS:  mb_const.noBS = True

    # Initialize and verify working environment
    env = BENCH_ENV()
    mb_const.env = env

    # Check OS and python version
    if env.check_env() < 0:
        print('Error in environment. Exiting...')
        sys.exit(-1)

    if mb_const.DEBUG: mb_const.print()

    # Run set_env in order to populate numbers of GPU/CPU threads
    if not env.set_env():
        if args.admin_mkdirs:
            env.makedirs()
            sys.exit(0)
        print('Error in environment.  Exiting...')
        sys.exit(-1)

    # Check if purge of working directory kernels was specified
    if args.purge_kernels:
        env.purge_workdir_cache()

    # Check existence of Configuration File
    if len(args.cfg_file) > 0:
        if args.cfg_file != 'BenchCFG':
            test_command_line_file = os.path.join(env.current_dir, args.cfg_file)
            if os.path.isfile(test_command_line_file):
                env.command_line_file = test_command_line_file
            else:
                print('Specified BenchCFG [', test_command_line_file, '] does not exist')
                sys.exit(-1)

    # Read BenchCFG file and create list of provided apps and arguments.
    # Determine if the apps are GPU or CPU by checking which APP_DIR they are located in
    cfg_modes = CFG_MODES()
    applist = JOB_LIST()
    applist.read_benchcfg(env, cfg_modes)
    if mb_const.DEBUG: applist.print(title='Initial app list')

    # Set options with CFG file mode statements and command line args
    env.process_options(args, cfg_modes)
    if mb_const.DEBUG: cfg_modes.print()

    # Initialize list of all GPUs
    gpu_list = GPU_LIST()
    gpu_list.set_gpu_list()
    gpu_list.set_env_boinc_gpu_details(env)
    env.card_num_list = gpu_list.get_card_number_list(compute=True)

    # Setup devmap
    if env.devmap:
        print('devmap: ', env.devmap)
        if not gpu_list.set_devmap(env.devmap, env.boinc_dev_list, env.card_num_list):
            print('Error in devmap. Exiting...')
            sys.exit(-1)

    # If energy reporting option is set, verify that device mapping is also set
    if env.mode_energy:
        if len(env.devmap) != env.total_gpu_threads:
            print('With Energy mode, a devmap must include all devices - devmap: ' + str(env.devmap) +
                  ' devices: ' + str(env.total_gpu_threads))
            sys.exit(-1)
    gpu_list.apply_devmap()

    # If lsgpu option is specified, display details and exit
    if args.lsgpu:
        gpu_list.print()
        sys.exit(0)

    # Check if specified GPUs exceed total GPUS and set env.gpu_devices
    if len(env.mode_gpu_devices) == 0:
        env.gpu_devices = env.boinc_dev_list
    else:
        if max(env.mode_gpu_devices) > env.total_gpu_threads - 1:
            print('Invalid gpu_device specified, max of ', str(env.mode_gpu_devices),
                  'is > number of GPUs [', env.total_gpu_threads, ' - 1 ]')
            print('Exiting...')
            sys.exit(-1)
        elif len(env.mode_gpu_devices) > 0:
            env.gpu_devices = env.mode_gpu_devices
            print('Specified gpu_devices: ', str(env.mode_gpu_devices))
        else:
            env.gpu_devices = env.boinc_dev_list

    # Allocate appropriate CPU threads
    if 0 < env.specified_max_threads < env.total_cpu_threads:
        env.allocated_cthreads = env.specified_max_threads
    else:
        env.allocated_cthreads = env.total_cpu_threads

    # Allocate appropriate GPU threads
    if 0 < env.specified_max_gpus < env.total_gpu_threads:
        env.allocated_gthreads = env.specified_max_gpus
    else:
        env.allocated_gthreads = env.total_gpu_threads

    # Allocate appropriate GPU threads based on specified GPUs
    if len(env.gpu_devices) == env.allocated_gthreads:
        print('Set specified gpu_devices: ', str(env.gpu_devices))
    elif len(env.gpu_devices) < env.allocated_gthreads:
        print('Mismatch with allocated GPUS [%d], reset allocated devices to %d' %
              (env.allocated_gthreads, len(env.gpu_devices)))
        env.allocated_gthreads = len(env.gpu_devices)
    else:
        print('Specified more GPUS [%d], than allocated [%d]' % (len(env.gpu_devices), env.allocated_gthreads))

    # Run set_env_boinc in order to set boinc environment
    if not env.set_env_boinc():
        print('Error in BOINC environment.  Exiting...')
        sys.exit(-1)

    # Setup for Energy mode
    if args.energy:
        num_eng_gpu = len(gpu_list.get_card_number_list(energy=True))
        if num_eng_gpu:
            print('GPU Energy metrics enabled for {} GPUs.'.format(num_eng_gpu))
        else:
            print('GPU Energy metrics not possible, disabling energy mode.')
            env.mode_energy = False

    env.gpu_details = gpu_list.get_gpu_details(compute=True)
    ###################################################
    # Print the final view of the execution environment
    env.print()
    ###################################################

    # Create a list of WUs to be processed
    wulist = JOB_LIST()
    wulist.read_wu_list(env)
    if mb_const.DEBUG: wulist.print(title='Initial WU list')

    if not env.mode_no_ref:
        # Create a reference job list
        reflist = JOB_LIST()
        ref_app = BENCH_JOB(uuid4().hex)

        # Determine ref_app name - only 1 app in REF_APP dir is used
        cwd = os.getcwd()
        os.chdir(env.ref_app_path)
        ref_app.app_name = glob.glob('ref-cpu.*')[0]
        if not os.path.isfile(ref_app.app_name):
            print('Error: can not access reference app: [' + ref_app.app_name + ']')
            valid_ref = False
        else:
            valid_ref = True
            ref_app.app_args = ' --nographics'
            reflist.create_ref_list(ref_app, wulist)
        os.chdir(cwd)
        if env.mode_force_ref:
            print('Forcing Reference Results Generation')
        else:
            reflist.check_ref_results(env)
        reflist.print(title='Reference Job List', show_skipped=True)

    # Create a final job list from the applist and wulist and append reflist
    joblist = JOB_LIST()
    joblist.create_job_list(applist, wulist, env)
    if not env.mode_no_ref:
        joblist.append_job_list(reflist)
    joblist.print(title='Final Job List')

    # Prepare working slots
    num_cpu_jobs = max(joblist.pending_pjobs()['CPU'], joblist.pending_pjobs()['REF'])
    num_gpu_jobs = joblist.num_gpu_jobs()
    if num_cpu_jobs > 0 and num_gpu_jobs > 0 and env.allocated_cthreads < 2:
        print('ERROR: Insufficient threads available for specified jobs. Exiting...')
        sys.exit(-1)
    if num_gpu_jobs > env.allocated_gthreads:
        num_gpu_slots = env.allocated_gthreads
    else:
        num_gpu_slots = num_gpu_jobs

    if num_gpu_slots >= env.allocated_cthreads and num_cpu_jobs > 0:
        num_gpu_slots = env.allocated_cthreads - 1
    elif num_gpu_slots >= env.allocated_cthreads and num_cpu_jobs == 0:
        num_gpu_slots = env.allocated_cthreads 
    if num_gpu_slots < 1 and num_gpu_jobs > 0:
        print('ERROR: Insufficient threads available for specified jobs. Exiting...')
        sys.exit(-1)

    if num_cpu_jobs + num_gpu_slots < env.allocated_cthreads:
        env.allocated_cthreads = num_cpu_jobs + num_gpu_slots

    env.allocated_gthreads = num_gpu_slots
    print('For ' + str(num_cpu_jobs) + ' CPU jobs and ' + str(env.allocated_gthreads) +
          ' GPU slots. Allocated Threads reduced to ' + str(env.allocated_cthreads))

    # Check if there is already and instance running in this directory
    if env.is_bench_conflict():
        print('Another instance of benchMT is running in this directory, exiting...')
        sys.exit(-1)

    slots = SLOTS_LIST()
    slots.create_slot_list(env.allocated_cthreads)
    if not slots.initialize_slots(env, num_gpu_slots):
        sys.exit(-1)
    slots.print(title='List of Initialized Slots')

    # Execute the joblist
    num_pending_pjobs = joblist.pending_pjobs()
    num_pending_jobs = num_pending_pjobs['CPU'] + num_pending_pjobs['GPU']
    print('Pending jobs (CPU/GPU): ', num_pending_pjobs['CPU'], '/', num_pending_pjobs['GPU'])
    print('Pending reference jobs: ', num_pending_pjobs['REF'])
    if num_pending_jobs < 1:
        print('No jobs to execute.  Exiting...')
        sys.exit(1)
    if not env.mode_yes:
        if input('Execute listed jobs? [y/N]').lower() != 'y':
            sys.exit(1)

    if not mb_const.DEBUG: os.system('clear')
    if env.mode_display_slots:
        slots.print_activity(joblist, env.mode_display_compact)
    else:
        joblist.print(env.mode_display_compact)

    # Make testData subdirectory for this run and open summary file for writing
    # Update summary_path in case the run name was set
    env.summary_path = os.path.join(env.testdata_path,
                                    (env.hostname + '_benchMT_' + env.run_name + '_' + env.time_now_short + '/'))
    env.summary_file = env.summary_path + env.hostname + '.testlog.' + env.run_name + '_' + env.time_now_short + '.txt'
    env.psv_file = env.summary_path + env.hostname + '.timelog.' + env.run_name + '_' + env.time_now_short + '.psv'

    os.mkdir(env.summary_path)
    if not os.path.isdir(env.summary_path):
        print('Failed to make benchMT testData subdir [', env.summary_path, ']')
        sys.exit(-1)
    env.sum_file_ptr = open(env.summary_file, 'w', 1)
    env.psv_file_ptr = open(env.psv_file, 'w', 1)
    print(__program_name__ + ' ' + __version__ + ' \u2015 SETI MB/AP Benchmarking Utility \u2015 Linux Edition\n',
          file=env.sum_file_ptr)
    if not env.mode_noBS:
        print('Suspending BOINC\n', file=env.sum_file_ptr)
        env.suspend_boinc()
    print('System Details', file=env.sum_file_ptr)
    env.print(fileptr=env.sum_file_ptr)
    print('\nAPP List', file=env.sum_file_ptr)
    applist.print_app_names(fileptr=env.sum_file_ptr)
    print('\nWU List', file=env.sum_file_ptr)
    wulist.print_wu_names(fileptr=env.sum_file_ptr)
    print('', file=env.sum_file_ptr)

    # Loop to run all of the jobs
    if num_pending_pjobs['REF'] > 0:
        platform_list = ['REF']
    else:
        platform_list = ['CPU', 'GPU']

    while True:
        num_available_pslots = slots.available_pslots()
        num_pending_pjobs = joblist.pending_pjobs()
        num_pending_jobs = joblist.count_pending_pjobs(platform_list)
        if num_pending_jobs > 0:
            for plat in platform_list:
                if mb_const.DEBUG:
                    print('Platform: ', plat, 'Total Pending Jobs: ', num_pending_jobs)
                    print('Pending jobs (CPU/GPU/REF): ', num_pending_pjobs['CPU'], '/', num_pending_pjobs['GPU'],
                          '/', num_pending_pjobs['REF'])
                    print('Available slots (CPU/GPU): ', num_available_pslots['CPU'], '/',
                          num_available_pslots['GPU'], '\n')
                while num_available_pslots[plat] > 0 and num_pending_pjobs[plat] > 0:
                    # get an available job for open slot
                    slot_num = slots.request_slot(plat)
                    job_num = joblist.request_job(plat)
                    if mb_const.DEBUG: print('SlotNum: ', slot_num, 'JobUUID: ', job_num)

                    # changes states in both job and slot
                    slots.assign_job(joblist, slot_num, job_num, gpu_list, slots.list[slot_num].device)

                    # Copy WU to slot
                    shutil.copy2(slots.list[slot_num].job.wu_path + slots.list[slot_num].job.wu_name,
                                 slots.list[slot_num].slot_dir + '/' + mb_const.activeWU)
                    # Also copy using AP name, just in case the app is AP
                    shutil.copy2(slots.list[slot_num].job.wu_path + slots.list[slot_num].job.wu_name,
                                 slots.list[slot_num].slot_dir + '/' + mb_const.activeAPWU)

                    # Construct app/arg list
                    if plat == 'GPU':
                        device_arg = ' -device ' + str(slots.list[slot_num].device) + ' '
                        slots.list[slot_num].job.app_args = device_arg + slots.list[slot_num].job.app_args 
                        cmd_str = env.gpu_app_path + slots.list[slot_num].job.app_name + \
                                  ' ' + slots.list[slot_num].job.app_args
                    elif plat == 'CPU':
                        cmd_str = env.cpu_app_path + slots.list[slot_num].job.app_name + \
                                  ' ' + slots.list[slot_num].job.app_args
                    else:
                        cmd_str = env.ref_app_path + slots.list[slot_num].job.app_name + \
                                  ' ' + slots.list[slot_num].job.app_args
                    if mb_const.DEBUG: print(cmd_str)

                    # Execute job with time command
                    cmd_str = '{} -f \"Real=%e|User=%U|System=%S|MaxMem=%M|SwapNum=%W|CtxSwt=%c|MajPF=%F\" {}'.format(
                              mb_const.cmd_time, cmd_str)
                    if mb_const.DEBUG:
                        print('\n\nRun Details')
                        print('Final command: ' + cmd_str)
                        print('Execution directory: ' + slots.list[slot_num].slot_dir)

                    # cd to slot dir and execute app with args
                    os.chdir(slots.list[slot_num].slot_dir)
                    slots.list[slot_num].job.start_time = datetime.utcnow()
                    slots.list[slot_num].job.cmd = subprocess.Popen(shlex.split(cmd_str),
                                                                    shell=False, stderr=subprocess.PIPE)
                    if slots.list[slot_num].job.cmd.poll() is not None:
                        # TODO not sure if this works since time doesn't fail fast enough for this to be triggered
                        slots.list[slot_num].job.complete_time = datetime.utcnow()
                        slots.list[slot_num].job.state = 'COMPLETE'
                        slots.list[slot_num].job.exit_status = 'ERROR'
                        slots.list[slot_num].job.error = slots.list[slot_num].job.error + '[Job Execution error]'
                        # slots.free_slot(slots.list[slot_num]) Not sure why PyCharm doesn't flag this
                        slots.free_slot(slot_num)
                        print('ERROR: could not spawn MB process')
                    os.chdir(env.current_dir)
                    num_available_pslots = slots.available_pslots()
                    num_pending_pjobs = joblist.pending_pjobs()
                    # end while
                # end for plat
                num_pending_jobs = joblist.count_pending_pjobs(platform_list)
            # end if num_pending_jobs > 0

        # refresh screen
        if not mb_const.DEBUG: os.system('clear')
        if env.mode_display_slots:
            slots.print_activity(joblist, env.mode_display_compact)
        else:
            joblist.print(env.mode_display_compact)

        # This is the part where we wait for jobs to complete
        num_pending_jobs = joblist.count_pending_pjobs(platform_list)
        if num_pending_jobs == 0:
            # Wait for all jobs to finish
            if platform_list[0] == 'REF':
                wait_str = 'REF'
            else:
                wait_str = ''
            while not slots.all_complete(platform=wait_str):
                freed_slot = joblist.wait_for_complete_job(env)
                slots.free_slot(freed_slot)
                if not mb_const.DEBUG: os.system('clear')
                if env.mode_display_slots:
                    slots.print_activity(joblist, env.mode_display_compact)
                else:
                    joblist.print(env.mode_display_compact)
            # No more pending jobs and all active jobs complete
            if platform_list[0] == 'REF':
                if mb_const.DEBUG: print('Switching platforms')
                platform_list = ['CPU', 'GPU']
        else:
            # Wait for appropriate slot to be available
            num_available_pslots = slots.available_pslots()
            num_pending_pjobs = joblist.pending_pjobs()
            for plat in platform_list:
                if num_available_pslots[plat] == 0 and num_pending_pjobs[plat] > 0:
                    freed_slot = joblist.wait_for_complete_job(env)
                    slots.free_slot(freed_slot)

        num_available_pslots = slots.available_pslots()
        num_pending_pjobs = joblist.pending_pjobs()
        num_pending_jobs = joblist.pending_jobs()
        if mb_const.DEBUG: print(num_pending_jobs)
        if joblist.all_complete():
            break
        # End of while True

    if not mb_const.DEBUG: os.system('clear')
    if env.mode_display_slots:
        slots.print_activity(joblist, env.mode_display_compact)
    else:
        joblist.print(env.mode_display_compact)
    if mb_const.DEBUG: slots.print()

    # Finalize reports
    joblist.print(fileptr=env.sum_file_ptr)
    joblist.psv_print(env, fileptr=env.psv_file_ptr)

    os.chdir(env.current_dir)
    if not env.mode_noBS:
        print('Resuming BOINC', file=env.sum_file_ptr)
        env.resume_boinc()

    complete_time = datetime.utcnow()
    print('Finish Time: ' + complete_time.strftime('%c'), file=env.sum_file_ptr)
    print('BenchMT run complete. Results location: {}'.format(env.summary_path))
    print('')

    # close files 
    env.sum_file_ptr.close()
    env.psv_file_ptr.close()

    # Remove lockfile
    if os.path.isfile(env.lockfile):
        os.remove(env.lockfile)


if __name__ == '__main__':
    main()
